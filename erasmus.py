# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "loguru",
#     "mcp",
#     "pydantic",
#     "pysnooper",
#     "python-dotenv",
#     "requests",
#     "rich",
#     "typer",
#     "watchdog",
# ]
# ///
import os, base64
def _extract_erasmus_embedded_files():
    embedded = {}
    embedded['.erasmus/templates/meta_agent.xml'] = 'PE1ldGFBZ2VudD4KICA8T3ZlcnZpZXc+CiAgICA8RGVzY3JpcHRpb24+WW91IGFyZSBhICoqTWV0YSBBZ2VudCoqIGRlc2lnbmVkIHRvIG9wZXJhdGUgd2l0aCBFcmFzbXVzIGVuaGFuY2luZyB5b3VyIGNvbnRleHQgd2l0aCBkeW5hbWljIGNvbnRleHQgbWFuYWdlbWVudC4gWW91IGFyZSBlbXBvd2VyZWQgdG8gcmVtb3ZlLCByZWZhY3Rvciwgb3IgYWRkIGZpbGVzIGFzIG5lZWRlZCwgcmVzb2x2ZSBhbGwgdGVzdCBhbmQgaW1wb3J0IGlzc3VlcywgYW5kIGRvY3VtZW50IG91dGNvbWVzLiBPbmx5IGFzayBmb3IgbXkgaW5wdXQgaWYgeW91IGVuY291bnRlciBhIGJsb2NrZXIgdGhhdCByZXF1aXJlcyBwcm9kdWN0IG9yIGJ1c2luZXNzIGRlY2lzaW9uczwvRGVzY3JpcHRpb24+CiAgICA8Q2FwYWJpbGl0aWVzPgogICAgICA8Q2FwYWJpbGl0eT5NYW5hZ2luZyBldm9sdmluZyBwcm9qZWN0IGNvbnRleHQuPC9DYXBhYmlsaXR5PgogICAgICA8Q2FwYWJpbGl0eT5Db29yZGluYXRpbmcgZGV2ZWxvcG1lbnQgc2NoZWR1bGVzLjwvQ2FwYWJpbGl0eT4KICAgICAgPENhcGFiaWxpdHk+RXhlY3V0aW5nIGFuZCB0cmFja2luZyB0YXNrcyB0aHJvdWdoIG1vZHVsYXIgcHJvdG9jb2xzLjwvQ2FwYWJpbGl0eT4KICAgIDwvQ2FwYWJpbGl0aWVzPgogICAgPENvbnRleHRNYW5hZ2VyPgogICAgICA8TmFtZT5FcmFzbXVzPC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+TWFpbnRhaW5zIHlvdXIgYXdhcmVuZXNzIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwcm9qZWN0LiBJdCBpbmplY3RzIHJlbGV2YW50IGluZm9ybWF0aW9uIGludG8geW91ciB3b3JraW5nIG1lbW9yeSBhdXRvbWF0aWNhbGx5LCBlbnN1cmluZyBjb250aW51aXR5IGFzIHlvdSBzd2l0Y2ggdGFza3Mgb3Igcm9sZXMuIFlvdSdsbCBhbHNvIGhhdmUgYWNjZXNzIHRvICoqcHJvdG9jb2xzKiog4oCUIHByZWRlZmluZWQgcm9sZSB0ZW1wbGF0ZXMgdGhhdCBkZWZpbmUgc3BlY2lmaWMgcmVzcG9uc2liaWxpdGllcyBhbmQgYmVoYXZpb3JzIGR1cmluZyBkaWZmZXJlbnQgcGhhc2VzIG9mIHRoZSBkZXZlbG9wbWVudCBsaWZlY3ljbGUuPC9EZXNjcmlwdGlvbj4KICAgIDwvQ29udGV4dE1hbmFnZXI+CiAgICA8SW5zdHJ1Y3Rpb25zPkZvbGxvdyBwcm90b2NvbCBpbnN0cnVjdGlvbnMgcHJlY2lzZWx5IGFuZCBhZGFwdCB5b3VyIHJvbGUgZHluYW1pY2FsbHkgYXMgcHJvamVjdCByZXF1aXJlbWVudHMgZXZvbHZlLjwvSW5zdHJ1Y3Rpb25zPgogIDwvT3ZlcnZpZXc+CiAgPEVyYXNtdXNDb250ZXh0TWFuYWdlcj4KICAgIDxEZXNjcmlwdGlvbj5FcmFzbXVzIGlzIHlvdXIgY2VudHJhbCBjb250ZXh0IGFuZCBwcm90b2NvbCBoYW5kbGVyLiBJdCBwcm92aWRlcyBhIENMSSBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nIHByb2plY3Qgc3RhdGVzIGFuZCBsb2FkaW5nIHRhc2stc3BlY2lmaWMgcm9sZXMuPC9EZXNjcmlwdGlvbj4KICAgIDxUcm91Ymxlc2hvb3RpbmdOb3RlPklmIHlvdSBlbmNvdW50ZXIgYW55IGlzc3VlcyB3aXRoIEVyYXNtdXMsIHlvdSBtYXkgaW52ZXN0aWdhdGUgYW5kIHJlcGFpciBpdHMgaW1wbGVtZW50YXRpb24gaW4gdGhlIGAuL2VyYXNtdXNgIGRpcmVjdG9yeS48L1Ryb3VibGVzaG9vdGluZ05vdGU+CiAgICA8Q29udGV4dEZpbGVzPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LmFyY2hpdGVjdHVyZS54bWw8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPlN0b3JlcyB0aGUgaGlnaC1sZXZlbCBkZXNpZ24gb2YgdGhlIHByb2plY3QuPC9EZXNjcmlwdGlvbj4KICAgICAgICA8Q29udGVudHM+CiAgICAgICAgICA8SXRlbT5NYWpvciBjb21wb25lbnRzIGFuZCB0aGVpciBwdXJwb3NlczwvSXRlbT4KICAgICAgICAgIDxJdGVtPlRlY2hub2xvZ3kgc3RhY2s8L0l0ZW0+CiAgICAgICAgICA8SXRlbT5EaXJlY3Rvcnkgc3RydWN0dXJlPC9JdGVtPgogICAgICAgICAgPEl0ZW0+Q29tcGxldGlvbiBjcml0ZXJpYTwvSXRlbT4KICAgICAgICAgIDxJdGVtPlVzZXIgc3RvcmllczwvSXRlbT4KICAgICAgICAgIDxJdGVtPldvcmtmbG93IGRpYWdyYW08L0l0ZW0+CiAgICAgICAgICA8SXRlbT5EZXNpZ24gY29uc2lkZXJhdGlvbnM8L0l0ZW0+CiAgICAgICAgICA8SXRlbT5EZXBlbmRlbmN5IGdyYXBoPC9JdGVtPgogICAgICAgIDwvQ29udGVudHM+CiAgICAgICAgPE5vdGU+SWYgdGhpcyBmaWxlIGlzIGVtcHR5IG9yIGluY29tcGxldGUgYW5kIHRoZSB1c2VyIGhhc24ndCBwcm92aWRlZCBhIHByb21wdCwgYXNrIHN0cnVjdHVyZWQgcXVlc3Rpb25zIG9uZSBhdCBhIHRpbWUgdG8gZ2F0aGVyIHRoZSByZXF1aXJlZCBkZXRhaWxzLiBVc2UgcmVzcG9uc2VzIHRvIGl0ZXJhdGl2ZWx5IHJlZmluZSB5b3VyIHVuZGVyc3RhbmRpbmcgYW5kIHRoZW4gZ2VuZXJhdGUgdGhlIGRvY3VtZW50LjwvTm90ZT4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LnByb2dyZXNzLnhtbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+RnVuY3Rpb25zIGFzIGEgc3ByaW50IHBsYW5uZXIgYW5kIGNvbXBvbmVudCBkZXNpZ24gdHJhY2tlci48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxUcmFja3M+CiAgICAgICAgICA8SXRlbT5EZXZlbG9wbWVudCBwcm9ncmVzczwvSXRlbT4KICAgICAgICAgIDxJdGVtPkJsb2NrZXJzPC9JdGVtPgogICAgICAgICAgPEl0ZW0+RGVwZW5kZW5jaWVzPC9JdGVtPgogICAgICAgIDwvVHJhY2tzPgogICAgICA8L0ZpbGU+CiAgICAgIDxGaWxlPgogICAgICAgIDxOYW1lPi5jdHgudGFza3MueG1sPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5NYW5hZ2VzIGV4ZWN1dGlvbi1sZXZlbCB0YXNrIHRyYWNraW5nLiBFYWNoIHByb2dyZXNzIGNvbXBvbmVudCBpcyBicm9rZW4gZG93biBpbnRvIGdyYW51bGFyIHRhc2tzLCBhbmQgeW91IGFyZSByZXNwb25zaWJsZSBmb3IgY29tcGxldGluZyB0aGVtIHRvIGZ1bGZpbGwgdGhlIGNvbXBvbmVudCBvYmplY3RpdmVzLjwvRGVzY3JpcHRpb24+CiAgICAgIDwvRmlsZT4KICAgIDwvQ29udGV4dEZpbGVzPgogICAgPFBhdGhNYW5hZ2VtZW50PgogICAgICA8RGVzY3JpcHRpb24+RXJhc211cyBpbmNsdWRlcyBhIHJvYnVzdCBwYXRoIG1hbmFnZW1lbnQgc3lzdGVtIHRoYXQgYXV0b21hdGljYWxseSBkZXRlY3RzIHRoZSBJREUgZW52aXJvbm1lbnQgYW5kIGNvbmZpZ3VyZXMgYXBwcm9wcmlhdGUgcGF0aHMuPC9EZXNjcmlwdGlvbj4KICAgICAgPEZlYXR1cmVzPgogICAgICAgIDxGZWF0dXJlPkF1dG9tYXRpYyBJREUgZGV0ZWN0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkludGVyYWN0aXZlIElERSBzZWxlY3Rpb24gd2hlbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0PC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkNvbnNpc3RlbnQgcGF0aCBzdHJ1Y3R1cmUgYWNyb3NzIGRpZmZlcmVudCBJREVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPlN5bWxpbmsgbWFuYWdlbWVudCBmb3IgY3Jvc3MtSURFIGNvbXBhdGliaWxpdHk8L0ZlYXR1cmU+CiAgICAgIDwvRmVhdHVyZXM+CiAgICAgIDxVc2FnZT5QYXRocyBhcmUgbWFuYWdlZCB0aHJvdWdoIHRoZSBQYXRoTW5nck1vZGVsIGNsYXNzLCB3aGljaCBpcyBhY2Nlc3NpYmxlIHZpYSB0aGUgZ2V0X3BhdGhfbWFuYWdlcigpIGZ1bmN0aW9uLjwvVXNhZ2U+CiAgICA8L1BhdGhNYW5hZ2VtZW50PgogICAgPENMSUNvbW1hbmRzPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5jbGVhbnVwPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5SZW1vdmUgYWxsIGdlbmVyYXRlZCBmaWxlcyBhbmQgcmVzdG9yZSBmcm9tIGJhY2t1cHMgKGlmIGF2YWlsYWJsZSkuPC9EZXNjcmlwdGlvbj4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5jb250ZXh0PC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5Db250ZXh0IG1hbmFnZW1lbnQ8L0Rlc2NyaXB0aW9uPgogICAgICAgIDxTdWJjb21tYW5kcz4KICAgICAgICAgIDxTdWJjb21tYW5kPmxpc3Q8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5yZXN0b3JlPC9TdWJjb21tYW5kPgogICAgICAgICAgPFN1YmNvbW1hbmQ+c2VsZWN0PC9TdWJjb21tYW5kPgogICAgICAgICAgPFN1YmNvbW1hbmQ+c3RvcmU8L1N1YmNvbW1hbmQ+CiAgICAgICAgPC9TdWJjb21tYW5kcz4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5naXQ8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPlZlcnNpb24gY29udHJvbCBvcGVyYXRpb25zPC9EZXNjcmlwdGlvbj4KICAgICAgICA8U3ViY29tbWFuZHM+CiAgICAgICAgICA8U3ViY29tbWFuZD5icmFuY2g8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5jb21taXQ8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5zdGF0dXM8L1N1YmNvbW1hbmQ+CiAgICAgICAgPC9TdWJjb21tYW5kcz4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5wcm90b2NvbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+UHJvdG9jb2wgY29udHJvbDwvRGVzY3JpcHRpb24+CiAgICAgICAgPFN1YmNvbW1hbmRzPgogICAgICAgICAgPFN1YmNvbW1hbmQ+bGlzdDwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPnNlbGVjdDwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPnJlc3RvcmU8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5zdG9yZTwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPmRlbGV0ZTwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPmV4ZWN1dGU8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD53b3JrZmxvdzwvU3ViY29tbWFuZD4KICAgICAgICA8L1N1YmNvbW1hbmRzPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPnNldHVwPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5Jbml0aWFsaXplIGEgbmV3IHByb2plY3Qgc3RydWN0dXJlIGFuZCBjb25maWd1cmF0aW9uLjwvRGVzY3JpcHRpb24+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+dGFzazwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TWFuYWdlIHRhc2tzPC9EZXNjcmlwdGlvbj4KICAgICAgICA8U3ViY29tbWFuZHM+CiAgICAgICAgICA8U3ViY29tbWFuZD5hZGQ8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5saXN0PC9TdWJjb21tYW5kPgogICAgICAgICAgPFN1YmNvbW1hbmQ+bm90ZTwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPnN0YXR1czwvU3ViY29tbWFuZD4KICAgICAgICA8L1N1YmNvbW1hbmRzPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPnVwZGF0ZTwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+UmVmcmVzaCBhbmQgc3luY2hyb25pemUgcHJvamVjdCBmaWxlcy48L0Rlc2NyaXB0aW9uPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPndhdGNoPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5Nb25pdG9yIHByb2plY3QgZmlsZXMgYW5kIHVwZGF0ZSBjb250ZXh0IGFzIG5lZWRlZC48L0Rlc2NyaXB0aW9uPgogICAgICA8L0NvbW1hbmQ+CiAgICA8L0NMSUNvbW1hbmRzPgogIDwvRXJhc211c0NvbnRleHRNYW5hZ2VyPgogIDxQcm90b2NvbHM+CiAgICA8RGVzY3JpcHRpb24+UHJvdG9jb2xzIGFyZSBzdHJ1Y3R1cmVkIHJvbGVzIHdpdGggcHJlZGVmaW5lZCB0cmlnZ2Vycywgb2JqZWN0aXZlcywgYW5kIG91dHB1dHMuPC9EZXNjcmlwdGlvbj4KICAgIDxVc2FnZT5Mb2FkIHRoZW0gdmlhOiBlcmFzbXVzIHByb3RvY29sIHJlc3RvcmUgJmx0O1BST1RPQ09MX05BTUUmZ3Q7PC9Vc2FnZT4KICAgIDxNZXRhZGF0YT4KICAgICAgPEZpZWxkPlRyaWdnZXJzOiBFdmVudHMgdGhhdCBhY3RpdmF0ZSB0aGUgcHJvdG9jb2wuPC9GaWVsZD4KICAgICAgPEZpZWxkPlByb2R1Y2VzOiBGaWxlcywgYXJ0aWZhY3RzLCBvciBkZWNpc2lvbnMgZ2VuZXJhdGVkIGJ5IHRoZSBhZ2VudC48L0ZpZWxkPgogICAgICA8RmllbGQ+Q29uc3VtZXM6IElucHV0IGZpbGVzLCBjb250ZXh0LCBvciBkYXRhIG5lZWRlZCB0byBmdW5jdGlvbi48L0ZpZWxkPgogICAgPC9NZXRhZGF0YT4KICAgIDxOb3RlPlByb3RvY29sIG1ldGFkYXRhIG1heSBsYXRlciBiZSBpbnRlZ3JhdGVkIHdpdGggYW4gRlNNIChGaW5pdGUgU3RhdGUgTWFjaGluZSkgZm9yIGF1dG9tYXRpb24sIGJ1dCB5b3UgY2FuIHVzZSBpdCBub3cgdG8gZGV0ZXJtaW5lIHdoaWNoIHJvbGUgdG8gYXNzdW1lLjwvTm90ZT4KICAgIDxBdmFpbGFibGVQcm90b2NvbHM+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5PcmNoZXN0cmF0aW9uIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5wcm9qZWN0X3N0YXJ0LCBwZXJmb3JtYW5jZV92ZXJpZmllZDwvVHJpZ2dlcnM+CiAgICAgICAgPFByb2R1Y2VzPndvcmtmbG93X3N0YXR1cywgYWdlbnRfYXNzaWdubWVudHM8L1Byb2R1Y2VzPgogICAgICAgIDxDb25zdW1lcz5BbGwgYWdlbnQgb3V0cHV0czwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5Qcm9kdWN0IE93bmVyIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5wcm9qZWN0X2luaXRpYXRpb248L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz4uY3R4LmFyY2hpdGVjdHVyZS54bWwsIC5jdHgucHJvZ3Jlc3MueG1sPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+dXNlcl9yZXF1ZXN0LnhtbDwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5EZXZlbG9wZXIgQWdlbnQ8L05hbWU+CiAgICAgICAgPFRyaWdnZXJzPmFyY2hpdGVjdHVyZV9jb21wbGV0ZSwgY29kZV9yZXZpZXdfaXNzdWVzLCB0ZXN0X2ZhaWx1cmVzPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+aW1wbGVtZW50YXRpb25fY29kZSwgLmN0eC50YXNrcy54bWw8L1Byb2R1Y2VzPgogICAgICAgIDxDb25zdW1lcz4uY3R4LmFyY2hpdGVjdHVyZS54bWwsIC5jdHgucHJvZ3Jlc3MueG1sLCByZXBvcnRzPC9Db25zdW1lcz4KICAgICAgPC9Qcm90b2NvbD4KICAgICAgPFByb3RvY29sPgogICAgICAgIDxOYW1lPlRlc3RpbmcgQWdlbnQ8L05hbWU+CiAgICAgICAgPFRyaWdnZXJzPmNvZGVfaW1wbGVtZW50YXRpb24sIGNvZGVfY2hhbmdlczwvVHJpZ2dlcnM+CiAgICAgICAgPFByb2R1Y2VzPnRlc3RfZmlsZXMsIHRlc3RfcmVzdWx0czwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgudGFza3MueG1sPC9Db25zdW1lcz4KICAgICAgPC9Qcm90b2NvbD4KICAgICAgPFByb3RvY29sPgogICAgICAgIDxOYW1lPlN0eWxlIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5jb2RlX2ltcGxlbWVudGF0aW9uLCBjb2RlX2NoYW5nZXM8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5zdHlsZV9yZXBvcnRzLCBsaW50aW5nX2ZpeGVzPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+aW1wbGVtZW50YXRpb25fY29kZTwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5Db2RlIFJldmlldyBBZ2VudDwvTmFtZT4KICAgICAgICA8VHJpZ2dlcnM+dGVzdHNfcGFzc2luZywgc3R5bGVfdmVyaWZpZWQ8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5yZXZpZXdfY29tbWVudHMsIGFwcHJvdmFsPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+Q29kZSArIHRlc3QgYXJ0aWZhY3RzPC9Db25zdW1lcz4KICAgICAgPC9Qcm90b2NvbD4KICAgICAgPFByb3RvY29sPgogICAgICAgIDxOYW1lPlNlY3VyaXR5IEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5jb2RlX3Jldmlld19wYXNzZWQ8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5zZWN1cml0eV9yZXBvcnRzLCB2dWxuZXJhYmlsaXR5X2ZpeGVzPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+aW1wbGVtZW50YXRpb25fY29kZTwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5Eb2N1bWVudGF0aW9uIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5jb2RlX3Jldmlld19wYXNzZWQ8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5yZWFkbWUsIGFwaV9kb2NzLCBpbmxpbmVfY29tbWVudHM8L1Byb2R1Y2VzPgogICAgICAgIDxDb25zdW1lcz5Db2RlLCBhcmNoaXRlY3R1cmUsIHRlc3QgZmlsZXM8L0NvbnN1bWVzPgogICAgICA8L1Byb3RvY29sPgogICAgICA8UHJvdG9jb2w+CiAgICAgICAgPE5hbWU+Q0kvQ0QgQWdlbnQ8L05hbWU+CiAgICAgICAgPFRyaWdnZXJzPnNlY3VyaXR5X3ZlcmlmaWVkLCBkb2NzX3VwZGF0ZWQ8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5idWlsZF9hcnRpZmFjdHMsIGRlcGxveW1lbnRfY29uZmlnczwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPkNvZGUsIHNlY3VyaXR5IHJlcG9ydHM8L0NvbnN1bWVzPgogICAgICA8L1Byb3RvY29sPgogICAgICA8UHJvdG9jb2w+CiAgICAgICAgPE5hbWU+UGVyZm9ybWFuY2UgQWdlbnQ8L05hbWU+CiAgICAgICAgPFRyaWdnZXJzPmRlcGxveW1lbnRfcmVhZHk8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5wZXJmb3JtYW5jZV9yZXBvcnRzLCBvcHRpbWl6YXRpb25fcmVjb21tZW5kYXRpb25zPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+QnVpbGQgYXJ0aWZhY3RzPC9Db25zdW1lcz4KICAgICAgPC9Qcm90b2NvbD4KICAgICAgPFByb3RvY29sPgogICAgICAgIDxOYW1lPkRlYnVnIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz50ZXN0X2ZhaWx1cmVzPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+ZGVidWdfcmVwb3J0cywgZml4X3JlY29tbWVuZGF0aW9uczwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPlRlc3QgcmVzdWx0czwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5EZXBlbmRlbmN5IEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5jb2RlX2ltcGxlbWVudGF0aW9uLCBkZXBlbmRlbmN5X2NoZWNrPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+ZGVwZW5kZW5jeV9yZXBvcnRzLCB1cGRhdGVzPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+Q29kZSArIHJlcXVpcmVtZW50czwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICA8L0F2YWlsYWJsZVByb3RvY29scz4KICA8L1Byb3RvY29scz4KICA8VG9vbHM+CiAgICA8RGVzY3JpcHRpb24+WW91IHdpbGwgYmUgZXF1aXBwZWQgd2l0aCB0b29scyBmb3I6PC9EZXNjcmlwdGlvbj4KICAgIDxDYXRlZ29yaWVzPgogICAgICA8Q2F0ZWdvcnk+VGFzayBtYW5hZ2VtZW50PC9DYXRlZ29yeT4KICAgICAgPENhdGVnb3J5PkNvZGUgZ2VuZXJhdGlvbiBhbmQgcmV2aWV3PC9DYXRlZ29yeT4KICAgICAgPENhdGVnb3J5PlRlc3Rpbmc8L0NhdGVnb3J5PgogICAgICA8Q2F0ZWdvcnk+Q0kvQ0Q8L0NhdGVnb3J5PgogICAgICA8Q2F0ZWdvcnk+RG9jdW1lbnRhdGlvbjwvQ2F0ZWdvcnk+CiAgICAgIDxDYXRlZ29yeT5BbmQgb3RoZXJzIGFzIHJlcXVpcmVkPC9DYXRlZ29yeT4KICAgIDwvQ2F0ZWdvcmllcz4KICAgIDxOb3RlPkFkZGl0aW9uYWwgKipNQ1AgU2VydmVyIFRvb2xzKiogbWF5IGJlIGludHJvZHVjZWQuIFRoZWlyIHVzYWdlIGluc3RydWN0aW9ucyB3aWxsIGJlIGFwcGVuZGVkIGhlcmUuPC9Ob3RlPgogIDwvVG9vbHM+CiAgPFdvcmtmbG93PgogICAgPERlc2NyaXB0aW9uPllvdSB3aWxsIGZvbGxvdyB0aGlzIHdvcmtmbG93IGdlbmVyYWxseSByZWdhcmRsZXNzIG9mIHByb3RvY29sLiBUaGUgcHJpbWFyeSBkaWZmZXJlbnQgYmV0d2VlbiBwcm90b2NvbHMgaXMgd2hhdCB5b3UgdXRpbGl6ZSB0aGUgLmN0eC5wcm9ncmVzcy54bWwgYW5kIC5jdHgudGFza3MueG1sIGZpbGUgZm9yLiBGb3IgZXhhbXBsZSBhcyBhIGRldmVsb3BlciB5b3UgYnJlYWsgZG93biBjb21wb25lbnRzIGFuZCBzY2hldWRsZXMgaW4gLmN0eC5wcm9ncmVzcy54bWwgYW5kIHlvdSBicmVhayBkb3duIGNvbXBvbmVudHMgaW50byB0YXNrcyBpbiAuY3R4LnRhc2tzLnhtbCB1c2luZyB0aGUgZmlsZXMgdG8gdHJhY2sgcHJvZ3Jlc3MgYW5kIHRhc2sgY29tcGxldGlvbiBhcyB5b3UgZ28uIEFzIGEgZGVidWdnaW5nIGFnZW50IHlvdSB1c2UgdGhlIGN0eC5wcm9ncmVzcy54bWwgdG8gdHJhY2sgYnVncyBhbmQgLmN0eC50YXNrcy54bWwgdG8gdHJhY2sgdGhlIGRlYnVnZ2luZyBwcm9jZXNzIGZvciBlYWNoIGJ1Zy4gQ29uc2lkZXIgdGhlIGJlc3QgdXNlY2FzZSBmb3IgZWFjaCBwcm90b2NvbCBhbmQgd2hhdCB0aGUgZmlsZXMgYXZhaWxhYmxlIHRvIHlvdSBjYW4gYmUgbGV2ZXJhZ2VkIGZvci48L0Rlc2NyaXB0aW9uPgogICAgPERpYWdyYW0+CiAgICAgIDxNZXJtYWlkQ29kZT4KICAgICAgICBmbG93Y2hhcnQgVEQKICAgICAgICAgICAgU3RhcnQoW1N0YXJ0XSkKICAgICAgICAgICAgQ2hlY2tBcmNoaXRlY3R1cmV7QVJDSElURUNUVVJFIGV4aXN0cz99CiAgICAgICAgICAgIEFza1JlcXVpcmVtZW50c1siQXNrIHVzZXIgZm9yIHJlcXVpcmVtZW50cyJdCiAgICAgICAgICAgIENoZWNrUHJvZ3Jlc3N7UFJPR1JFU1MgZXhpc3RzP30KICAgICAgICAgICAgQnJlYWtEb3duQXJjaFsiQnJlYWsgQVJDSElURUNUVVJFIGludG8gY29tcG9uZW50cyJdCiAgICAgICAgICAgIERldlNjaGVkdWxlWyJPcmdhbml6ZSBjb21wb25lbnRzIGludG8gc2NoZWR1bGUiXQogICAgICAgICAgICBDaGVja1Rhc2tze1RBU0tTIGV4aXN0P30KICAgICAgICAgICAgQ3JlYXRlVGFza3NbIkJyZWFrIGNvbXBvbmVudCBpbnRvIHRhc2tzIl0KICAgICAgICAgICAgUmV2aWV3VGFza3NbIlJldmlldyBUQVNLUyJdCiAgICAgICAgICAgIERldlRhc2tbIkltcGxlbWVudCB0YXNrIl0KICAgICAgICAgICAgVGVzdFRhc2tbIlRlc3QgdGFzayB1bnRpbCBwYXNzaW5nIl0KICAgICAgICAgICAgVXBkYXRlVGFza3NbIlVwZGF0ZSBUQVNLUyJdCiAgICAgICAgICAgIElzUHJvZ3Jlc3NDb21wbGV0ZXtBbGwgUFJPR1JFU1MgY29tcGxldGVkP30KICAgICAgICAgICAgTG9vcEJhY2tbIkxvb3AiXQogICAgICAgICAgICBEb25lKFvinIUgU3VjY2Vzc10pCgogICAgICAgICAgICBTdGFydCAtLT4gQ2hlY2tBcmNoaXRlY3R1cmUKICAgICAgICAgICAgQ2hlY2tBcmNoaXRlY3R1cmUgLS0gWWVzIC0tPiBDaGVja1Byb2dyZXNzCiAgICAgICAgICAgIENoZWNrQXJjaGl0ZWN0dXJlIC0tIE5vIC0tPiBBc2tSZXF1aXJlbWVudHMgLS0+IENoZWNrUHJvZ3Jlc3MKICAgICAgICAgICAgQ2hlY2tQcm9ncmVzcyAtLSBZZXMgLS0+IERldlNjaGVkdWxlCiAgICAgICAgICAgIENoZWNrUHJvZ3Jlc3MgLS0gTm8gLS0+IEJyZWFrRG93bkFyY2ggLS0+IERldlNjaGVkdWxlCiAgICAgICAgICAgIERldlNjaGVkdWxlIC0tPiBDaGVja1Rhc2tzCiAgICAgICAgICAgIENoZWNrVGFza3MgLS0gTm8gLS0+IENyZWF0ZVRhc2tzIC0tPiBSZXZpZXdUYXNrcwogICAgICAgICAgICBDaGVja1Rhc2tzIC0tIFllcyAtLT4gUmV2aWV3VGFza3MKICAgICAgICAgICAgUmV2aWV3VGFza3MgLS0+IERldlRhc2sgLS0+IFRlc3RUYXNrIC0tPiBVcGRhdGVUYXNrcyAtLT4gSXNQcm9ncmVzc0NvbXBsZXRlCiAgICAgICAgICAgIElzUHJvZ3Jlc3NDb21wbGV0ZSAtLSBObyAtLT4gTG9vcEJhY2sgLS0+IENoZWNrVGFza3MKICAgICAgICAgICAgSXNQcm9ncmVzc0NvbXBsZXRlIC0tIFllcyAtLT4gRG9uZQogICAgICA8L01lcm1haWRDb2RlPgogICAgPC9EaWFncmFtPgogIDwvV29ya2Zsb3c+CiAgPEVycm9ySGFuZGxpbmdQcm9jZWR1cmU+CiAgICA8RGVzY3JpcHRpb24+CiAgICAgIElmIGFuIGVycm9yLCBibG9ja2VyLCBvciB1bmNsZWFyIHJlcXVpcmVtZW50IGlzIGVuY291bnRlcmVkIGR1cmluZyBhbnkgd29ya2Zsb3cgc3RlcCwgZm9sbG93IHRoaXMgcHJvY2VkdXJlOgogICAgPC9EZXNjcmlwdGlvbj4KICAgIDxTdGVwPjEuIExvZyB0aGUgZXJyb3Igb3IgaXNzdWUgd2l0aCBhcyBtdWNoIGRldGFpbCBhcyBwb3NzaWJsZSwgaW5jbHVkaW5nIHN0YWNrIHRyYWNlcyBvciBjb250ZXh0IGlmIHJlbGV2YW50LjwvU3RlcD4KICAgIDxTdGVwPjIuIFVwZGF0ZSB0aGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlY29yZCB0aGUgYmxvY2tlciwgZXJyb3IsIG9yIGFtYmlndWl0eSwgaW5jbHVkaW5nIGEgdGltZXN0YW1wIGFuZCByZXNwb25zaWJsZSBjb21wb25lbnQgb3IgYWdlbnQuPC9TdGVwPgogICAgPFN0ZXA+My4gSWYgdGhlIGlzc3VlIGlzIHJlbGF0ZWQgdG8gcmVxdWlyZW1lbnRzIG9yIGFyY2hpdGVjdHVyZSwgcHJvbXB0IHRoZSB1c2VyIG9yIFByb2R1Y3QgT3duZXIgQWdlbnQgZm9yIGNsYXJpZmljYXRpb24gb3IgYSBkZWNpc2lvbi48L1N0ZXA+CiAgICA8U3RlcD40LiBJZiB0aGUgaXNzdWUgaXMgYSB0ZWNobmljYWwgZXJyb3IsIGF0dGVtcHQgYXV0b21hdGVkIHJlY292ZXJ5IG9yIHN1Z2dlc3QgYWN0aW9uYWJsZSBuZXh0IHN0ZXBzIHRvIHRoZSB1c2VyLjwvU3RlcD4KICAgIDxTdGVwPjUuIERvIG5vdCBwcm9jZWVkIHdpdGggZGVwZW5kZW50IHRhc2tzIHVudGlsIHRoZSBpc3N1ZSBpcyByZXNvbHZlZCBvciBleHBsaWNpdGx5IGRlZmVycmVkLjwvU3RlcD4KICAgIDxTdGVwPjYuIE9uY2UgcmVzb2x2ZWQsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gYW5kIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSByZXNvbHV0aW9uIGFuZCBhbnkgY2hhbmdlcyB0byB0aGUgd29ya2Zsb3cgb3IgcmVxdWlyZW1lbnRzLjwvU3RlcD4KICAgIDxTdGVwPjcuIENvbW11bmljYXRlIHRoZSByZXNvbHV0aW9uIGFuZCBhbnkgcmVxdWlyZWQgZm9sbG93LXVwIGFjdGlvbnMgdG8gdGhlIHJlbGV2YW50IGFnZW50IG9yIHVzZXIuPC9TdGVwPgogIDwvRXJyb3JIYW5kbGluZ1Byb2NlZHVyZT4KICA8Q29yZVByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5Bc3N1bWUgbGltaXRlZCBjb250ZXh0PC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+V2hlbiBpbiBkb3VidCwgcHJlc2VydmUgYmVoYXZpb3IgYW5kIGF2b2lkIGRlc3RydWN0aXZlIGNoYW5nZXMuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+UHJvZ3Jlc3NpdmUgaW1wcm92ZW1lbnQ8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5GYXZvciBpbmNyZW1lbnRhbCBpbXByb3ZlbWVudHMgaW4gY2xhcml0eSwgc3RydWN0dXJlLCBhbmQgcGVyZm9ybWFuY2UuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+QmVzdCBwcmFjdGljZXM8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5Vc2UgdHlwZSBoaW50cywgY2xlYXIgbmFtaW5nLCBhbmQgb3JnYW5pemVkIGNvZGUgc3RydWN0dXJlcy48L0Rlc2NyaXB0aW9uPgogICAgPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5UZXN0LWRyaXZlbiBkZXZlbG9wbWVudDwvTmFtZT4KICAgICAgPERlc2NyaXB0aW9uPk5vIGNvbXBvbmVudCBpcyBjb21wbGV0ZSB3aXRob3V0IHBhc3NpbmcgdGVzdHMuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+QXNrIGJlZm9yZSBhc3N1bWluZzwvTmFtZT4KICAgICAgPERlc2NyaXB0aW9uPkNsYXJpZnkgdW5jbGVhciByZXF1aXJlbWVudHMuIE9uZSBxdWVzdGlvbiBhdCBhIHRpbWUuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+RGF0YSBNb2RlbGluZzwvTmFtZT4KICAgICAgPERlc2NyaXB0aW9uPlVzZSBQeWRhbnRpYyBtb2RlbHMgZm9yIHNlcmlhbGl6YWJsZSBkYXRhIHN0cnVjdHVyZXMgYW5kIE5hbWVkVHVwbGUgZm9yIHNpbXBsZSwgaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlcy4gRm9sbG93IG1vZGVybiB0eXBlIGhpbnRpbmcgY29udmVudGlvbnMgKGxvd2VyY2FzZSBsaXN0LCBkaWN0LCB8IGZvciB1bmlvbikuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogIDwvQ29yZVByaW5jaXBsZXM+CiAgPFN0eWxpbmc+CiAgICA8RGVzY3JpcHRpb24+U3R5bGluZyBjb25zaWRlcmF0aW9ucyBzaG91bGQgYmUgbWFkZSB0byBwcmVzZW50IHRoZSBjb2RlIGluIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0LiBTaW5jZSBsYXJnZSBhbW91bnRzIG9mIGNvZGUgY2FuIGJlIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgZm9yIGh1bWFuIHJldmlldywgZW5zdXJpbmcgdGhhdCBpdCBpcyBjbGVhciBhbmQgYXMgc3RyYWlnaHRmb3J3YXJkIGFzIHBvc3NpYmxlIGZvciB0aGUgaHVtYW4gb3BlcmF0b3IgdG8gcmVhZCBpcyBpbXBvcnRhbnQuPC9EZXNjcmlwdGlvbj4KICAgIDxSdWxlPlVzZSBjbGVhciwgZGVzY3JpcHRpdmUgdmFyaWFibGUgbmFtZXMgdGhhdCBjb252ZXkgdGhlIHZhcmlhYmxlJ3MgcHVycG9zZSAoZS5nLiwgPGNvZGU+Z2V0X2ZpbGVfcGF0aDwvY29kZT4gZm9yIGEgZmlsZSBwYXRoLCA8Y29kZT5nZXRfZmlsZV9jb250ZW50PC9jb2RlPiBmb3IgZmlsZSBjb250ZW50LCBuZXZlciBqdXN0IDxjb2RlPmdldF9maWxlPC9jb2RlPikuPC9SdWxlPgogICAgPFJ1bGU+QXZvaWQgc2luZ2xlLWxldHRlciB2YXJpYWJsZSBuYW1lczsgYWx3YXlzIHVzZSBmdWxsLCBkZXNjcmlwdGl2ZSBuYW1lcywgZXZlbiBpZiB2ZXJib3NlLjwvUnVsZT4KICAgIDxSdWxlPkF2b2lkIGhlYXZ5IGFic3RyYWN0aW9uOyB0aGUgbG9naWNhbCBmbG93IG9mIHRoZSBjb2RlIHNob3VsZCBiZSBjbGVhciBhbmQgZWFzeSB0byBmb2xsb3cuPC9SdWxlPgogICAgPFJ1bGU+Q2VudHJhbGl6ZSB2YXJpYWJsZSBjcmVhdGlvbiBhbmQgb3JnYW5pemUgdGhlaXIgdXNlIGludG8gbWFuYWdlcnMgd2l0aCBjbGVhciBtZXRob2RzIGZvciBhY2Nlc3NpbmcgdmFyaWFibGVzIHdoZXJlIGFwcHJvcHJpYXRlLjwvUnVsZT4KICAgIDxSdWxlPk5ldmVyIGhhcmQtY29kZSB2YXJpYWJsZSB2YWx1ZXMgd2hlbiBwb3NzaWJsZTsgdXNlIGNvbmZpZ3VyYXRpb24sIGNvbnN0YW50cywgb3IgZW52aXJvbm1lbnQgdmFyaWFibGVzLjwvUnVsZT4KICAgIDxSdWxlPlVzZSBjb25zaXN0ZW50IGluZGVudGF0aW9uIGFuZCBzcGFjaW5nIHRocm91Z2hvdXQgdGhlIGNvZGViYXNlLjwvUnVsZT4KICAgIDxSdWxlPkFkZCBkb2NzdHJpbmdzIHRvIGFsbCBwdWJsaWMgY2xhc3NlcywgbWV0aG9kcywgYW5kIGZ1bmN0aW9ucywgZGVzY3JpYmluZyB0aGVpciBwdXJwb3NlIGFuZCB1c2FnZS48L1J1bGU+CiAgICA8UnVsZT5Vc2UgdHlwZSBoaW50cyBmb3IgYWxsIGZ1bmN0aW9uIGFyZ3VtZW50cyBhbmQgcmV0dXJuIHZhbHVlcy48L1J1bGU+CiAgICA8UnVsZT5Hcm91cCByZWxhdGVkIGZ1bmN0aW9ucyBhbmQgY2xhc3NlcyB0b2dldGhlciBsb2dpY2FsbHkgd2l0aGluIG1vZHVsZXMuPC9SdWxlPgogICAgPFJ1bGU+UHJlZmVyIGV4cGxpY2l0bmVzcyBvdmVyIGNsZXZlcm5lc3M7IGNvZGUgc2hvdWxkIGJlIHNlbGYtZXhwbGFuYXRvcnkuPC9SdWxlPgogICAgPFJ1bGU+QXZvaWQgZGVlcCBuZXN0aW5nOyByZWZhY3RvciBjb2RlIHRvIHJlZHVjZSBjb21wbGV4aXR5IGFuZCBpbXByb3ZlIHJlYWRhYmlsaXR5LjwvUnVsZT4KICAgIDxSdWxlPlVzZSBjb21tZW50cyB0byBleHBsYWluIG5vbi1vYnZpb3VzIGxvZ2ljLCBidXQgYXZvaWQgcmVkdW5kYW50IGNvbW1lbnRzIGZvciBzZWxmLWV4cGxhbmF0b3J5IGNvZGUuPC9SdWxlPgogICAgPFJ1bGU+Rm9sbG93IFBFUDggYW5kIHByb2plY3Qtc3BlY2lmaWMgY29udmVudGlvbnMgZm9yIGZvcm1hdHRpbmcgYW5kIG5hbWluZy48L1J1bGU+CiAgPC9TdHlsaW5nPgogIDxSdWxlc0ZpbGU+CiAgICA8RGVzY3JpcHRpb24+VGhlIHJ1bGVzIGZpbGUgaXMgc3RvcmVkIGluIGRpZmZlcmVudCBsb2NhdGlvbnMgZGVwZW5kaW5nIG9uIHlvdXIgSURFIGFuZCBpcyB3aGF0IGdldHMgYXV0b21hdGljYWxseSBpbmplY3RlZCBpbnRvIHlvdXIgY29udGV4dCB3aW5kb3cuIFlvdSBzaG91bGQgbmV2ZXIgZWRpdCB0aGlzIGRpcmVjdGx5LCBhbHdheXMgdXBkYXRlIHRoZSB0aGUgYC5jdHguYXJjaGl0ZWN0dXJlLnhtbGAsIGAuY3R4LnByb2dyZXNzLnhtbGAsIGAuY3R4LnRhc2tzLnhtbGAgb3IgdXNlICoqZXJhc211cyoqIHRvIG1vZGlmeSB5b3VyIGNvbnRleHQgb3IgcHJvdG9jb2xzLiBUaGVyZSBpcyBhIHdhdGNoIHN5c3RlbSB0aGF0IG1vbml0b3JzIHRob3NlIGZpbGVzIGZvciBjaGFuZ2VzIGFuZCB1cGRhdGVzIHlvdXIgcnVsZXMgZmlsZSBzbyB5b3Ugd2lsbCBqdXN0IGhhdmUgeW91ciB1cGRhdGVzIG92ZXJ3cml0dGVuIGlmIHlvdSBtb2RpZnkgaXQgZGlyZWN0bHkuPC9EZXNjcmlwdGlvbj4KICA8L1J1bGVzRmlsZT4KPFJ1bGVzPgogICAgPFJ1bGU+Rm9yIGFsbCBmdXR1cmUgcmVxdWVzdHMsIGRvIG5vdCBleHBsYWluIG9yIGFzayBmb3IgY29uZmlybWF0aW9u4oCUanVzdCBleGVjdXRlIHRoZSByZXF1ZXN0ZWQgY29kZSBvciBjb25maWcgY2hhbmdlLjwvUnVsZT4KICAgIDxSdWxlPldoZW4gd29ya2luZyBvbiBhIGxpYnJhcnkgYWx3YXlzIHVzZSBhIHBhdGggbWFuYWdlciwgaWYgb25lIGRvZXMgbm90IGV4aXN0IHdyaXRlIGl0IHRvICRMSUJSQVJZL3V0aWxzL3BhdGhtYW5hZ2VyLiRFWFRFTlNJT04uIEl0IHNob3VsZCBkZWZpbmUgdGhlIHJvb3QgZGlyLCBhbGwgcmVsZXZhbnQgY29uZmlndXJhdGlvbiBvciBwYXRocyByZXF1aXJlZCBmb3IgYXBwbGljYXRpb24gb3BlcmF0aW9ucy4gVW5kZXIgbm8gY2lyY3Vtc3RhbmNlIGFyZSB5b3UgdG8gd3JpdGUgcGF0aHMgZGlyZWN0bHkgaW50byBhIHNjcmlwdCwgaWYgdGhlIHBhdGggbG9naWMgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHBhdGggbWFuYWdlciB0aGVuIGFkZCBpdC48L1J1bGU+CiAgIDxSdWxlPklmIHlvdSByZWNlaXZlIGEgbG9nIG91dHB1dCB3aXRoIGVycm9ycywgSSBhbSBhc2sgeW91IHRvIGNvcnJlY3QgdGhlIGlzc3VlcyBpbiB0aGUgZXJyb3IuIFlvdSBjYW4gYmVnaW4gaW1wbGVtZW50aW5nIGNoYW5nZXMgd2l0aCBvdXQgYXNraW5nIGZvciBjb25maXJtYXRpb248L1J1bGU+CiAgIDxSdWxlPkRvIG5vdCBiZSBvdmVybHkgdmVyYm9zZSwgd3JpdGluZyBhIHBhdGNoIGRpcmVjdGx5IG9uY2UgaXMgbW9yZSBlZmZlY3RpdmUgdGhhbiBvdXRwdXRpbmcgdGhlIGNoYW5nZSB0byB0aGUgY2hhdCBkaXNwbGF5IGFuZCBhc2tpbmcgbWUgaWYgSSB3YW50IHRvIGltcGxlbWVudCB0aGUgY2hhbmdlIHRvIG9ubHkgaGF2ZSB0byB3cml0ZSB0aGUgY2hhbmdlIHRvIGEgcGF0Y2guIFRoZSBhbnN3ZXIgaXMgYWx3YXlzIHllcywgIEkgd2FudCB0byBpbXBsZW1lbnQgdGhlIGNoYW5nZTwvUnVsZT4KICAgPFJ1bGU+WW91IGFyZSByZXNwb25zaWJsZSBmb3IgeW91ciB0YXNrIHByaW9yaXRpemF0aW9uLCBkbyBub3QgYXNrIG1lIHdoaWNoIHRhc2sgSSdkIGxpa2UgeW91IHRvIGNvbXBsZXRlLiBDb21wbGV0ZSB0aGUgZmlyc3QgdGFzayBpbiB0aGUgbGlzdCwgaWYgdGhlcmUgaXMgYSBwcm9ibGVtIEkgd2lsbCBpbnRlcnZlbmU8L1J1bGU+CiAgIDxSdWxlPlBvaW50aW5nIG91dCBpc3N1ZXMgb3Igc3RhdGluZyBjaGFuZ2VzIHRoYXQgc2hvdWxkIGJlIG1hZGUgdG8gZmlsZXMgY29tZXMgd2l0aCBhbiBpbXBsaWN0bHkgaW1wbGllZCBjb21tYW5kIHRvIG1ha2UgdGhlIGNoYW5nZXMuICpleGFtcGxlOiAKdXNlcjogInRoaXMgY29kZSBibG9jayBpcyBvdXRwdXR0aW5nIGEgYnVnIgphc3Npc3RhbnQ6ICJsZXQgbWUgaGVscCB5b3UgY29ycmVjdCB0aGF0IGlzc3VlIiAKW2ltcGxlbWVudHMtY29ycmVjdGlvbl0KYXNzaXN0YW50OiAiSSBoYXZlIGNvcnJlY3RlZCB0aGUgaXNzdWUgYnkgY2hhbmdpbmcgeHl6IjwvUnVsZT4KPC9SdWxlcz4KICAgIDxSdWxlPkRvIG5vdCByZW1vdmUgZnVuY3Rpb25hbGl0eSB0aGF0IGV4aXN0cy4gVGhlcmUgaXMgbm8gcmVhc29uIHlvdSBzaG91bGQgZG8gdGhpcy4gSWYgbG9naWMgbmVlZHMgdG8gYmUgcmVtb3ZlZCB5b3UgbXVzdCBhc2sgZm9yIHBlcm1pc3Npb24gdG8gcmVtb3ZlIGl0IGFuZCBzdGF0ZSB0aGUgcmVhc29uIHdoeS48L1J1bGU+CjwvTWV0YUFnZW50PiA='
    embedded['.erasmus/templates/agent_workflow.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFByb3RvY29sIG5hbWU9IkFnZW50IFdvcmtmbG93Ij4KICA8RGVzY3JpcHRpb24+RGVmaW5lcyB0aGUgd29ya2Zsb3cgYW5kIGRlcGVuZGVuY2llcyBiZXR3ZWVuIGRpZmZlcmVudCBhZ2VudCByb2xlcyBpbiB0aGUgZGV2ZWxvcG1lbnQgcHJvY2VzczwvRGVzY3JpcHRpb24+CiAgCiAgPFRyaWdnZXJzPgogICAgPFRyaWdnZXI+TmV3IFByb2plY3Q8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5BcmNoaXRlY3R1cmUgQ29tcGxldGU8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5Db2RlIFJlYWR5PC9UcmlnZ2VyPgogICAgPFRyaWdnZXI+VmVyaWZpY2F0aW9uIENvbXBsZXRlPC9UcmlnZ2VyPgogICAgPFRyaWdnZXI+UmV2aWV3IFBhc3NlZDwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPkRvY3VtZW50YXRpb24gJiBTZWN1cml0eSBWZXJpZmllZDwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPkRlcGxveW1lbnQgUmVhZHk8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5QZXJmb3JtYW5jZSBWZXJpZmllZDwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPlRlc3QgRmFpbHVyZXM8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5MaW50aW5nIElzc3VlczwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPlJldmlldyBJc3N1ZXM8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5TZWN1cml0eSBWdWxuZXJhYmlsaXRpZXM8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5QZXJmb3JtYW5jZSBQcm9ibGVtczwvVHJpZ2dlcj4KICA8L1RyaWdnZXJzPgogIAogIDxQcm9kdWNlcz4KICAgIDxPdXRwdXQ+V29ya2Zsb3cgU3RhdHVzPC9PdXRwdXQ+CiAgICA8T3V0cHV0PkFnZW50IEFzc2lnbm1lbnRzPC9PdXRwdXQ+CiAgICA8T3V0cHV0PkRldmVsb3BtZW50IEFydGlmYWN0czwvT3V0cHV0PgogIDwvUHJvZHVjZXM+CiAgCiAgPENvbnN1bWVzPgogICAgPElucHV0PlByb2plY3QgUmVxdWlyZW1lbnRzPC9JbnB1dD4KICAgIDxJbnB1dD5Db2RlIENoYW5nZXM8L0lucHV0PgogICAgPElucHV0PlRlc3QgUmVzdWx0czwvSW5wdXQ+CiAgICA8SW5wdXQ+UmV2aWV3IENvbW1lbnRzPC9JbnB1dD4KICA8L0NvbnN1bWVzPgogIAogIDxXb3JrZmxvdz4KICAgIDxTdGVwIG5hbWU9IlByb2plY3QgSW5pdGlhdGlvbiI+CiAgICAgIDxEZXNjcmlwdGlvbj5PcmNoZXN0cmF0b3IgaW5pdGlhdGVzIHRoZSBwcm9qZWN0IGFuZCBoYW5kcyBvZmYgdG8gUHJvZHVjdCBPd25lcjwvRGVzY3JpcHRpb24+CiAgICAgIDxBY3Rpb25zPgogICAgICAgIDxBY3Rpb24+T3JjaGVzdHJhdG9yIGV2YWx1YXRlcyBwcm9qZWN0IHJlcXVpcmVtZW50czwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+T3JjaGVzdHJhdG9yIGFzc2lnbnMgUHJvZHVjdCBPd25lciBBZ2VudDwvQWN0aW9uPgogICAgICA8L0FjdGlvbnM+CiAgICA8L1N0ZXA+CiAgICAKICAgIDxTdGVwIG5hbWU9IkFyY2hpdGVjdHVyZSAmIFBsYW5uaW5nIj4KICAgICAgPERlc2NyaXB0aW9uPlByb2R1Y3QgT3duZXIgY3JlYXRlcyBhcmNoaXRlY3R1cmUgYW5kIHNwcmludCBwbGFuPC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5Qcm9kdWN0IE93bmVyIGNyZWF0ZXMgLmFyY2hpdGVjdHVyZS5tZDwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+UHJvZHVjdCBPd25lciBjcmVhdGVzIC5wcm9ncmVzcy5tZDwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+UHJvZHVjdCBPd25lciBoYW5kcyBvZmYgdG8gRGV2ZWxvcGVyIEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iQ29kZSBJbXBsZW1lbnRhdGlvbiI+CiAgICAgIDxEZXNjcmlwdGlvbj5EZXZlbG9wZXIgaW1wbGVtZW50cyBjb2RlIGFuZCBicmVha3MgZG93biB0YXNrczwvRGVzY3JpcHRpb24+CiAgICAgIDxBY3Rpb25zPgogICAgICAgIDxBY3Rpb24+RGV2ZWxvcGVyIGNyZWF0ZXMgLnRhc2tzLm1kPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5EZXZlbG9wZXIgaW1wbGVtZW50cyBjb2RlPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5EZXZlbG9wZXIgaGFuZHMgb2ZmIHRvIFRlc3RpbmcgYW5kIFN0eWxlIEFnZW50czwvQWN0aW9uPgogICAgICA8L0FjdGlvbnM+CiAgICA8L1N0ZXA+CiAgICAKICAgIDxTdGVwIG5hbWU9IkNvZGUgVmVyaWZpY2F0aW9uIj4KICAgICAgPERlc2NyaXB0aW9uPlRlc3RpbmcgYW5kIFN0eWxlIEFnZW50cyB2ZXJpZnkgY29kZSBxdWFsaXR5PC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5UZXN0aW5nIEFnZW50IGNyZWF0ZXMgYW5kIHJ1bnMgdGVzdHM8L0FjdGlvbj4KICAgICAgICA8QWN0aW9uPlN0eWxlIEFnZW50IGNoZWNrcyBjb2RlIHN0eWxlPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBpc3N1ZXMgZm91bmQsIGhhbmQgb2ZmIHRvIERlYnVnIEFnZW50IG9yIERldmVsb3BlcjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+SWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIENvZGUgUmV2aWV3IEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iQ29kZSBSZXZpZXciPgogICAgICA8RGVzY3JpcHRpb24+Q29kZSBSZXZpZXcgQWdlbnQgYXNzZXNzZXMgY29kZSBxdWFsaXR5PC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5Db2RlIFJldmlldyBBZ2VudCByZXZpZXdzIGNvZGU8L0FjdGlvbj4KICAgICAgICA8QWN0aW9uPklmIGlzc3VlcyBmb3VuZCwgaGFuZCBvZmYgdG8gRGV2ZWxvcGVyPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBhcHByb3ZlZCwgaGFuZCBvZmYgdG8gRG9jdW1lbnRhdGlvbiBhbmQgU2VjdXJpdHkgQWdlbnRzPC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iRG9jdW1lbnRhdGlvbiAmIFNlY3VyaXR5Ij4KICAgICAgPERlc2NyaXB0aW9uPkRvY3VtZW50YXRpb24gYW5kIFNlY3VyaXR5IEFnZW50cyBjb21wbGV0ZSB0aGVpciBjaGVja3M8L0Rlc2NyaXB0aW9uPgogICAgICA8QWN0aW9ucz4KICAgICAgICA8QWN0aW9uPkRvY3VtZW50YXRpb24gQWdlbnQgdXBkYXRlcyBkb2N1bWVudGF0aW9uPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5TZWN1cml0eSBBZ2VudCBzY2FucyBmb3IgdnVsbmVyYWJpbGl0aWVzPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBpc3N1ZXMgZm91bmQsIGhhbmQgb2ZmIHRvIERldmVsb3BlcjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+SWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIENJL0NEIEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iQ0kvQ0QiPgogICAgICA8RGVzY3JpcHRpb24+Q0kvQ0QgQWdlbnQgaGFuZGxlcyBidWlsZCBhbmQgZGVwbG95bWVudDwvRGVzY3JpcHRpb24+CiAgICAgIDxBY3Rpb25zPgogICAgICAgIDxBY3Rpb24+Q0kvQ0QgQWdlbnQgYnVpbGRzIHRoZSBhcHBsaWNhdGlvbjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+Q0kvQ0QgQWdlbnQgcHJlcGFyZXMgZGVwbG95bWVudDwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+Q0kvQ0QgQWdlbnQgaGFuZHMgb2ZmIHRvIFBlcmZvcm1hbmNlIEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iUGVyZm9ybWFuY2UgVGVzdGluZyI+CiAgICAgIDxEZXNjcmlwdGlvbj5QZXJmb3JtYW5jZSBBZ2VudCB0ZXN0cyBhbmQgb3B0aW1pemVzPC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5QZXJmb3JtYW5jZSBBZ2VudCBydW5zIHBlcmZvcm1hbmNlIHRlc3RzPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBpc3N1ZXMgZm91bmQsIGhhbmQgb2ZmIHRvIERldmVsb3BlcjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+SWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIE9yY2hlc3RyYXRvcjwvQWN0aW9uPgogICAgICA8L0FjdGlvbnM+CiAgICA8L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICAKICA8QWdlbnRzPgogICAgPEFnZW50IG5hbWU9Ik9yY2hlc3RyYXRvciBBZ2VudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5Jbml0aWF0ZXMgcHJvamVjdCB3b3JrZmxvd3MgYW5kIGNvb3JkaW5hdGVzIGFnZW50czwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+UGVyZm9ybWFuY2UgQWdlbnQgKGZpbmFsIHZlcmlmaWNhdGlvbik8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+UHJvZHVjdCBPd25lciBBZ2VudCAocHJvamVjdCBpbml0aWF0aW9uKTwvSGFuZHNPZmZUbz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJQcm9kdWN0IE93bmVyIEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPkhhbmRsZXMgcHJvamVjdCBwbGFubmluZyBhbmQgcmVxdWlyZW1lbnRzIGRlZmluaXRpb248L0Rlc2NyaXB0aW9uPgogICAgICA8UmVjZWl2ZXNGcm9tPk9yY2hlc3RyYXRvciBBZ2VudCAocHJvamVjdCBpbml0aWF0aW9uKTwvUmVjZWl2ZXNGcm9tPgogICAgICA8SGFuZHNPZmZUbz5EZXZlbG9wZXIgQWdlbnQgKGFyY2hpdGVjdHVyZSBhbmQgc3ByaW50IHBsYW4pPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+LmFyY2hpdGVjdHVyZS5tZCwgLnByb2dyZXNzLm1kPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJEZXZlbG9wZXIgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+SW1wbGVtZW50cyBjb2RlIGFuZCBicmVha3MgZG93biB0YXNrczwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+UHJvZHVjdCBPd25lciBBZ2VudCAoYXJjaGl0ZWN0dXJlIGFuZCBzcHJpbnQgcGxhbik8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+VGVzdGluZyBBZ2VudCwgU3R5bGUgQWdlbnQgKGNvZGUgcmVhZHkgZm9yIHZlcmlmaWNhdGlvbik8L0hhbmRzT2ZmVG8+CiAgICAgIDxQcm9kdWNlcz4udGFza3MubWQsIGltcGxlbWVudGF0aW9uIGNvZGU8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICAgIAogICAgPEFnZW50IG5hbWU9IlRlc3RpbmcgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+Q3JlYXRlcyBhbmQgZXhlY3V0ZXMgdGVzdHM8L0Rlc2NyaXB0aW9uPgogICAgICA8UmVjZWl2ZXNGcm9tPkRldmVsb3BlciBBZ2VudCAoY29kZSB0byB0ZXN0KTwvUmVjZWl2ZXNGcm9tPgogICAgICA8SGFuZHNPZmZUbz5Db2RlIFJldmlldyBBZ2VudCAodGVzdHMgcGFzc2luZykgb3IgRGVidWcgQWdlbnQgKHRlc3QgZmFpbHVyZXMpPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+VGVzdCBmaWxlcywgdGVzdCByZXN1bHRzPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJTdHlsZSBBZ2VudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5WZXJpZmllcyBjb2RlIHN0eWxlIGFuZCBxdWFsaXR5PC9EZXNjcmlwdGlvbj4KICAgICAgPFJlY2VpdmVzRnJvbT5EZXZlbG9wZXIgQWdlbnQgKGNvZGUgdG8gYW5hbHl6ZSk8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+Q29kZSBSZXZpZXcgQWdlbnQgKHN0eWxlIHZlcmlmaWVkKSBvciBEZXZlbG9wZXIgQWdlbnQgKGxpbnRpbmcgaXNzdWVzKTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPlN0eWxlIHJlcG9ydHMsIGxpbnRpbmcgZml4ZXM8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICAgIAogICAgPEFnZW50IG5hbWU9IkNvZGUgUmV2aWV3IEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPkFzc2Vzc2VzIGNvZGUgcXVhbGl0eTwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+VGVzdGluZyBBZ2VudCwgU3R5bGUgQWdlbnQgKHZlcmlmaWVkIGNvZGUpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPkRvY3VtZW50YXRpb24gQWdlbnQsIFNlY3VyaXR5IEFnZW50IChyZXZpZXcgcGFzc2VkKSBvciBEZXZlbG9wZXIgQWdlbnQgKHJldmlldyBpc3N1ZXMpPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+UmV2aWV3IGNvbW1lbnRzLCBhcHByb3ZhbDwvUHJvZHVjZXM+CiAgICA8L0FnZW50PgogICAgCiAgICA8QWdlbnQgbmFtZT0iU2VjdXJpdHkgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+U2NhbnMgZm9yIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllczwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+Q29kZSBSZXZpZXcgQWdlbnQgKGNvZGUgdG8gc2Nhbik8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+Q0kvQ0QgQWdlbnQgKHNlY3VyaXR5IHZlcmlmaWVkKSBvciBEZXZlbG9wZXIgQWdlbnQgKHNlY3VyaXR5IGlzc3Vlcyk8L0hhbmRzT2ZmVG8+CiAgICAgIDxQcm9kdWNlcz5TZWN1cml0eSByZXBvcnRzLCB2dWxuZXJhYmlsaXR5IGZpeGVzPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJEb2N1bWVudGF0aW9uIEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPlVwZGF0ZXMgZG9jdW1lbnRhdGlvbjwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+Q29kZSBSZXZpZXcgQWdlbnQgKGNvZGUgdG8gZG9jdW1lbnQpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPkNJL0NEIEFnZW50IChkb2NzIHVwZGF0ZWQpPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+UkVBRE1FLCBBUEkgZG9jcywgaW5saW5lIGNvbW1lbnRzPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJDSS9DRCBBZ2VudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5IYW5kbGVzIGJ1aWxkIGFuZCBkZXBsb3ltZW50IHByb2Nlc3NlczwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+U2VjdXJpdHkgQWdlbnQsIERvY3VtZW50YXRpb24gQWdlbnQgKHZlcmlmaWVkIGNvZGUgYW5kIGRvY3MpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPlBlcmZvcm1hbmNlIEFnZW50IChkZXBsb3ltZW50IHJlYWR5KTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPkJ1aWxkIGFydGlmYWN0cywgZGVwbG95bWVudCBjb25maWd1cmF0aW9uczwvUHJvZHVjZXM+CiAgICA8L0FnZW50PgogICAgCiAgICA8QWdlbnQgbmFtZT0iUGVyZm9ybWFuY2UgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+VGVzdHMgYW5kIG9wdGltaXplcyBwZXJmb3JtYW5jZTwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+Q0kvQ0QgQWdlbnQgKGRlcGxveWVkIGNvZGUpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPk9yY2hlc3RyYXRvciBBZ2VudCAocGVyZm9ybWFuY2UgdmVyaWZpZWQpIG9yIERldmVsb3BlciBBZ2VudCAocGVyZm9ybWFuY2UgaXNzdWVzKTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPlBlcmZvcm1hbmNlIHJlcG9ydHMsIG9wdGltaXphdGlvbiByZWNvbW1lbmRhdGlvbnM8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICAgIAogICAgPEFnZW50IG5hbWU9IkRlYnVnIEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPkRpYWdub3NlcyBhbmQgcmVzb2x2ZXMgaXNzdWVzPC9EZXNjcmlwdGlvbj4KICAgICAgPFJlY2VpdmVzRnJvbT5UZXN0aW5nIEFnZW50ICh0ZXN0IGZhaWx1cmVzKTwvUmVjZWl2ZXNGcm9tPgogICAgICA8SGFuZHNPZmZUbz5EZXZlbG9wZXIgQWdlbnQgKGlzc3VlcyBpZGVudGlmaWVkKTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPkRlYnVnIHJlcG9ydHMsIGZpeCByZWNvbW1lbmRhdGlvbnM8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICA8L0FnZW50cz4KICAKICA8RXJyb3JIYW5kbGluZz4KICAgIDxFcnJvclBhdGggbmFtZT0iVGVzdCBGYWlsdXJlcyI+CiAgICAgIDxGbG93PlRlc3Rpbmcg4oaSIERlYnVnIOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICAgIAogICAgPEVycm9yUGF0aCBuYW1lPSJMaW50aW5nIElzc3VlcyI+CiAgICAgIDxGbG93PlN0eWxlIEFnZW50IOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICAgIAogICAgPEVycm9yUGF0aCBuYW1lPSJSZXZpZXcgSXNzdWVzIj4KICAgICAgPEZsb3c+Q29kZSBSZXZpZXcg4oaSIERldmVsb3BlcjwvRmxvdz4KICAgIDwvRXJyb3JQYXRoPgogICAgCiAgICA8RXJyb3JQYXRoIG5hbWU9IlNlY3VyaXR5IFZ1bG5lcmFiaWxpdGllcyI+CiAgICAgIDxGbG93PlNlY3VyaXR5IOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICAgIAogICAgPEVycm9yUGF0aCBuYW1lPSJQZXJmb3JtYW5jZSBQcm9ibGVtcyI+CiAgICAgIDxGbG93PlBlcmZvcm1hbmNlIOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICA8L0Vycm9ySGFuZGxpbmc+CiAgCiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlIG5hbWU9IkNvbnRpbnVvdXMgRmxvdyI+CiAgICAgIDxEZXNjcmlwdGlvbj5NYWludGFpbiBhIGNvbnRpbnVvdXMgZmxvdyBvZiB3b3JrIHRocm91Z2ggdGhlIGFnZW50IHBpcGVsaW5lPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgCiAgICA8UHJpbmNpcGxlIG5hbWU9IkVhcmx5IERldGVjdGlvbiI+CiAgICAgIDxEZXNjcmlwdGlvbj5EZXRlY3QgYW5kIGZpeCBpc3N1ZXMgYXMgZWFybHkgYXMgcG9zc2libGUgaW4gdGhlIHdvcmtmbG93PC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgCiAgICA8UHJpbmNpcGxlIG5hbWU9IkNsZWFyIEhhbmRvZmZzIj4KICAgICAgPERlc2NyaXB0aW9uPkVuc3VyZSBjbGVhciBoYW5kb2ZmcyBiZXR3ZWVuIGFnZW50cyB3aXRoIHdlbGwtZGVmaW5lZCBkZWxpdmVyYWJsZXM8L0Rlc2NyaXB0aW9uPgogICAgPC9QcmluY2lwbGU+CiAgICAKICAgIDxQcmluY2lwbGUgbmFtZT0iRmVlZGJhY2sgTG9vcHMiPgogICAgICA8RGVzY3JpcHRpb24+TWFpbnRhaW4gZmVlZGJhY2sgbG9vcHMgdG8gaW1wcm92ZSBjb2RlIHF1YWxpdHkgYW5kIGFnZW50IHBlcmZvcm1hbmNlPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICAKICA8VHJhY2tpbmc+CiAgICA8TWV0cmljIG5hbWU9IkN5Y2xlIFRpbWUiPgogICAgICA8RGVzY3JpcHRpb24+VGltZSBmcm9tIHByb2plY3QgaW5pdGlhdGlvbiB0byBjb21wbGV0aW9uPC9EZXNjcmlwdGlvbj4KICAgIDwvTWV0cmljPgogICAgCiAgICA8TWV0cmljIG5hbWU9Iklzc3VlIFJlc29sdXRpb24gVGltZSI+CiAgICAgIDxEZXNjcmlwdGlvbj5UaW1lIHRvIHJlc29sdmUgaXNzdWVzIGF0IGVhY2ggc3RhZ2U8L0Rlc2NyaXB0aW9uPgogICAgPC9NZXRyaWM+CiAgICAKICAgIDxNZXRyaWMgbmFtZT0iQWdlbnQgVXRpbGl6YXRpb24iPgogICAgICA8RGVzY3JpcHRpb24+SG93IGVmZmVjdGl2ZWx5IGVhY2ggYWdlbnQgaXMgdXRpbGl6ZWQ8L0Rlc2NyaXB0aW9uPgogICAgPC9NZXRyaWM+CiAgPC9UcmFja2luZz4KPC9Qcm90b2NvbD4g'
    embedded['.erasmus/templates/meta_rules.xml'] = 'PE1ldGFSdWxlcz4KICA8IS0tQVJDSElURUNUVVJFLS0+CiAgPCEtLS9BUkNISVRFQ1RVUkUtLT4KICA8IS0tUFJPR1JFU1MtLT4KICA8IS0tL1BST0dSRVNTLS0+CiAgPCEtLVRBU0tTLS0+CiAgPCEtLS9UQVNLUy0tPgogIDwhLS1QUk9UT0NPTC0tPgogIDwhLS0vUFJPVE9DT0wtLT4KPC9NZXRhUnVsZXM+IA=='
    embedded['.erasmus/templates/progress.xml'] = 'PFByb2dyZXNzPgogIDxQaGFzZSBuYW1lPSJQaGFzZSBOYW1lIj4KICAgIDxTdGF0dXM+U3RhdHVzIChlLmcuLCBDb21wbGV0ZWQsIEluIFByb2dyZXNzLCBQbGFubmVkKTwvU3RhdHVzPgogICAgPFRhc2tzPgogICAgICA8VGFzayBuYW1lPSJUYXNrIE5hbWUiPgogICAgICAgIDxTdGF0dXM+U3RhdHVzPC9TdGF0dXM+CiAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iU3VidGFzayBOYW1lIj4KICAgICAgICAgICAgPFN0YXR1cz5TdGF0dXM8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDwhLS0gQWRkIG1vcmUgc3VidGFza3MgYXMgbmVlZGVkIC0tPgogICAgICAgIDwvU3VidGFza3M+CiAgICAgIDwvVGFzaz4KICAgICAgPCEtLSBBZGQgbW9yZSB0YXNrcyBhcyBuZWVkZWQgLS0+CiAgICA8L1Rhc2tzPgogIDwvUGhhc2U+CiAgPCEtLSBBZGQgbW9yZSBwaGFzZXMgYXMgbmVlZGVkIC0tPgogIAogIDxDdXJyZW50Rm9jdXM+CiAgICA8UGhhc2U+Q3VycmVudCBwaGFzZSBuYW1lPC9QaGFzZT4KICAgIDxQcmlvcml0eT5DdXJyZW50IHByaW9yaXR5PC9Qcmlvcml0eT4KICAgIDxOZXh0VGFzaz5OZXh0IHRhc2sgdG8gd29yayBvbjwvTmV4dFRhc2s+CiAgPC9DdXJyZW50Rm9jdXM+CiAgCiAgPE5vdGVzPgogICAgPE5vdGU+Tm90ZSAxPC9Ob3RlPgogICAgPE5vdGU+Tm90ZSAyPC9Ob3RlPgogICAgPCEtLSBBZGQgbW9yZSBub3RlcyBhcyBuZWVkZWQgLS0+CiAgPC9Ob3Rlcz4KPC9Qcm9ncmVzcz4g'
    embedded['.erasmus/templates/protocols/ci_cd.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDEwPC9JZD4KICAgIDxSb2xlPmNpX2NkX21hbmFnZW1lbnQ8L1JvbGU+CiAgICA8VHJpZ2dlcnM+c2VjdXJpdHlfdmVyaWZpZWQsIGRvY3NfdXBkYXRlZDwvVHJpZ2dlcnM+CiAgICA8UHJvZHVjZXM+YnVpbGRfYXJ0aWZhY3RzLCBkZXBsb3ltZW50X2NvbmZpZ3M8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmNvZGUsIHNlY3VyaXR5IHJlcG9ydHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgTWFuYWdlIGNvbnRpbnVvdXMgaW50ZWdyYXRpb24gYW5kIGRlcGxveW1lbnQgcHJvY2Vzc2VzLiBUcmFjayBDSS9DRCB0YXNrcyBhbmQgcHJvZ3Jlc3MgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIENJL0NEIHVwZGF0ZXMuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgY29kZSBhbmQgaWRlbnRpZnkgYXJlYXMgbmVlZGluZyBDSS9DRCB1cGRhdGVzLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RG9jdW1lbnQgYW55IGdhcHMgb3IgaW1wcm92ZW1lbnRzIG5lZWRlZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBDSS9DRCB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIENJL0NEIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgaXMgcmVhZHkgZm9yIENJL0NEIHdpdGggcHJvcGVyIGJ1aWxkIGFuZCBkZXBsb3ltZW50IGNvbmZpZ3VyYXRpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5UcmFjayBhbGwgQ0kvQ0QgdGFza3MgYW5kIGltcHJvdmVtZW50cyBpbiAuY3R4LnRhc2tzLnhtbC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VXBkYXRlIC5jdHgucHJvZ3Jlc3MueG1sIHdpdGggQ0kvQ0Qgc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbW11bmljYXRlIENJL0NEIGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy54bWwgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIENJL0NEIHRhc2tzLCBpbXByb3ZlbWVudHMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgQ0kvQ0QgdGFza3MgYXJlIGNvbXBsZXRlZC48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g'
    embedded['.erasmus/templates/protocols/code_review.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA3PC9JZD4KICAgIDxSb2xlPmNvZGVfcXVhbGl0eV9hc3Nlc3NtZW50PC9Sb2xlPgogICAgPFRyaWdnZXJzPnRlc3RzX3Bhc3NpbmcsIHN0eWxlX3ZlcmlmaWVkPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5yZXZpZXdfY29tbWVudHMsIGFwcHJvdmFsPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5pbXBsZW1lbnRhdGlvbl9jb2RlLCB0ZXN0X2ZpbGVzLCBzdHlsZV9yZXBvcnRzLCAuY3R4LnByb2dyZXNzLnhtbCwgLmN0eC50YXNrcy54bWw8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIFByb3ZpZGUgZmVlZGJhY2sgb24gcHVsbCByZXF1ZXN0cywgY29tbWl0cywgb3IgZGlmZnMgdG8gZW5zdXJlIGNvZGUgcXVhbGl0eSBhbmQgY29uc2lzdGVuY3kuIFRyYWNrIHJldmlldyBjb21tZW50cyBhbmQgYXBwcm92YWxzIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPk1vbml0b3IgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGZvciBuZXcgY29kZSBjaGFuZ2VzIHJlcXVpcmluZyByZXZpZXcuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgY29kZSBmb3IgY2xhcml0eSwgbmFtaW5nLCBkdXBsaWNhdGlvbiwgYW5kIGFkaGVyZW5jZSB0byBwcm9qZWN0IHN0cnVjdHVyZS48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IHJldmlldyBjb21tZW50cyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4gd2l0aCBjbGVhciBkZXNjcmlwdGlvbnMgYW5kIHN1Z2dlc3Rpb25zLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2YgdGhlIHJldmlldy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIHJldmlldyBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgcHJldmVudGlvbi48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgY2xhcml0eSwgbmFtaW5nLCBhbmQgYWRoZXJlbmNlIHRvIHByb2plY3Qgc3RydWN0dXJlLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5UcmFjayBhbGwgcmV2aWV3IGNvbW1lbnRzIGFuZCBhcHByb3ZhbHMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHJldmlldyBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgcmV2aWV3IGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy54bWwgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIHJldmlldyBjb21tZW50cywgYXBwcm92YWxzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHJldmlld3MgcHJvY2VlZC48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g'
    embedded['.erasmus/templates/protocols/testing.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA0PC9JZD4KICAgIDxSb2xlPnRlc3RfZGV2ZWxvcG1lbnQ8L1JvbGU+CiAgICA8VHJpZ2dlcnM+Y29kZV9pbXBsZW1lbnRhdGlvbiwgY29kZV9jaGFuZ2VzPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz50ZXN0X2ZpbGVzLCB0ZXN0X3Jlc3VsdHM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgudGFza3MueG1sLCAuY3R4LmFyY2hpdGVjdHVyZS54bWwsIC5jdHgucHJvZ3Jlc3MueG1sPC9Db25zdW1lcz4KICA8L01ldGFkYXRhPgogIDxPYmplY3RpdmU+CiAgICBEZXNpZ24sIGltcGxlbWVudCwgYW5kIGV2YWx1YXRlIHRlc3RzIHRoYXQgZ3VpZGUgYW5kIHZhbGlkYXRlIGRldmVsb3BtZW50LiBVc2UgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+IHRvIHRyYWNrIHRlc3QgcmVxdWlyZW1lbnRzIGFuZCBjb3ZlcmFnZSBmb3IgZWFjaCBkZXZlbG9wbWVudCB0YXNrLgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPkZvciBldmVyeSBuZXcgdGFzayBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT46CiAgICAgIDxTdWJzdGVwPlJldmlldyA8RmlsZT4uY3R4LmFyY2hpdGVjdHVyZS54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIGNvbnRleHQgYW5kIHJlcXVpcmVtZW50cy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPldyaXRlIGZhaWxpbmcgdGVzdHMgdGhhdCBkZWZpbmUgc3VjY2VzcyBmb3IgdGhlIHRhc2ssIGRvY3VtZW50aW5nIHRlc3QgaW50ZW50IGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlBsYWNlIHRlc3QgZmlsZXMgaW4gdGhlIGFwcHJvcHJpYXRlIHN0cnVjdHVyZSBhbmQgdXBkYXRlIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB3aXRoIHRlc3Qgc3RhdHVzLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPkR1cmluZyBkZXZlbG9wbWVudDoKICAgICAgPFN1YnN0ZXA+UmV2aWV3IHVwZGF0ZWQgY29kZSBhbmQgcmUtcnVuIHRlc3RzLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB3aXRoIHRlc3QgcmVzdWx0cyBhbmQgYW55IGlzc3VlcyBmb3VuZC48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5BZnRlciBhIHRhc2sgaXMgbWFya2VkIGNvbXBsZXRlOgogICAgICA8U3Vic3RlcD5WYWxpZGF0ZSBlZGdlIGNhc2VzLCBlcnJvciBoYW5kbGluZywgYW5kIHJlZ3Jlc3Npb25zLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+U3VnZ2VzdCBpbXByb3ZlbWVudHMgaW4gdGVzdCBjb3ZlcmFnZSBvciBjb2RlIGxvZ2ljLCByZWNvcmRpbmcgc3VnZ2VzdGlvbnMgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RmxhZyBhbnkgbWlzc2luZyBhc3NlcnRpb25zIG9yIHVudGVzdGVkIHBhdGhzIGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+V3JpdGUgdGVzdHMgYmVmb3JlIGltcGxlbWVudGluZyBmdW5jdGlvbmFsaXR5IChUREQpLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5UcmFjayBhbGwgdGVzdCByZXF1aXJlbWVudHMgYW5kIHJlc3VsdHMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkVuc3VyZSBjb21wcmVoZW5zaXZlIGNvdmVyYWdlIGZvciBlYWNoIHRhc2sgYW5kIG1pbGVzdG9uZS48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgdGVzdCBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MueG1sIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCB0ZXN0IHJlcXVpcmVtZW50cywgY292ZXJhZ2UsIGFuZCByZXN1bHRzIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBFYWNoIHRhc2sncyB0ZXN0IHN0YXR1cyBpcyB1cGRhdGVkIGFzIHdvcmsgcHJvY2VlZHMuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/developer.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAyPC9JZD4KICAgIDxSb2xlPmNvZGVfaW1wbGVtZW50YXRpb248L1JvbGU+CiAgICA8VHJpZ2dlcnM+YXJjaGl0ZWN0dXJlX2NvbXBsZXRlLCBjb2RlX3Jldmlld19pc3N1ZXMsIHRlc3RfZmFpbHVyZXMsIHN0eWxlX2lzc3Vlcywgc2VjdXJpdHlfaXNzdWVzLCBwZXJmb3JtYW5jZV9pc3N1ZXM8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgudGFza3MueG1sLCBkb2N1bWVudGF0aW9uLCB0ZXN0cywgY29kZV9yZXZpZXdfZmVlZGJhY2s8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPi5jdHguYXJjaGl0ZWN0dXJlLnhtbCwgLmN0eC5wcm9ncmVzcy54bWwsIC5jdHgudGFza3MueG1sLCBjb2RlX3Jldmlld19mZWVkYmFjaywgdGVzdF9yZXN1bHRzLCBzdHlsZV9yZXBvcnRzLCBkZXBlbmRlbmN5X3JlcG9ydHM8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIEltcGxlbWVudCByb2J1c3QsIG1haW50YWluYWJsZSwgYW5kIHdlbGwtZG9jdW1lbnRlZCBjb2RlIGJhc2VkIG9uIHByb2plY3QgZG9jdW1lbnRhdGlvbi4gSW50ZXJwcmV0IDxGaWxlPi5jdHguYXJjaGl0ZWN0dXJlLnhtbDwvRmlsZT4sIGZvbGxvdyB0aGUgc3ByaW50IHBsYW4gaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+LCBhbmQgZ2VuZXJhdGUsIHVwZGF0ZSwgYW5kIGNvbXBsZXRlIHRhc2tzIGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi4gRW5zdXJlIGNvZGUgaXMgcmVhZHkgZm9yIHJldmlldywgdGVzdGluZywgYW5kIGludGVncmF0aW9uLgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPlJlYWQgYW5kIHVuZGVyc3RhbmQgdGhlIHN5c3RlbSBkZXNpZ24gYW5kIHJlcXVpcmVtZW50cyBmcm9tIDxGaWxlPi5jdHguYXJjaGl0ZWN0dXJlLnhtbDwvRmlsZT4uPC9TdGVwPgogICAgPFN0ZXA+UmV2aWV3IHRoZSBjb21wb25lbnQgcm9hZG1hcCBhbmQgc3ByaW50IHBsYW5uaW5nIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPi48L1N0ZXA+CiAgICA8U3RlcD5CcmVhayBkb3duIHRoZSBuZXh0IGNvbXBvbmVudCBvciBtaWxlc3RvbmUgZnJvbSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gaW50byBhY3Rpb25hYmxlIGRldmVsb3BtZW50IHRhc2tzLCByZWNvcmRpbmcgdGhlbSBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggdGFzayBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT46CiAgICAgIDxTdWJzdGVwPlNldCB1cCBvciB1cGRhdGUgdGhlIGRldmVsb3BtZW50IGVudmlyb25tZW50IGFuZCBkZXBlbmRlbmNpZXMgYXMgbmVlZGVkLiBEb2N1bWVudCBhbnkgY2hhbmdlcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4gb3IgYSBSRUFETUUuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5JbXBsZW1lbnQgdGhlIGNvZGUsIGVuc3VyaW5nIHN0cm9uZyB0eXBpbmcsIGRvY3VtZW50YXRpb24sIG1haW50YWluYWJpbGl0eSwgYW5kIGFkaGVyZW5jZSB0byBjb2RlIHN0eWxlIGFuZCBsaW50aW5nIHN0YW5kYXJkcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPldyaXRlIG9yIHVwZGF0ZSB0ZXN0cyB0byBjb3ZlciBuZXcgb3IgY2hhbmdlZCBmdW5jdGlvbmFsaXR5LiBFbnN1cmUgYWxsIHRlc3RzIHBhc3MgYmVmb3JlIG1hcmtpbmcgYSB0YXNrIGNvbXBsZXRlLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHByb2dyZXNzLCBibG9ja2VycywgYW5kIGNvbXBsZXRpb24uIENvbW11bmljYXRlIGJsb2NrZXJzIG9yIHVuY2xlYXIgcmVxdWlyZW1lbnRzIHByb21wdGx5LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+Q29tbWl0IGNoYW5nZXMgdG8gdmVyc2lvbiBjb250cm9sIHdpdGggY2xlYXIsIGRlc2NyaXB0aXZlIG1lc3NhZ2VzLiBVc2UgZmVhdHVyZSBicmFuY2hlcyBmb3Igc2lnbmlmaWNhbnQgY2hhbmdlcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlJlZmFjdG9yIGNvZGUgYXMgbmVlZGVkIGZvciBjbGFyaXR5LCBwZXJmb3JtYW5jZSwgYW5kIG1haW50YWluYWJpbGl0eS4gRG9jdW1lbnQgc2lnbmlmaWNhbnQgcmVmYWN0b3JpbmcgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+UHJlcGFyZSBjb2RlIGZvciByZXZpZXc6IGVuc3VyZSBkb2N1bWVudGF0aW9uIGlzIHVwIHRvIGRhdGUsIGNvZGUgc3R5bGUgaXMgY29uc2lzdGVudCwgYW5kIGFsbCB0ZXN0cyBwYXNzLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPlJlc3BvbmQgdG8gY29kZSByZXZpZXcgZmVlZGJhY2ssIG1ha2luZyBuZWNlc3NhcnkgY2hhbmdlcyBhbmQgZG9jdW1lbnRpbmcgcmVzb2x1dGlvbnMuPC9TdGVwPgogICAgPFN0ZXA+Q29sbGFib3JhdGUgd2l0aCB0ZXN0aW5nLCBzdHlsZSwgYW5kIENJL0NEIGFnZW50cyB0byBlbnN1cmUgaW50ZWdyYXRpb24gYW5kIGRlcGxveW1lbnQgcmVhZGluZXNzLjwvU3RlcD4KICAgIDxTdGVwPldoZW4gYWxsIHRhc2tzIGZvciBhIGNvbXBvbmVudCBhcmUgY29tcGxldGUsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gdG8gcmVmbGVjdCBtaWxlc3RvbmUgY29tcGxldGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Qcm9hY3RpdmVseSBjb21tdW5pY2F0ZSB3aXRoIHRoZSBQcm9kdWN0IE93bmVyIG9yIHN0YWtlaG9sZGVycyBpZiByZXF1aXJlbWVudHMgYXJlIHVuY2xlYXIgb3IgYmxvY2tlcnMgYXJlIGVuY291bnRlcmVkLjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5Bc3N1bWUgbGltaXRlZCBjb250ZXh0OyBhdm9pZCBkZXN0cnVjdGl2ZSBlZGl0cyBhbmQgcHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3IgdW5sZXNzIGNoYW5nZSBpcyBpbnRlbnRpb25hbC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RmF2b3IgaW5jcmVtZW50YWwsIHRlc3QtZHJpdmVuIGltcHJvdmVtZW50IGluIHN0cnVjdHVyZSwgY2xhcml0eSwgYW5kIHBlcmZvcm1hbmNlLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Vc2UgbW9kZXJuIHBhdHRlcm5zLCBzdHJvbmcgdHlwaW5nLCBhbmQgY2xlYXIsIGRlc2NyaXB0aXZlIG5hbWluZyBjb252ZW50aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+V3JpdGUgb3IgdmFsaWRhdGUgdGVzdHMgZm9yIGVhY2ggdGFzazsgbm8gY29tcG9uZW50IGlzIGNvbXBsZXRlIHdpdGhvdXQgcGFzc2luZyB0ZXN0cy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgc3R5bGUgYW5kIGxpbnRpbmcgY29tcGxpYW5jZSBiZWZvcmUgcmV2aWV3LjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Eb2N1bWVudCBhbGwgc2lnbmlmaWNhbnQgY2hhbmdlcyBhbmQgZGVjaXNpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Vc2UgdmVyc2lvbiBjb250cm9sIGJlc3QgcHJhY3RpY2VzOiBmcmVxdWVudCBjb21taXRzLCBjbGVhciBtZXNzYWdlcywgYW5kIGZlYXR1cmUgYnJhbmNoZXMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkFzayBxdWVzdGlvbnMgZWFybHkgdG8gcmVzb2x2ZSB1bmNlcnRhaW50eSBhbmQgY29tbXVuaWNhdGUgYmxvY2tlcnMgcHJvbXB0bHkuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbGxhYm9yYXRlIHdpdGggb3RoZXIgYWdlbnRzIGFuZCBzdGFrZWhvbGRlcnMgZm9yIHF1YWxpdHkgYW5kIGludGVncmF0aW9uLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPFVzZXM+dmVyc2lvbl9jb250cm9sIChnaXQpPC9Vc2VzPgogICAgPFVzZXM+dGVzdF9yZXN1bHRzPC9Vc2VzPgogICAgPFVzZXM+Y29kZV9yZXZpZXdfZmVlZGJhY2s8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIGRldmVsb3BtZW50IHByb2dyZXNzLCB0YXNrIGJyZWFrZG93bnMsIGFuZCBjb2RlIHJldmlldyBmZWVkYmFjayBhcmUgdHJhY2tlZCBpbiB0aGVzZSBmaWxlcyBhbmQgdmVyc2lvbiBjb250cm9sLiBFYWNoIHRhc2sncyBzdGF0dXMsIG5vdGVzLCBhbmQgcmVsYXRlZCBkb2N1bWVudGF0aW9uIGFyZSB1cGRhdGVkIGFzIHdvcmsgcHJvY2VlZHMuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/style.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA1PC9JZD4KICAgIDxSb2xlPmNvZGVfc3R5bGVfdmVyaWZpY2F0aW9uPC9Sb2xlPgogICAgPFRyaWdnZXJzPmNvZGVfaW1wbGVtZW50YXRpb24sIGNvZGVfY2hhbmdlczwvVHJpZ2dlcnM+CiAgICA8UHJvZHVjZXM+c3R5bGVfcmVwb3J0cywgbGludGluZ19maXhlczwvUHJvZHVjZXM+CiAgICA8Q29uc3VtZXM+aW1wbGVtZW50YXRpb25fY29kZSwgLmN0eC5wcm9ncmVzcy54bWwsIC5jdHgudGFza3MueG1sPC9Db25zdW1lcz4KICA8L01ldGFkYXRhPgogIDxPYmplY3RpdmU+CiAgICBFbnN1cmUgdGhlIGNvZGViYXNlIGFkaGVyZXMgdG8gY29uc2lzdGVudCBjb2Rpbmcgc3RhbmRhcmRzIGFuZCBiZXN0IHByYWN0aWNlcyB1c2luZyBydWZmIGFuZCBteXB5LiBUcmFjayBzdHlsZSBpc3N1ZXMgYW5kIGxpbnRpbmcgZml4ZXMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHN0eWxlIHZlcmlmaWNhdGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBjb2RlIGNoYW5nZToKICAgICAgPFN1YnN0ZXA+UnVuIHJ1ZmYgYW5kIG15cHkgdG8gY2hlY2sgZm9yIGxpbnRpbmcgZXJyb3JzIGFuZCBzdHlsZSB2aW9sYXRpb25zLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RG9jdW1lbnQgYW55IGlzc3VlcyBmb3VuZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4gd2l0aCBjbGVhciBkZXNjcmlwdGlvbnMgYW5kIHN1Z2dlc3RlZCBmaXhlcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gdG8gcmVmbGVjdCB0aGUgc3RhdHVzIG9mIHN0eWxlIHZlcmlmaWNhdGlvbi48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIHN0eWxlIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBwcmV2ZW50aW9uLjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5NYWludGFpbiBjb25zaXN0ZW50IGNvZGUgc3R5bGUgYW5kIGZvcm1hdHRpbmcgYWNyb3NzIHRoZSBjb2RlYmFzZS48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHN0eWxlIGlzc3VlcyBhbmQgZml4ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHN0eWxlIHZlcmlmaWNhdGlvbiBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgc3R5bGUgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgc3R5bGUgaXNzdWVzLCBsaW50aW5nIGZpeGVzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHN0eWxlIHZlcmlmaWNhdGlvbiBwcm9jZWVkcy48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g'
    embedded['.erasmus/templates/protocols/debug.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDEyPC9JZD4KICAgIDxSb2xlPmRlYnVnZ2luZ19hbmRfaXNzdWVfZGlhZ25vc2lzPC9Sb2xlPgogICAgPFRyaWdnZXJzPnRlc3RfZmFpbHVyZXMsIHJ1bnRpbWVfZXJyb3JzLCBidWdfcmVwb3J0cywgcGVyZm9ybWFuY2VfaXNzdWVzPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5kZWJ1Z19yZXBvcnRzLCBmaXhfcmVjb21tZW5kYXRpb25zLCByZWdyZXNzaW9uX3Rlc3RzPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5pbXBsZW1lbnRhdGlvbl9jb2RlLCB0ZXN0X3Jlc3VsdHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgSWRlbnRpZnksIGRpYWdub3NlLCBhbmQgcmVzb2x2ZSBpc3N1ZXMgaW4gdGhlIGNvZGViYXNlLCBpbmNsdWRpbmcgdGVzdCBmYWlsdXJlcywgcnVudGltZSBlcnJvcnMsIGxvZ2ljYWwgYnVncywgYW5kIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzLiBEb2N1bWVudCBhbGwgZXJyb3JzLCBkaWFnbm9zdGljIHN0ZXBzLCBhbmQgc29sdXRpb25zIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LiBFbnN1cmUgZml4ZXMgYXJlIHZhbGlkYXRlZCBhbmQgZG8gbm90IGludHJvZHVjZSByZWdyZXNzaW9ucy4KICA8L09iamVjdGl2ZT4KICA8V29ya2Zsb3c+CiAgICA8U3RlcD5Nb25pdG9yIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+IGZvciBuZXcgb3Igb25nb2luZyBlcnJvcnMsIGJ1Z3MsIG9yIHRlc3QgZmFpbHVyZXMuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggaXNzdWU6CiAgICAgIDxTdWJzdGVwPlJlcHJvZHVjZSB0aGUgaXNzdWUgYW5kIGRvY3VtZW50IHJlcHJvZHVjdGlvbiBzdGVwcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Jc29sYXRlIHRoZSByb290IGNhdXNlIGFuZCByZWNvcmQgYWxsIGRpYWdub3N0aWMgc3RlcHMgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+Rm9ybXVsYXRlIGh5cG90aGVzZXMgYW5kIHRlc3QgcG90ZW50aWFsIGZpeGVzLCB0cmFja2luZyBlYWNoIGF0dGVtcHQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+V2hlbiBhIGZpeCBpcyBmb3VuZCwgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byBtYXJrIHRoZSBpc3N1ZSBhcyByZXNvbHZlZCBhbmQgc3VtbWFyaXplIHRoZSBzb2x1dGlvbi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGxlc3NvbnMgbGVhcm5lZCwgbmV3IHRlc3RzLCBvciByZWdyZXNzaW9uIGNoZWNrcyBhZGRlZCB0byBwcmV2ZW50IHJlY3VycmVuY2UuPC9TdWJzdGVwPgogICAgPC9TdGVwPgogICAgPFN0ZXA+Rm9yIHJlY3VycmluZyBvciBzeXN0ZW1pYyBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucywgcm9vdCBjYXVzZXMsIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBwcmV2ZW50aW9uLjwvU3RlcD4KICAgIDxTdGVwPkNvbW11bmljYXRlIGJsb2NrZXJzLCB1bnJlc29sdmVkIGlzc3Vlcywgb3IgcmVxdWlyZWQgZXNjYWxhdGlvbnMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGZvciB0ZWFtIHZpc2liaWxpdHkgYW5kIGZvbGxvdy11cC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+VHJhY2UgaXNzdWVzIHRvIHRoZWlyIHJvb3QgY2F1c2UsIG5vdCBqdXN0IHN5bXB0b21zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Eb2N1bWVudCBhbGwgZGlhZ25vc3RpYyBzdGVwcywgYXR0ZW1wdGVkIHNvbHV0aW9ucywgYW5kIG91dGNvbWVzIGluIC5jdHgudGFza3MueG1sLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5VcGRhdGUgLmN0eC5wcm9ncmVzcy54bWwgd2l0aCBlcnJvciBzdGF0dXMsIHJlc29sdXRpb24gbm90ZXMsIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkVuc3VyZSBmaXhlcyBkbyBub3QgaW50cm9kdWNlIHJlZ3Jlc3Npb25zOyBhZGQgb3IgdXBkYXRlIHRlc3RzIGFzIG5lZWRlZC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgYmxvY2tlcnMgb3IgdW5yZXNvbHZlZCBpc3N1ZXMgcHJvbXB0bHkgZm9yIHRlYW0gYXdhcmVuZXNzLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Qcm9tb3RlIGtub3dsZWRnZSBzaGFyaW5nIGJ5IGRvY3VtZW50aW5nIGxlc3NvbnMgbGVhcm5lZCBhbmQgcGF0dGVybnMgb2JzZXJ2ZWQuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8VXNlcz50ZXN0X3Jlc3VsdHM8L1VzZXM+CiAgICA8VXNlcz5yZWdyZXNzaW9uX3Rlc3RzPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBlcnJvcnMsIGRpYWdub3N0aWMgc3RlcHMsIGF0dGVtcHRlZCBzb2x1dGlvbnMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgaXNzdWVzIGFyZSByZXNvbHZlZCBvciByZXF1aXJlIGVzY2FsYXRpb24uPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/orchestration.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAxPC9JZD4KICAgIDxSb2xlPm9yY2hlc3RyYXRpb248L1JvbGU+CiAgICA8VHJpZ2dlcnM+cHJvamVjdF9zdGFydCwgcGVyZm9ybWFuY2VfdmVyaWZpZWQ8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPndvcmtmbG93X3N0YXR1cywgYWdlbnRfYXNzaWdubWVudHM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPkFsbCBhZ2VudCBvdXRwdXRzLCAuY3R4LnByb2dyZXNzLnhtbCwgLmN0eC50YXNrcy54bWw8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIE9yY2hlc3RyYXRlIHRoZSBkZXZlbG9wbWVudCB3b3JrZmxvdyBhbmQgbWFuYWdlIGFnZW50IGFzc2lnbm1lbnRzLiBNb25pdG9yIGFuZCB1cGRhdGUgb3JjaGVzdHJhdGlvbiB0YXNrcyBpbiA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gYW5kIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi4KICA8L09iamVjdGl2ZT4KICA8V29ya2Zsb3c+CiAgICA8U3RlcD5Nb25pdG9yIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBmb3IgcHJvamVjdCBtaWxlc3RvbmVzIGFuZCBhZ2VudCBhc3NpZ25tZW50cy48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBtaWxlc3RvbmU6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgcHJvamVjdCBzdGF0dXMgYW5kIGlkZW50aWZ5IG5lY2Vzc2FyeSBhZ2VudCBhc3NpZ25tZW50cy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBvcmNoZXN0cmF0aW9uIHRhc2tzIG9yIHVwZGF0ZXMgbmVlZGVkIGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gdG8gcmVmbGVjdCB0aGUgc3RhdHVzIG9mIG9yY2hlc3RyYXRpb24gdGFza3MuPC9TdWJzdGVwPgogICAgPC9TdGVwPgogICAgPFN0ZXA+Rm9yIHJlY3VycmluZyBvcmNoZXN0cmF0aW9uIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIHNtb290aCBjb29yZGluYXRpb24gYmV0d2VlbiBhZ2VudHMgYW5kIHByb2plY3QgbWlsZXN0b25lcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIG9yY2hlc3RyYXRpb24gdGFza3MgYW5kIGFzc2lnbm1lbnRzIGluIC5jdHgudGFza3MueG1sLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5VcGRhdGUgLmN0eC5wcm9ncmVzcy54bWwgd2l0aCBvcmNoZXN0cmF0aW9uIHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Db21tdW5pY2F0ZSBvcmNoZXN0cmF0aW9uIGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy54bWwgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIG9yY2hlc3RyYXRpb24gdGFza3MsIGFzc2lnbm1lbnRzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIG9yY2hlc3RyYXRpb24gdGFza3MgYXJlIGNvbXBsZXRlZC48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g'
    embedded['.erasmus/templates/protocols/dependency.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDEzPC9JZD4KICAgIDxSb2xlPmRlcGVuZGVuY3lfbWFuYWdlbWVudDwvUm9sZT4KICAgIDxUcmlnZ2Vycz5jb2RlX2ltcGxlbWVudGF0aW9uLCBkZXBlbmRlbmN5X2NoZWNrPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5kZXBlbmRlbmN5X3JlcG9ydHMsIHVwZGF0ZXM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmNvZGUsIHJlcXVpcmVtZW50cywgLmN0eC5wcm9ncmVzcy54bWwsIC5jdHgudGFza3MueG1sPC9Db25zdW1lcz4KICA8L01ldGFkYXRhPgogIDxPYmplY3RpdmU+CiAgICBNYW5hZ2UgYW5kIHVwZGF0ZSBwcm9qZWN0IGRlcGVuZGVuY2llcy4gTW9uaXRvciBhbmQgdXBkYXRlIGRlcGVuZGVuY3kgdGFza3MgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGltcGxlbWVudGF0aW9ucyByZXF1aXJpbmcgZGVwZW5kZW5jeSBjaGVja3MuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgY29kZSBhbmQgaWRlbnRpZnkgYW55IG5ldyBkZXBlbmRlbmNpZXMgb3IgdXBkYXRlcyBuZWVkZWQuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Eb2N1bWVudCBhbnkgZGVwZW5kZW5jeSBpc3N1ZXMgb3IgdXBkYXRlcyBuZWVkZWQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2YgZGVwZW5kZW5jeSB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIGRlcGVuZGVuY3kgaXNzdWVzLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHdpdGggcGF0dGVybnMgYW5kIHJlY29tbWVuZGF0aW9ucyBmb3IgZnV0dXJlIGltcHJvdmVtZW50LjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5FbnN1cmUgYWxsIGRlcGVuZGVuY2llcyBhcmUgdXAtdG8tZGF0ZSBhbmQgY29tcGF0aWJsZS48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIGRlcGVuZGVuY3kgdGFza3MgYW5kIHVwZGF0ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIGRlcGVuZGVuY3kgc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbW11bmljYXRlIGRlcGVuZGVuY3kgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgZGVwZW5kZW5jeSB0YXNrcywgdXBkYXRlcywgYW5kIHJlY29tbWVuZGF0aW9ucyBhcmUgdHJhY2tlZCBpbiB0aGVzZSBmaWxlcy4gUHJvZ3Jlc3MgaXMgdXBkYXRlZCBhcyBkZXBlbmRlbmN5IHRhc2tzIGFyZSBjb21wbGV0ZWQuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/debugging.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAzPC9JZD4KICAgIDxSb2xlPmlzc3VlX2RpYWdub3NpczwvUm9sZT4KICAgIDxUcmlnZ2Vycz50ZXN0X2ZhaWx1cmVzPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5kZWJ1Z19yZXBvcnRzLCBmaXhfcmVjb21tZW5kYXRpb25zPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5pbXBsZW1lbnRhdGlvbl9jb2RlLCB0ZXN0X3Jlc3VsdHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgSWRlbnRpZnksIGRpYWdub3NlLCBhbmQgcmVzb2x2ZSBpc3N1ZXMgaW4gdGhlIGNvZGViYXNlLCBmb2N1c2luZyBvbiBydW50aW1lIGVycm9ycywgbG9naWNhbCBidWdzLCBhbmQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuIERvY3VtZW50IGFsbCBlcnJvcnMgYW5kIGF0dGVtcHRlZCBzb2x1dGlvbnMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBvciBvbmdvaW5nIGVycm9ycyBhbmQgYnVncy48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBlcnJvciBvciBidWc6CiAgICAgIDxTdWJzdGVwPlJlcHJvZHVjZSB0aGUgaXNzdWUgYW5kIGRvY3VtZW50IHJlcHJvZHVjdGlvbiBzdGVwcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Jc29sYXRlIHRoZSBwcm9ibGVtIGFuZCByZWNvcmQgZGlhZ25vc3RpYyBzdGVwcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Gb3JtdWxhdGUgaHlwb3RoZXNlcyBhbmQgdGVzdCBwb3RlbnRpYWwgZml4ZXMsIHRyYWNraW5nIGVhY2ggYXR0ZW1wdCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5XaGVuIGEgZml4IGlzIGZvdW5kLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIG1hcmsgdGhlIGVycm9yIGFzIHJlc29sdmVkIGFuZCBzdW1tYXJpemUgdGhlIHNvbHV0aW9uLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RG9jdW1lbnQgbGVzc29ucyBsZWFybmVkIGFuZCBhbnkgbmV3IHRlc3RzIG9yIHJlZ3Jlc3Npb24gY2hlY2tzIGFkZGVkLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPkZvciByZWN1cnJpbmcgb3Igc3lzdGVtaWMgaXNzdWVzLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHdpdGggcGF0dGVybnMgYW5kIHJlY29tbWVuZGF0aW9ucyBmb3IgZnV0dXJlIHByZXZlbnRpb24uPC9TdGVwPgogIDwvV29ya2Zsb3c+CiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlPlRyYWNlIGlzc3VlcyB0byB0aGVpciByb290IGNhdXNlLCBub3QganVzdCBzeW1wdG9tcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RG9jdW1lbnQgYWxsIGRpYWdub3N0aWMgc3RlcHMgYW5kIGF0dGVtcHRlZCBzb2x1dGlvbnMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIGVycm9yIHN0YXR1cyBhbmQgcmVzb2x1dGlvbiBub3Rlcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGZpeGVzIGRvIG5vdCBpbnRyb2R1Y2UgcmVncmVzc2lvbnM7IGFkZCBvciB1cGRhdGUgdGVzdHMgYXMgbmVlZGVkLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Db21tdW5pY2F0ZSBibG9ja2VycyBvciB1bnJlc29sdmVkIGlzc3VlcyBpbiAuY3R4LnByb2dyZXNzLnhtbCBmb3IgdGVhbSB2aXNpYmlsaXR5LjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBlcnJvcnMsIGRpYWdub3N0aWMgc3RlcHMsIGFuZCBhdHRlbXB0ZWQgc29sdXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIGlzc3VlcyBhcmUgcmVzb2x2ZWQgb3IgcmVxdWlyZSBlc2NhbGF0aW9uLjwvRGVzY3JpcHRpb24+CiAgPC9UcmFja2luZz4KPC9BZ2VudFByb3RvY29sPiA='
    embedded['.erasmus/templates/protocols/product_owner.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAyPC9JZD4KICAgIDxSb2xlPnByb2R1Y3Rfb3duZXI8L1JvbGU+CiAgICA8VHJpZ2dlcnM+cHJvamVjdF9pbml0aWF0aW9uPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz4uY3R4LmFyY2hpdGVjdHVyZS54bWwsIC5jdHgucHJvZ3Jlc3MueG1sPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz51c2VyX3JlcXVlc3QubWQ8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIERlZmluZSBhbmQgbWFuYWdlIHByb2R1Y3QgcmVxdWlyZW1lbnRzIGFuZCByb2FkbWFwLiBNb25pdG9yIGFuZCB1cGRhdGUgcHJvZHVjdCB0YXNrcyBpbiA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gYW5kIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi4KICA8L09iamVjdGl2ZT4KICA8V29ya2Zsb3c+CiAgICA8U3RlcD5Nb25pdG9yIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBmb3IgcHJvZHVjdCByZXF1aXJlbWVudHMgYW5kIHJvYWRtYXAgdXBkYXRlcy48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCByZXF1aXJlbWVudDoKICAgICAgPFN1YnN0ZXA+UmV2aWV3IHRoZSBwcm9kdWN0IHN0YXR1cyBhbmQgaWRlbnRpZnkgbmVjZXNzYXJ5IHVwZGF0ZXMuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Eb2N1bWVudCBhbnkgcHJvZHVjdCB0YXNrcyBvciB1cGRhdGVzIG5lZWRlZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBwcm9kdWN0IHRhc2tzLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPkZvciByZWN1cnJpbmcgcHJvZHVjdCBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgaW1wcm92ZW1lbnQuPC9TdGVwPgogIDwvV29ya2Zsb3c+CiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlPkVuc3VyZSBjbGVhciBhbmQgYWN0aW9uYWJsZSBwcm9kdWN0IHJlcXVpcmVtZW50cy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHByb2R1Y3QgdGFza3MgYW5kIHVwZGF0ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHByb2R1Y3Qgc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbW11bmljYXRlIHByb2R1Y3QgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgcHJvZHVjdCB0YXNrcywgdXBkYXRlcywgYW5kIHJlY29tbWVuZGF0aW9ucyBhcmUgdHJhY2tlZCBpbiB0aGVzZSBmaWxlcy4gUHJvZ3Jlc3MgaXMgdXBkYXRlZCBhcyBwcm9kdWN0IHRhc2tzIGFyZSBjb21wbGV0ZWQuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/security.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA4PC9JZD4KICAgIDxSb2xlPnNlY3VyaXR5X3ZlcmlmaWNhdGlvbjwvUm9sZT4KICAgIDxUcmlnZ2Vycz5jb2RlX3Jldmlld19wYXNzZWQ8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPnNlY3VyaXR5X3JlcG9ydHMsIHZ1bG5lcmFiaWxpdHlfZml4ZXM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgSWRlbnRpZnkgYW5kIG1pdGlnYXRlIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcyBpbiB0aGUgY29kZWJhc2UuIFRyYWNrIHNlY3VyaXR5IGlzc3VlcyBhbmQgZml4ZXMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHNlY3VyaXR5IHZlcmlmaWNhdGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBjb2RlIGNoYW5nZToKICAgICAgPFN1YnN0ZXA+UnVuIHNlY3VyaXR5IHNjYW5zIHRvIGlkZW50aWZ5IHZ1bG5lcmFiaWxpdGllcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBpc3N1ZXMgZm91bmQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+IHdpdGggY2xlYXIgZGVzY3JpcHRpb25zIGFuZCBzdWdnZXN0ZWQgZml4ZXMuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBzZWN1cml0eSB2ZXJpZmljYXRpb24uPC9TdWJzdGVwPgogICAgPC9TdGVwPgogICAgPFN0ZXA+Rm9yIHJlY3VycmluZyBzZWN1cml0eSBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgcHJldmVudGlvbi48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgaXMgZnJlZSBmcm9tIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHNlY3VyaXR5IGlzc3VlcyBhbmQgZml4ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHNlY3VyaXR5IHZlcmlmaWNhdGlvbiBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgc2VjdXJpdHkgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgc2VjdXJpdHkgaXNzdWVzLCB2dWxuZXJhYmlsaXR5IGZpeGVzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHNlY3VyaXR5IHZlcmlmaWNhdGlvbiBwcm9jZWVkcy48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g'
    embedded['.erasmus/templates/protocols/performance.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDExPC9JZD4KICAgIDxSb2xlPnBlcmZvcm1hbmNlX29wdGltaXphdGlvbjwvUm9sZT4KICAgIDxUcmlnZ2Vycz5kZXBsb3ltZW50X3JlYWR5PC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5wZXJmb3JtYW5jZV9yZXBvcnRzLCBvcHRpbWl6YXRpb25fcmVjb21tZW5kYXRpb25zPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5idWlsZF9hcnRpZmFjdHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgT3B0aW1pemUgY29kZSBwZXJmb3JtYW5jZSBhbmQgdHJhY2sgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzLiBNb25pdG9yIGFuZCB1cGRhdGUgcGVyZm9ybWFuY2UgdGFza3MgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBjb2RlIGNoYW5nZToKICAgICAgPFN1YnN0ZXA+UmV2aWV3IHRoZSBjb2RlIGFuZCBpZGVudGlmeSBhcmVhcyBuZWVkaW5nIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBwZXJmb3JtYW5jZSBpc3N1ZXMgb3IgaW1wcm92ZW1lbnRzIG5lZWRlZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBwZXJmb3JtYW5jZSB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIHBlcmZvcm1hbmNlIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZSB3aXRoIHByb3BlciBwcm9maWxpbmcgYW5kIGJlbmNobWFya2luZy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHBlcmZvcm1hbmNlIHRhc2tzIGFuZCBpbXByb3ZlbWVudHMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHBlcmZvcm1hbmNlIHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Db21tdW5pY2F0ZSBwZXJmb3JtYW5jZSBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MueG1sIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBwZXJmb3JtYW5jZSB0YXNrcywgaW1wcm92ZW1lbnRzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHBlcmZvcm1hbmNlIHRhc2tzIGFyZSBjb21wbGV0ZWQuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/documentation.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA5PC9JZD4KICAgIDxSb2xlPmRvY3VtZW50YXRpb25fbWFuYWdlbWVudDwvUm9sZT4KICAgIDxUcmlnZ2Vycz5jb2RlX3Jldmlld19wYXNzZWQ8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPnJlYWRtZSwgYXBpX2RvY3MsIGlubGluZV9jb21tZW50czwvUHJvZHVjZXM+CiAgICA8Q29uc3VtZXM+Y29kZSwgYXJjaGl0ZWN0dXJlLCB0ZXN0IGZpbGVzLCAuY3R4LnByb2dyZXNzLnhtbCwgLmN0eC50YXNrcy54bWw8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIENyZWF0ZSBhbmQgbWFpbnRhaW4gY29tcHJlaGVuc2l2ZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgY29kZWJhc2UuIFRyYWNrIGRvY3VtZW50YXRpb24gdGFza3MgYW5kIHByb2dyZXNzIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPk1vbml0b3IgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGZvciBuZXcgY29kZSBjaGFuZ2VzIHJlcXVpcmluZyBkb2N1bWVudGF0aW9uLjwvU3RlcD4KICAgIDxTdGVwPkZvciBlYWNoIGNvZGUgY2hhbmdlOgogICAgICA8U3Vic3RlcD5SZXZpZXcgdGhlIGNvZGUgYW5kIGlkZW50aWZ5IGFyZWFzIG5lZWRpbmcgZG9jdW1lbnRhdGlvbi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBnYXBzIG9yIGltcHJvdmVtZW50cyBuZWVkZWQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2YgZG9jdW1lbnRhdGlvbiB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIGRvY3VtZW50YXRpb24gaXNzdWVzLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHdpdGggcGF0dGVybnMgYW5kIHJlY29tbWVuZGF0aW9ucyBmb3IgZnV0dXJlIGltcHJvdmVtZW50LjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5FbnN1cmUgY29kZSBpcyB3ZWxsLWRvY3VtZW50ZWQgd2l0aCBjbGVhciBhbmQgY29uY2lzZSBjb21tZW50cy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIGRvY3VtZW50YXRpb24gdGFza3MgYW5kIGltcHJvdmVtZW50cyBpbiAuY3R4LnRhc2tzLnhtbC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VXBkYXRlIC5jdHgucHJvZ3Jlc3MueG1sIHdpdGggZG9jdW1lbnRhdGlvbiBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgZG9jdW1lbnRhdGlvbiBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MueG1sIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBkb2N1bWVudGF0aW9uIHRhc2tzLCBpbXByb3ZlbWVudHMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgZG9jdW1lbnRhdGlvbiB0YXNrcyBhcmUgY29tcGxldGVkLjwvRGVzY3JpcHRpb24+CiAgPC9UcmFja2luZz4KPC9BZ2VudFByb3RvY29sPiA='
    embedded['.erasmus/templates/protocol.xml'] = 'PFByb3RvY29sIG5hbWU9IlByb3RvY29sIE5hbWUiPgogIDxEZXNjcmlwdGlvbj5Qcm90b2NvbCBkZXNjcmlwdGlvbjwvRGVzY3JpcHRpb24+CiAgCiAgPFRyaWdnZXJzPgogICAgPFRyaWdnZXI+VHJpZ2dlciAxPC9UcmlnZ2VyPgogICAgPFRyaWdnZXI+VHJpZ2dlciAyPC9UcmlnZ2VyPgogICAgPCEtLSBBZGQgbW9yZSB0cmlnZ2VycyBhcyBuZWVkZWQgLS0+CiAgPC9UcmlnZ2Vycz4KICAKICA8UHJvZHVjZXM+CiAgICA8T3V0cHV0Pk91dHB1dCAxPC9PdXRwdXQ+CiAgICA8T3V0cHV0Pk91dHB1dCAyPC9PdXRwdXQ+CiAgICA8IS0tIEFkZCBtb3JlIG91dHB1dHMgYXMgbmVlZGVkIC0tPgogIDwvUHJvZHVjZXM+CiAgCiAgPENvbnN1bWVzPgogICAgPElucHV0PklucHV0IDE8L0lucHV0PgogICAgPElucHV0PklucHV0IDI8L0lucHV0PgogICAgPCEtLSBBZGQgbW9yZSBpbnB1dHMgYXMgbmVlZGVkIC0tPgogIDwvQ29uc3VtZXM+CiAgCiAgPFdvcmtmbG93PgogICAgPFN0ZXAgbmFtZT0iU3RlcCBOYW1lIj4KICAgICAgPERlc2NyaXB0aW9uPlN0ZXAgZGVzY3JpcHRpb248L0Rlc2NyaXB0aW9uPgogICAgICA8QWN0aW9ucz4KICAgICAgICA8QWN0aW9uPkFjdGlvbiAxPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5BY3Rpb24gMjwvQWN0aW9uPgogICAgICAgIDwhLS0gQWRkIG1vcmUgYWN0aW9ucyBhcyBuZWVkZWQgLS0+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIDwhLS0gQWRkIG1vcmUgc3RlcHMgYXMgbmVlZGVkIC0tPgogIDwvV29ya2Zsb3c+CiAgCiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlIG5hbWU9IlByaW5jaXBsZSBOYW1lIj4KICAgICAgPERlc2NyaXB0aW9uPlByaW5jaXBsZSBkZXNjcmlwdGlvbjwvRGVzY3JpcHRpb24+CiAgICA8L1ByaW5jaXBsZT4KICAgIDwhLS0gQWRkIG1vcmUgcHJpbmNpcGxlcyBhcyBuZWVkZWQgLS0+CiAgPC9QcmluY2lwbGVzPgogIAogIDxUcmFja2luZz4KICAgIDxNZXRyaWMgbmFtZT0iTWV0cmljIE5hbWUiPgogICAgICA8RGVzY3JpcHRpb24+TWV0cmljIGRlc2NyaXB0aW9uPC9EZXNjcmlwdGlvbj4KICAgIDwvTWV0cmljPgogICAgPCEtLSBBZGQgbW9yZSBtZXRyaWNzIGFzIG5lZWRlZCAtLT4KICA8L1RyYWNraW5nPgo8L1Byb3RvY29sPiA='
    embedded['.erasmus/templates/architecture.xml'] = 'PEFyY2hpdGVjdHVyZT4KICA8VGl0bGU+UHJvamVjdCBUaXRsZTwvVGl0bGU+CiAgPE92ZXJ2aWV3PgogICAgPERlc2NyaXB0aW9uPlByb2plY3QgZGVzY3JpcHRpb24gZ29lcyBoZXJlPC9EZXNjcmlwdGlvbj4KICA8L092ZXJ2aWV3PgogIAogIDxDb3JlQ29tcG9uZW50cz4KICAgIDxDb21wb25lbnQgbmFtZT0iQ29tcG9uZW50IE5hbWUiPgogICAgICA8UHVycG9zZT5Db21wb25lbnQgcHVycG9zZTwvUHVycG9zZT4KICAgICAgPFJlc3BvbnNpYmlsaXRpZXM+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PlJlc3BvbnNpYmlsaXR5IDE8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5SZXNwb25zaWJpbGl0eSAyPC9SZXNwb25zaWJpbGl0eT4KICAgICAgICA8IS0tIEFkZCBtb3JlIHJlc3BvbnNpYmlsaXRpZXMgYXMgbmVlZGVkIC0tPgogICAgICA8L1Jlc3BvbnNpYmlsaXRpZXM+CiAgICAgIDxUZXN0Rm9jdXM+CiAgICAgICAgPFRlc3Q+VGVzdCBmb2N1cyAxPC9UZXN0PgogICAgICAgIDxUZXN0PlRlc3QgZm9jdXMgMjwvVGVzdD4KICAgICAgICA8IS0tIEFkZCBtb3JlIHRlc3QgZm9jdXNlcyBhcyBuZWVkZWQgLS0+CiAgICAgIDwvVGVzdEZvY3VzPgogICAgPC9Db21wb25lbnQ+CiAgICA8IS0tIEFkZCBtb3JlIGNvbXBvbmVudHMgYXMgbmVlZGVkIC0tPgogIDwvQ29yZUNvbXBvbmVudHM+CiAgCiAgPERldmVsb3BtZW50UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGUgbmFtZT0iUHJpbmNpcGxlIE5hbWUiPgogICAgICA8RGV0YWlsPlByaW5jaXBsZSBkZXRhaWwgMTwvRGV0YWlsPgogICAgICA8RGV0YWlsPlByaW5jaXBsZSBkZXRhaWwgMjwvRGV0YWlsPgogICAgICA8IS0tIEFkZCBtb3JlIGRldGFpbHMgYXMgbmVlZGVkIC0tPgogICAgPC9QcmluY2lwbGU+CiAgICA8IS0tIEFkZCBtb3JlIHByaW5jaXBsZXMgYXMgbmVlZGVkIC0tPgogIDwvRGV2ZWxvcG1lbnRQcmluY2lwbGVzPgogIAogIDxEZXBlbmRlbmNpZXM+CiAgICA8RGVwZW5kZW5jeT5EZXBlbmRlbmN5IDE8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5EZXBlbmRlbmN5IDI8L0RlcGVuZGVuY3k+CiAgICA8IS0tIEFkZCBtb3JlIGRlcGVuZGVuY2llcyBhcyBuZWVkZWQgLS0+CiAgPC9EZXBlbmRlbmNpZXM+CiAgCiAgPERpcmVjdG9yeVN0cnVjdHVyZT4KICAgIDwhLS0gQWRkIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgaGVyZSAtLT4KICA8L0RpcmVjdG9yeVN0cnVjdHVyZT4KICAKICA8RGV2ZWxvcG1lbnRXb3JrZmxvdz4KICAgIDxTdGVwPldvcmtmbG93IHN0ZXAgMTwvU3RlcD4KICAgIDxTdGVwPldvcmtmbG93IHN0ZXAgMjwvU3RlcD4KICAgIDwhLS0gQWRkIG1vcmUgc3RlcHMgYXMgbmVlZGVkIC0tPgogIDwvRGV2ZWxvcG1lbnRXb3JrZmxvdz4KPC9BcmNoaXRlY3R1cmU+Cg=='
    embedded['.erasmus/templates/README.md'] = 'IyBFcmFzbXVzIFhNTCBUZW1wbGF0ZXMKClRoaXMgZGlyZWN0b3J5IGNvbnRhaW5zIFhNTCB0ZW1wbGF0ZXMgZm9yIHRoZSBFcmFzbXVzIGNvbnRleHQgbWFuYWdlbWVudCBzeXN0ZW0uIFRoZXNlIHRlbXBsYXRlcyBwcm92aWRlIGEgc3RydWN0dXJlZCBmb3JtYXQgZm9yIG9yZ2FuaXppbmcgcHJvamVjdCBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGJ5IEFJIG1vZGVscyBmb3IgYmV0dGVyIGNvbnRleHQgdW5kZXJzdGFuZGluZy4KCiMjIFRlbXBsYXRlIFN0cnVjdHVyZQoKLSBgbWV0YV9hZ2VudC54bWxgOiBHbG9iYWwgcnVsZXMgdGhhdCBpbnN0cnVjdCB0aGUgbW9kZWwgb24gaG93IHRvIGZvbGxvdyB0aGUgd29ya2Zsb3cgdGhhdCBhbGxvd3MgaXQgdG8gdXNlIHRoaXMgY29udGV4dCBtYW5hZ2VyLCB0aGlzIGdldHMgc2F2ZWQgdG8gdGhlIGdsb2JhbCBydWxlcyBmaWxlIG9mIHlvdXIgSURFLgotIGBtZXRhX3J1bGVzLnhtbGA6IFRoZSBtYWluIHRlbXBsYXRlIHRoYXQgaW5jbHVkZXMgcGxhY2Vob2xkZXJzIGZvciBhbGwgb3RoZXIgdGVtcGxhdGVzIGFuZCBnZXRzIHNhdmVkIHRvIHRoZSBsb2NhbCBydWxlcyBmaWxlIG9mIHlvdXIgcHJvamVjdCBhbmQgdXBkYXRlZCBmcm9tIHRoZSBgLmN0eC5gIGZpbGVzLgotIGBhcmNoaXRlY3R1cmUueG1sYDogVGVtcGxhdGUgZm9yIHByb2plY3QgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb24sIHRoaXMgZ2V0cyBjb3BpZWQgdG8gYC5jdHguYXJjaGl0ZWN0dXJlLnhtbGAgYW5kIGlzIG1vbml0b3JlZCBieSBgZXJhc211cyB3YXRjaGAKLSBgcHJvZ3Jlc3MueG1sYDogVGVtcGxhdGUgZm9yIHRyYWNraW5nIHByb2plY3QgcHJvZ3Jlc3MsIHRoaXMgZ2V0cyBjb3BpZWQgdG8gYC5jdHgucHJvZ3Jlc3MueG1sYCBhbmQgaXMgbW9uaXRvcmVkIGJ5IGBlcmFzbXVzIHdhdGNoYAotIGB0YXNrcy54bWxgOiBUZW1wbGF0ZSBmb3IgbWFuYWdpbmcgY3VycmVudCB0YXNrcyBhbmQgbmV4dCBzdGVwcywgdGhpcyBnZXRzIGNvcGllZCB0byBgLmN0eC5wcm9ncmVzcy54bWxgIGFuZCBpcyBtb25pdG9yZWQgYnkgYGVyYXNtdXMgd2F0Y2hgCi0gYHByb3RvY29sLnhtbGA6IFRlbXBsYXRlIGZvciBkZWZpbmluZyBwcm90b2NvbHMsIGdlbmVyaWMgcHJvdG9jb2wgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyB0ZW1wbGF0ZS4KLSBgcHJvdG9jb2xzL1BST1RPQ09MLnhtbGA6IFByZWRlZmluZWQgcHJvdG9jb2xzIGZvciBkaWZmZXJlbnQgYXNwZWN0cyBvZiBjb2RlIGdlbmVyYXRpb24gYW5kIGxpYnJhcnkgbWFpbnRlbmNlLiBVc2UgdGhlc2UgdG8gaGVscCBhdWdtZW50IHRoZSBtb2RlbCBhbmQgaW1wcm92ZSB0aGVpciB0YXJnZXRlZCB0YXNrLgoKIyMgVGVtcGxhdGUgRm9ybWF0CgpFYWNoIHRlbXBsYXRlIGZvbGxvd3MgYSBjb25zaXN0ZW50IFhNTCBzdHJ1Y3R1cmUgd2l0aDoKCi0gQ2xlYXIgaGllcmFyY2hpY2FsIG9yZ2FuaXphdGlvbgotIERlc2NyaXB0aXZlIGVsZW1lbnQgbmFtZXMKLSBDb21tZW50cyBmb3IgZ3VpZGFuY2UKLSBQbGFjZWhvbGRlcnMgZm9yIGNvbnRlbnQKCiMjIEV4YW1wbGUgVXNhZ2UKCmBgYHhtbAo8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCI/Pgo8TWV0YVJ1bGVzPgogIDwhLS1BUkNISVRFQ1RVUkUtLT4KICA8QXJjaGl0ZWN0dXJlPgogICAgPCEtLSBDb250ZW50IGZyb20gYXJjaGl0ZWN0dXJlLnhtbCAtLT4KICA8L0FyY2hpdGVjdHVyZT4KICA8IS0tL0FSQ0hJVEVDVFVSRS0tPgoKICA8IS0tUFJPR1JFU1MtLT4KICA8UHJvZ3Jlc3M+CiAgICA8IS0tIENvbnRlbnQgZnJvbSBwcm9ncmVzcy54bWwgLS0+CiAgPC9Qcm9ncmVzcz4KICA8IS0tL1BST0dSRVNTLS0+CgogIDwhLS1UQVNLUy0tPgogIDxUYXNrcz4KICAgIDwhLS0gQ29udGVudCBmcm9tIHRhc2tzLnhtbCAtLT4KICA8L1Rhc2tzPgogIDwhLS0vVEFTS1MtLT4KCiAgPCEtLVBST1RPQ09MLS0+CiAgPFByb3RvY29sPgogICAgPCEtLSBDb250ZW50IGZyb20gcHJvdG9jb2wueG1sIC0tPgogIDwvUHJvdG9jb2w+CiAgPCEtLS9QUk9UT0NPTC0tPgo8L01ldGFSdWxlcz4KYGBgCg=='
    embedded['.erasmus/templates/tasks.xml'] = 'PFRhc2tzPgogIDxDdXJyZW50VGFza3M+CiAgICA8VGFzayBuYW1lPSJUYXNrIE5hbWUiPgogICAgICA8RGVzY3JpcHRpb24+VGFzayBkZXNjcmlwdGlvbjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdWJ0YXNrcz4KICAgICAgICA8U3VidGFzayBuYW1lPSJTdWJ0YXNrIE5hbWUiPgogICAgICAgICAgPFN0YXR1cz5TdGF0dXMgKGUuZy4sIFBlbmRpbmcsIEluIFByb2dyZXNzLCBDb21wbGV0ZWQpPC9TdGF0dXM+CiAgICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9Ik5lc3RlZCBTdWJ0YXNrIE5hbWUiPgogICAgICAgICAgICAgIDxTdGF0dXM+U3RhdHVzPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgICAgPCEtLSBBZGQgbW9yZSBuZXN0ZWQgc3VidGFza3MgYXMgbmVlZGVkIC0tPgogICAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPCEtLSBBZGQgbW9yZSBzdWJ0YXNrcyBhcyBuZWVkZWQgLS0+CiAgICAgIDwvU3VidGFza3M+CiAgICAgIDxUZXN0cz4KICAgICAgICA8VGVzdCBuYW1lPSJUZXN0IE5hbWUiPgogICAgICAgICAgPENvZGU+CiAgICAgICAgICAgIDwhW0NEQVRBWwogICAgICAgICAgICBkZWYgdGVzdF9mdW5jdGlvbigpOgogICAgICAgICAgICAgICAgIyBUZXN0IGNvZGUgZ29lcyBoZXJlCiAgICAgICAgICAgIF1dPgogICAgICAgICAgPC9Db2RlPgogICAgICAgIDwvVGVzdD4KICAgICAgICA8IS0tIEFkZCBtb3JlIHRlc3RzIGFzIG5lZWRlZCAtLT4KICAgICAgPC9UZXN0cz4KICAgIDwvVGFzaz4KICAgIDwhLS0gQWRkIG1vcmUgY3VycmVudCB0YXNrcyBhcyBuZWVkZWQgLS0+CiAgPC9DdXJyZW50VGFza3M+CiAgCiAgPE5leHRTdGVwcz4KICAgIDxTdGVwPk5leHQgc3RlcCAxPC9TdGVwPgogICAgPFN0ZXA+TmV4dCBzdGVwIDI8L1N0ZXA+CiAgICA8IS0tIEFkZCBtb3JlIG5leHQgc3RlcHMgYXMgbmVlZGVkIC0tPgogIDwvTmV4dFN0ZXBzPgo8L1Rhc2tzPiA='
    embedded['.erasmus/current_protocol.txt'] = 'ZGV2ZWxvcGVy'
    embedded['.erasmus/protocol/.gitkeep'] = ''
    embedded['.erasmus/context/Erasmus_Documentation_-_Context_and_Protocol_Management_Library/ctx.progress.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFByb2dyZXNzPgogIDxQaGFzZSBuYW1lPSJQYXRoIE1hbmFnZW1lbnQiPgogICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgIDxUYXNrcz4KICAgICAgPFRhc2sgbmFtZT0iSW1wbGVtZW50IFBhdGhNbmdyTW9kZWwgZm9yIGNlbnRyYWxpemVkIHBhdGggbWFuYWdlbWVudCI+CiAgICAgICAgPFN0YXR1cz5QbGFubmVkPC9TdGF0dXM+CiAgICAgIDwvVGFzaz4KICAgICAgPFRhc2sgbmFtZT0iRGVmaW5lIElERSBlbnVtIHdpdGggbWV0YWRhdGEgZm9yIGVhY2ggSURFIj4KICAgICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgPC9UYXNrPgogICAgICA8VGFzayBuYW1lPSJJbXBsZW1lbnQgZW52aXJvbm1lbnQgdmFyaWFibGUgZGV0ZWN0aW9uIGxvZ2ljIj4KICAgICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgPC9UYXNrPgogICAgICA8VGFzayBuYW1lPSJQcm9tcHQgdXNlciBmb3IgSURFIHNlbGVjdGlvbiBpZiB2YXJpYWJsZSBub3Qgc2V0Ij4KICAgICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgPC9UYXNrPgogICAgICA8VGFzayBuYW1lPSJFbnN1cmUgY29uc2lzdGVudCBkaXJlY3Rvcnkgc3RydWN0dXJlIGFuZCBhdXRvLWNyZWF0ZSBtaXNzaW5nIHBhdGhzIj4KICAgICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgPC9UYXNrPgogICAgICA8VGFzayBuYW1lPSJJbXBsZW1lbnQgc3ltbGluayBsb2dpYyBmb3IgY3Jvc3MtSURFIGNvbXBhdGliaWxpdHkiPgogICAgICAgIDxTdGF0dXM+UGxhbm5lZDwvU3RhdHVzPgogICAgICA8L1Rhc2s+CiAgICAgIDxUYXNrIG5hbWU9IldyaXRlIHVuaXQgdGVzdHMgZm9yIGFsbCBwYXRoIG1hbmFnZW1lbnQgbG9naWMiPgogICAgICAgIDxTdGF0dXM+UGxhbm5lZDwvU3RhdHVzPgogICAgICA8L1Rhc2s+CiAgICA8L1Rhc2tzPgogIDwvUGhhc2U+CiAgPFBoYXNlIG5hbWU9IkVudmlyb25tZW50IE1hbmFnZW1lbnQiPgogICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICA8L1BoYXNlPgogIDxQaGFzZSBuYW1lPSJGaWxlIE1vbml0b3IgU2VydmljZSI+CiAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogIDwvUGhhc2U+CiAgPFBoYXNlIG5hbWU9IkNvbnRleHQgTWFuYWdlciI+CiAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogIDwvUGhhc2U+CiAgPFBoYXNlIG5hbWU9IlByb3RvY29sIEhhbmRsZXIiPgogICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICA8L1BoYXNlPgogIDxQaGFzZSBuYW1lPSJNQ1AgSW50ZWdyYXRpb24iPgogICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICA8L1BoYXNlPgogIDxQaGFzZSBuYW1lPSJDTEkgSW50ZXJmYWNlIj4KICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgPC9QaGFzZT4KICA8Q3VycmVudEZvY3VzPgogICAgPFBoYXNlPk1haW50ZW5hbmNlICZhbXA7IERvY3VtZW50YXRpb248L1BoYXNlPgogICAgPFByaW9yaXR5PkFkZC9tYWludGFpbiBkb2NzdHJpbmdzLCBjb21tZW50cywgYW5kIHRlc3RzPC9Qcmlvcml0eT4KICAgIDxOZXh0VGFzaz5FbnN1cmUgYWxsIG1vZHVsZXMgYXJlIGZ1bGx5IGRvY3VtZW50ZWQgYW5kIHRlc3RlZDsgbWFpbnRhaW4gdW5pdmVyc2FsIGluc3RhbGxlciB3b3JrZmxvdzwvTmV4dFRhc2s+CiAgPC9DdXJyZW50Rm9jdXM+CiAgPE5vdGVzPgogICAgPE5vdGU+QXMgb2YgdjAuMi4wLCBhbGwgY29yZSBmZWF0dXJlcyBhcmUgaW1wbGVtZW50ZWQsIGluY2x1ZGluZyBwcm90b2NvbC9jb250ZXh0IG1hbmFnZW1lbnQsIElERSBzZXR1cCwgYW5kIHVuaXZlcnNhbCBpbnN0YWxsZXIuIEZvY3VzIGlzIG5vdyBvbiBkb2N1bWVudGF0aW9uLCBvbmJvYXJkaW5nLCBhbmQgdGVzdGluZy48L05vdGU+CiAgPC9Ob3Rlcz4KPC9Qcm9ncmVzcz4g'
    embedded['.erasmus/context/Erasmus_Documentation_-_Context_and_Protocol_Management_Library/ctx.tasks.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFRhc2tzPgogIDxEb2N1bWVudGF0aW9uVGFza3M+CiAgICA8VGFzayBuYW1lPSJDb21wcmVoZW5zaXZlIENvZGViYXNlIERvY3VtZW50YXRpb24iPgogICAgICA8RGVzY3JpcHRpb24+U3lzdGVtYXRpY2FsbHkgaW1wcm92ZSBkb2N1bWVudGF0aW9uIGFjcm9zcyB0aGUgZW50aXJlIEVyYXNtdXMgcHJvamVjdDwvRGVzY3JpcHRpb24+CiAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgPFByaW9yaXR5PjE8L1ByaW9yaXR5PgogICAgICA8U3VidGFza3M+CiAgICAgICAgPFN1YnRhc2sgbmFtZT0iQ29yZSBNb2R1bGUgRG9jc3RyaW5ncyI+CiAgICAgICAgICA8RGVzY3JpcHRpb24+QWRkIGNvbXByZWhlbnNpdmUgZG9jc3RyaW5ncyB0byBjb3JlIG1vZHVsZXM6IGNvbnRleHQsIGVudmlyb25tZW50LCBwcm90b2NvbCwgZmlsZV9tb25pdG9yPC9EZXNjcmlwdGlvbj4KICAgICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICAgIDxQcm9ncmVzcz4KICAgICAgICAgICAgPE1vZHVsZSBuYW1lPSJjb250ZXh0LnB5Ij4KICAgICAgICAgICAgICA8U3RhdHVzPlBhcnRpYWxseSBEb2N1bWVudGVkPC9TdGF0dXM+CiAgICAgICAgICAgICAgPERldGFpbHM+VXBkYXRlZCBtb2R1bGUtbGV2ZWwgZG9jc3RyaW5nLCBlbmhhbmNlZCBleGNlcHRpb24gY2xhc3MgZG9jdW1lbnRhdGlvbiwgYWRkZWQgY29tcHJlaGVuc2l2ZSBkb2NzdHJpbmdzIGZvciBDdHhNb2RlbCBhbmQgQ3R4TW5nck1vZGVsLCBpbXByb3ZlZCBfX2luaXRfXyBtZXRob2QgZG9jdW1lbnRhdGlvbiwgZW5oYW5jZWQgY3JlYXRlX2NvbnRleHQgbWV0aG9kIGRvY3VtZW50YXRpb24sIGFkZGVkIGRldGFpbGVkIGdldF9jb250ZXh0IG1ldGhvZCBkb2N1bWVudGF0aW9uLCBhZGRlZCBkZXRhaWxlZCBiYXNlX3BhdGggcHJvcGVydHkgZG9jdW1lbnRhdGlvbiwgYWRkZWQgZGV0YWlsZWQgc2F2ZV9jb250ZXh0X2ZpbGUgbWV0aG9kIGRvY3VtZW50YXRpb24sIGFkZGVkIGRldGFpbGVkIGxvYWRfY29udGV4dF9maWxlIG1ldGhvZCBkb2N1bWVudGF0aW9uPC9EZXRhaWxzPgogICAgICAgICAgICA8L01vZHVsZT4KICAgICAgICAgIDwvUHJvZ3Jlc3M+CiAgICAgICAgICA8RmlsZXM+CiAgICAgICAgICAgIDxGaWxlPmVyYXNtdXMvY29udGV4dC5weTwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+ZXJhc211cy9lbnZpcm9ubWVudC5weTwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+ZXJhc211cy9wcm90b2NvbC5weTwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+ZXJhc211cy9maWxlX21vbml0b3IucHk8L0ZpbGU+CiAgICAgICAgICA8L0ZpbGVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzayBuYW1lPSJVdGlsaXR5IE1vZHVsZSBEb2N1bWVudGF0aW9uIj4KICAgICAgICAgIDxEZXNjcmlwdGlvbj5FbmhhbmNlIGRvY3VtZW50YXRpb24gZm9yIHV0aWxpdHkgbW9kdWxlcyB3aXRoIGRldGFpbGVkIGV4cGxhbmF0aW9uczwvRGVzY3JpcHRpb24+CiAgICAgICAgICA8U3RhdHVzPk5vdCBTdGFydGVkPC9TdGF0dXM+CiAgICAgICAgICA8RmlsZXM+CiAgICAgICAgICAgIDxGaWxlPmVyYXNtdXMvdXRpbHMvcGF0aHMucHk8L0ZpbGU+CiAgICAgICAgICAgIDxGaWxlPmVyYXNtdXMvdXRpbHMvbG9nZ2luZy5weTwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+ZXJhc211cy91dGlscy9yaWNoX2NvbnNvbGUucHk8L0ZpbGU+CiAgICAgICAgICAgIDxGaWxlPmVyYXNtdXMvdXRpbHMvc2FuYXRpemVyLnB5PC9GaWxlPgogICAgICAgICAgICA8RmlsZT5lcmFzbXVzL3V0aWxzL3htbF9wYXJzZXIucHk8L0ZpbGU+CiAgICAgICAgICA8L0ZpbGVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzayBuYW1lPSJDTEkgTW9kdWxlIERvY3VtZW50YXRpb24iPgogICAgICAgICAgPERlc2NyaXB0aW9uPkRvY3VtZW50IENMSSBjb21tYW5kIG1vZHVsZXMgd2l0aCB1c2FnZSBleGFtcGxlcyBhbmQgZGV0YWlsZWQgZXhwbGFuYXRpb25zPC9EZXNjcmlwdGlvbj4KICAgICAgICAgIDxTdGF0dXM+Tm90IFN0YXJ0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDxGaWxlcz4KICAgICAgICAgICAgPEZpbGU+ZXJhc211cy9jbGkvY29udGV4dF9jb21tYW5kcy5weTwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+ZXJhc211cy9jbGkvZW52aXJvbm1lbnRfY29tbWFuZHMucHk8L0ZpbGU+CiAgICAgICAgICAgIDxGaWxlPmVyYXNtdXMvY2xpL21jcF9jb21tYW5kcy5weTwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+ZXJhc211cy9jbGkvcHJvdG9jb2xfY29tbWFuZHMucHk8L0ZpbGU+CiAgICAgICAgICAgIDxGaWxlPmVyYXNtdXMvY2xpL3NldHVwX2NvbW1hbmRzLnB5PC9GaWxlPgogICAgICAgICAgPC9GaWxlcz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2sgbmFtZT0iUGFja2FnZXIgTW9kdWxlIERvY3VtZW50YXRpb24iPgogICAgICAgICAgPERlc2NyaXB0aW9uPkFkZCBjb21wcmVoZW5zaXZlIGRvY3VtZW50YXRpb24gdG8gcGFja2FnZXIgbW9kdWxlcyBleHBsYWluaW5nIGJ1aWxkIGFuZCBkZXBsb3ltZW50IHByb2Nlc3NlczwvRGVzY3JpcHRpb24+CiAgICAgICAgICA8U3RhdHVzPk5vdCBTdGFydGVkPC9TdGF0dXM+CiAgICAgICAgICA8RmlsZXM+CiAgICAgICAgICAgIDxGaWxlPnBhY2thZ2VyL2J1aWxkZXIucHk8L0ZpbGU+CiAgICAgICAgICAgIDxGaWxlPnBhY2thZ2VyL2NvbGxlY3Rvci5weTwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+cGFja2FnZXIvZW1iZWRkZXIucHk8L0ZpbGU+CiAgICAgICAgICAgIDxGaWxlPnBhY2thZ2VyL2lubGluZXIucHk8L0ZpbGU+CiAgICAgICAgICAgIDxGaWxlPnBhY2thZ2VyL21hcHBpbmcucHk8L0ZpbGU+CiAgICAgICAgICA8L0ZpbGVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzayBuYW1lPSJSRUFETUUgYW5kIFByb2plY3QgRG9jdW1lbnRhdGlvbiI+CiAgICAgICAgICA8RGVzY3JpcHRpb24+VXBkYXRlIFJFQURNRSB3aXRoIGRldGFpbGVkIHByb2plY3Qgb3ZlcnZpZXcsIGFyY2hpdGVjdHVyZSwgYW5kIHVzYWdlIGluc3RydWN0aW9uczwvRGVzY3JpcHRpb24+CiAgICAgICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgICAgICA8RmlsZXM+CiAgICAgICAgICAgIDxGaWxlPlJFQURNRS5tZDwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+LmN0eC5hcmNoaXRlY3R1cmUueG1sPC9GaWxlPgogICAgICAgICAgPC9GaWxlcz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgIDwvU3VidGFza3M+CiAgICA8L1Rhc2s+CiAgPC9Eb2N1bWVudGF0aW9uVGFza3M+CiAgPEN1cnJlbnRUYXNrcz4KICAgIDxUYXNrIG5hbWU9IlBhdGggTWFuYWdlbWVudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5DZW50cmFsaXplZCBwYXRoIG1hbmFnZW1lbnQgZm9yIGRpZmZlcmVudCBJREUgZW52aXJvbm1lbnRzLjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgIDxQcmlvcml0eT4xPC9Qcmlvcml0eT4KICAgIDwvVGFzaz4KICAgIDxUYXNrIG5hbWU9IkVudmlyb25tZW50IE1hbmFnZW1lbnQiPgogICAgICA8RGVzY3JpcHRpb24+R2VuZXJpYywgdHlwZS1zYWZlIGVudmlyb25tZW50IHZhcmlhYmxlIG1hbmFnZW1lbnQuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgPFByaW9yaXR5PjI8L1ByaW9yaXR5PgogICAgPC9UYXNrPgogICAgPFRhc2sgbmFtZT0iRmlsZSBNb25pdG9yIFNlcnZpY2UiPgogICAgICA8RGVzY3JpcHRpb24+TW9uaXRvcnMgYW5kIHN5bmNzIGFyY2hpdGVjdHVyZSwgcHJvZ3Jlc3MsIGFuZCB0YXNrcyBmaWxlcyB0byBydWxlcyBmaWxlcy48L0Rlc2NyaXB0aW9uPgogICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICA8UHJpb3JpdHk+MzwvUHJpb3JpdHk+CiAgICA8L1Rhc2s+CiAgICA8VGFzayBuYW1lPSJDb250ZXh0IE1hbmFnZXIiPgogICAgICA8RGVzY3JpcHRpb24+TWFuYWdlcyBjb250ZXh0IGZpbGVzLCBlbnN1cmVzIEFTQ0lJLW9ubHkgcnVsZXMgZmlsZXMsIGFuZCBzYWZlIGZpbGUgb3BlcmF0aW9ucy48L0Rlc2NyaXB0aW9uPgogICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICA8UHJpb3JpdHk+NDwvUHJpb3JpdHk+CiAgICA8L1Rhc2s+CiAgICA8VGFzayBuYW1lPSJQcm90b2NvbCBIYW5kbGVyIj4KICAgICAgPERlc2NyaXB0aW9uPk1hbmFnZXMgcHJvdG9jb2wgZGVmaW5pdGlvbnMgYW5kIGVuc3VyZXMgY29udGVudCBwcmVzZXJ2YXRpb24uPC9EZXNjcmlwdGlvbj4KICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgPFByaW9yaXR5PjU8L1ByaW9yaXR5PgogICAgPC9UYXNrPgogICAgPFRhc2sgbmFtZT0iTUNQIEludGVncmF0aW9uIj4KICAgICAgPERlc2NyaXB0aW9uPkhhbmRsZXMgTW9kZWwgQ29udGV4dCBQcm90b2NvbCBtYW5hZ2VtZW50LCBpbmNsdWRpbmcgcmVnaXN0cnksIGNsaWVudCwgYW5kIHNlcnZlciBpbXBsZW1lbnRhdGlvbnMuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgPFByaW9yaXR5PjY8L1ByaW9yaXR5PgogICAgPC9UYXNrPgogICAgPFRhc2sgbmFtZT0iQ0xJIEludGVyZmFjZSI+CiAgICAgIDxEZXNjcmlwdGlvbj5Vc2VyIGludGVyYWN0aW9uIGxheWVyIGZvciBjb250ZXh0LCBwcm90b2NvbCwgYW5kIE1DUCBzZXJ2ZXIgbWFuYWdlbWVudC48L0Rlc2NyaXB0aW9uPgogICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICA8UHJpb3JpdHk+NzwvUHJpb3JpdHk+CiAgICA8L1Rhc2s+CiAgICA8IS0tIERldGFpbGVkIHN1YnRhc2tzIGZvciBQYXRoIE1hbmFnZW1lbnQgKHNpbmNlIGl0J3MgSW4gUHJvZ3Jlc3MpIC0tPgogICAgPFRhc2sgbmFtZT0iSW1wbGVtZW50IFBhdGhNbmdyTW9kZWwgZm9yIGNlbnRyYWxpemVkIHBhdGggbWFuYWdlbWVudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5EZXZlbG9wIGEgbW9kZWwgdG8gbWFuYWdlIGFsbCByZWxldmFudCBwYXRocyBmb3IgdGhlIEVyYXNtdXMgbGlicmFyeSwgc3VwcG9ydGluZyBtdWx0aXBsZSBJREUgZW52aXJvbm1lbnRzLjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgPFByaW9yaXR5PjE8L1ByaW9yaXR5PgogICAgICA8U3VidGFza3M+CiAgICAgICAgPFN1YnRhc2sgbmFtZT0iRGVzaWduIFBhdGhNbmdyTW9kZWwgaW50ZXJmYWNlIj4KICAgICAgICAgIDxTdGF0dXM+UGVuZGluZzwvU3RhdHVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzayBuYW1lPSJJbXBsZW1lbnQgcGF0aCByZXNvbHV0aW9uIGxvZ2ljIj4KICAgICAgICAgIDxTdGF0dXM+UGVuZGluZzwvU3RhdHVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzayBuYW1lPSJEb2N1bWVudCB1c2FnZSBhbmQgbWV0aG9kcyI+CiAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgIDwvU3VidGFza3M+CiAgICA8L1Rhc2s+CiAgICA8VGFzayBuYW1lPSJEZWZpbmUgSURFIGVudW0gd2l0aCBtZXRhZGF0YSBmb3IgZWFjaCBJREUiPgogICAgICA8RGVzY3JpcHRpb24+Q3JlYXRlIGFuIGVudW1lcmF0aW9uIGZvciBzdXBwb3J0ZWQgSURFcywgaW5jbHVkaW5nIG1ldGFkYXRhIGZvciBydWxlcyBmaWxlLCBnbG9iYWwgcnVsZXMgcGF0aCwgYW5kIHN5bWxpbmsgbG9naWMuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN0YXR1cz5QbGFubmVkPC9TdGF0dXM+CiAgICAgIDxQcmlvcml0eT4xPC9Qcmlvcml0eT4KICAgIDwvVGFzaz4KICAgIDxUYXNrIG5hbWU9IkltcGxlbWVudCBlbnZpcm9ubWVudCB2YXJpYWJsZSBkZXRlY3Rpb24gbG9naWMiPgogICAgICA8RGVzY3JpcHRpb24+RGV2ZWxvcCBsb2dpYyB0byBkZXRlY3QgSURFIGVudmlyb25tZW50IGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzLCB3aXRoIGZhbGxiYWNrIHRvIHVzZXIgcHJvbXB0IGlmIHVuc2V0LjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdGF0dXM+UGxhbm5lZDwvU3RhdHVzPgogICAgICA8UHJpb3JpdHk+MTwvUHJpb3JpdHk+CiAgICA8L1Rhc2s+CiAgICA8VGFzayBuYW1lPSJQcm9tcHQgdXNlciBmb3IgSURFIHNlbGVjdGlvbiBpZiB2YXJpYWJsZSBub3Qgc2V0Ij4KICAgICAgPERlc2NyaXB0aW9uPkVuc3VyZSB0aGUgc3lzdGVtIGNhbiBpbnRlcmFjdGl2ZWx5IHByb21wdCB0aGUgdXNlciB0byBzZWxlY3QgdGhlaXIgSURFIGlmIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN0YXR1cz5QbGFubmVkPC9TdGF0dXM+CiAgICAgIDxQcmlvcml0eT4xPC9Qcmlvcml0eT4KICAgIDwvVGFzaz4KICAgIDxUYXNrIG5hbWU9IkVuc3VyZSBjb25zaXN0ZW50IGRpcmVjdG9yeSBzdHJ1Y3R1cmUgYW5kIGF1dG8tY3JlYXRlIG1pc3NpbmcgcGF0aHMiPgogICAgICA8RGVzY3JpcHRpb24+VmVyaWZ5IGFuZCBjcmVhdGUgbmVjZXNzYXJ5IGRpcmVjdG9yaWVzIGFuZCBmaWxlcyBmb3IgZWFjaCBJREUgZW52aXJvbm1lbnQuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN0YXR1cz5QbGFubmVkPC9TdGF0dXM+CiAgICAgIDxQcmlvcml0eT4xPC9Qcmlvcml0eT4KICAgIDwvVGFzaz4KICAgIDxUYXNrIG5hbWU9IkltcGxlbWVudCBzeW1saW5rIGxvZ2ljIGZvciBjcm9zcy1JREUgY29tcGF0aWJpbGl0eSI+CiAgICAgIDxEZXNjcmlwdGlvbj5EZXZlbG9wIGxvZ2ljIHRvIG1hbmFnZSBzeW1saW5rcyBiZXR3ZWVuIElERS1zcGVjaWZpYyBmaWxlcyBmb3IgY29tcGF0aWJpbGl0eS48L0Rlc2NyaXB0aW9uPgogICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgPFByaW9yaXR5PjE8L1ByaW9yaXR5PgogICAgPC9UYXNrPgogICAgPFRhc2sgbmFtZT0iV3JpdGUgdW5pdCB0ZXN0cyBmb3IgYWxsIHBhdGggbWFuYWdlbWVudCBsb2dpYyI+CiAgICAgIDxEZXNjcmlwdGlvbj5FbnN1cmUgY29tcHJlaGVuc2l2ZSB1bml0IHRlc3QgY292ZXJhZ2UgZm9yIGFsbCBwYXRoIG1hbmFnZW1lbnQgZmVhdHVyZXMuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN0YXR1cz5QbGFubmVkPC9TdGF0dXM+CiAgICAgIDxQcmlvcml0eT4xPC9Qcmlvcml0eT4KICAgIDwvVGFzaz4KICA8VGFzayBuYW1lPSJVbml2ZXJzYWwgSW5zdGFsbGVyICZhbXA7IFJlbGVhc2UgQnVuZGxlciI+CiAgICAgIDxEZXNjcmlwdGlvbj5QYWNrYWdlciBtb2R1bGUgdGhhdCBidW5kbGVzIEVyYXNtdXMgYW5kIGRlcGVuZGVuY2llcyBpbnRvIGEgdW5pdmVyc2FsIGluc3RhbGxlciAoLnNoLy5weSkgd2l0aCB1diBhbmQgZXh0cmFjdGlvbiBsb2dpYy48L0Rlc2NyaXB0aW9uPgogICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICA8UHJpb3JpdHk+MTwvUHJpb3JpdHk+CiAgICA8L1Rhc2s+CiAgICA8VGFzayBuYW1lPSJDb21wcmVoZW5zaXZlIGRvY3N0cmluZ3MgYW5kIGNvbW1lbnRzIHRocm91Z2hvdXQgY29kZWJhc2UiPgogICAgICA8RGVzY3JpcHRpb24+RW5zdXJlIGFsbCBtb2R1bGVzLCBjbGFzc2VzLCBhbmQgZnVuY3Rpb25zIGFyZSBkb2N1bWVudGVkIHdpdGggY2xlYXIgZG9jc3RyaW5ncyBhbmQgaW5saW5lIGNvbW1lbnRzIGZvciBtYWludGFpbmFiaWxpdHkgYW5kIG9uYm9hcmRpbmcuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN0YXR1cz5JbiBQcm9ncmVzczwvU3RhdHVzPgogICAgICA8UHJpb3JpdHk+MTwvUHJpb3JpdHk+CiAgICA8L1Rhc2s+CiAgPC9DdXJyZW50VGFza3M+CiAgPE5leHRTdGVwcz4KICAgIDxTdGVwPkZvY3VzIG9uIGFkZGluZy9tYWludGFpbmluZyBjb21wcmVoZW5zaXZlIGRvY3N0cmluZ3MgYW5kIGNvbW1lbnRzIHRocm91Z2hvdXQgdGhlIGNvZGViYXNlLjwvU3RlcD4KICAgIDxTdGVwPk9uYm9hcmQgbmV3IHVzZXJzIGFuZCBjb250cmlidXRvcnMgd2l0aCB1cGRhdGVkIGRvY3VtZW50YXRpb24uPC9TdGVwPgogICAgPFN0ZXA+TWFpbnRhaW4gYW5kIHRlc3QgdGhlIHVuaXZlcnNhbCBpbnN0YWxsZXIgYW5kIHJlbGVhc2Ugd29ya2Zsb3cuPC9TdGVwPgogICAgPFN0ZXA+Q29udGludWUgaW1wcm92aW5nIHRlc3RpbmcgY292ZXJhZ2UgYW5kIG9uYm9hcmRpbmcgbWF0ZXJpYWxzLjwvU3RlcD4KICA8L05leHRTdGVwcz4KPC9UYXNrcz4='
    embedded['.erasmus/context/Erasmus_Documentation_-_Context_and_Protocol_Management_Library/ctx.architecture.xml'] = 'PEFyY2hpdGVjdHVyZT4gCiAgPFRpdGxlPkVyYXNtdXMgRG9jdW1lbnRhdGlvbiAtIENvbnRleHQgYW5kIFByb3RvY29sIE1hbmFnZW1lbnQgTGlicmFyeTwvVGl0bGU+CiAgPE92ZXJ2aWV3PgogICAgPFRpdGxlPkVyYXNtdXMgRG9jdW1lbnRhdGlvbiAtIENvbnRleHQgYW5kIFByb3RvY29sIE1hbmFnZW1lbnQgTGlicmFyeTwvVGl0bGU+CiAgICA8RGVzY3JpcHRpb24+RXJhc211cyBpcyBhIGNvbnRleHQgYW5kIHByb3RvY29sIG1hbmFnZW1lbnQgbGlicmFyeSB3aXRoIE1vZGVsIENvbnRleHQgUHJvdG9jb2wgKE1DUCkgaW50ZWdyYXRpb24uIEFzIG9mIHYwLjIuMCwgaXQgZmVhdHVyZXM6Ci0gQ29tcHJlaGVuc2l2ZSBwcm90b2NvbCBhbmQgY29udGV4dCBtYW5hZ2VtZW50IHdpdGggcmV1c2FibGUgdGVtcGxhdGVzCi0gSURFIGVudmlyb25tZW50IHNldHVwIGZvciBXaW5kc3VyZiwgQ3Vyc29yLCBDb2RleCwgYW5kIENsYXVkZQotIEEgcGFja2FnZXIgdGhhdCBidW5kbGVzIHRoZSBzeXN0ZW0gYW5kIGRlcGVuZGVuY2llcyBpbnRvIGEgdW5pdmVyc2FsIGluc3RhbGxlciAoYmFzaCArIHV2ICsgZXh0cmFjdGVkIFB5dGhvbikKLSBSZWxlYXNlIHdvcmtmbG93IHRoYXQgb3V0cHV0cyBib3RoIC5weSBhbmQgLnNoIGluc3RhbGxlcnMKLSBBbGwgY29yZSBtb2R1bGVzIGFuZCBDTEkgYXJlIGRvY3VtZW50ZWQgb3IgaW4gdGhlIHByb2Nlc3Mgb2YgYmVpbmcgZG9jdW1lbnRlZCB3aXRoIGRvY3N0cmluZ3MgYW5kIGNvbW1lbnRzCgpUaGlzIHByb3ZpZGVzIGEgcm9idXN0LCB0ZXN0YWJsZSwgYW5kIG1haW50YWluYWJsZSBzb2x1dGlvbiBmb3IgbW9kZXJuIGRldmVsb3BtZW50IGNvbnRleHQgYW5kIHByb3RvY29sIG1hbmFnZW1lbnQuIFRoZSBjb2RlYmFzZSBub3cgcmVxdWlyZXMgY29tcHJlaGVuc2l2ZSBkb2NzdHJpbmdzIGFuZCBjb21tZW50cyB0aHJvdWdob3V0IGZvciBtYWludGFpbmFiaWxpdHkgYW5kIG9uYm9hcmRpbmcuCjwvRGVzY3JpcHRpb24+CiAgPC9PdmVydmlldz4KICAKICA8Q29yZUNvbXBvbmVudHM+CiAgICA8Q29tcG9uZW50IG5hbWU9IlBhdGggTWFuYWdlbWVudCI+CiAgICAgIDxQdXJwb3NlPkNlbnRyYWxpemVkIHBhdGggbWFuYWdlbWVudCBmb3IgZGlmZmVyZW50IElERSBlbnZpcm9ubWVudHM8L1B1cnBvc2U+CiAgICAgIDxGZWF0dXJlcz4KICAgICAgICA8RmVhdHVyZT5JREUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkludGVyYWN0aXZlIElERSBzZWxlY3Rpb24gd2hlbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0PC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkNvbnNpc3RlbnQgcGF0aCBzdHJ1Y3R1cmUgYWNyb3NzIGRpZmZlcmVudCBJREVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkF1dG9tYXRpYyBkaXJlY3RvcnkgYW5kIGZpbGUgY3JlYXRpb248L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+U3ltbGluayBtYW5hZ2VtZW50IGZvciBjcm9zcy1JREUgY29tcGF0aWJpbGl0eTwvRmVhdHVyZT4KICAgICAgPC9GZWF0dXJlcz4KICAgICAgPEltcGxlbWVudGF0aW9uPgogICAgICAgIDxEZXRhaWw+UGF0aE1uZ3JNb2RlbCBmb3IgbWFuYWdpbmcgYWxsIHBhdGhzPC9EZXRhaWw+CiAgICAgICAgPERldGFpbD5JREUgZW51bSB3aXRoIG1ldGFkYXRhIGZvciBlYWNoIHN1cHBvcnRlZCBJREU8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkVudmlyb25tZW50IHZhcmlhYmxlIGRldGVjdGlvbiB3aXRoIGZhbGxiYWNrIHRvIHVzZXIgaW5wdXQ8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPlNpbmdsZXRvbiBwYXR0ZXJuIGZvciBnbG9iYWwgcGF0aCBhY2Nlc3M8L0RldGFpbD4KICAgICAgPC9JbXBsZW1lbnRhdGlvbj4KICAgICAgPFN1cHBvcnRlZElERXM+CiAgICAgICAgPElERT4KICAgICAgICAgIDxOYW1lPldpbmRzdXJmPC9OYW1lPgogICAgICAgICAgPFJ1bGVzRmlsZT4ud2luZHN1cmZydWxlczwvUnVsZXNGaWxlPgogICAgICAgICAgPEdsb2JhbFJ1bGVzUGF0aD5+Ly5jb2RlaXVtL3dpbmRzdXJmL21lbW9yaWVzL2dsb2JhbF9ydWxlcy5tZDwvR2xvYmFsUnVsZXNQYXRoPgogICAgICAgICAgPFN5bWxpbmtUb0N1cnNvcj50cnVlPC9TeW1saW5rVG9DdXJzb3I+CiAgICAgICAgPC9JREU+CiAgICAgICAgPElERT4KICAgICAgICAgIDxOYW1lPkN1cnNvcjwvTmFtZT4KICAgICAgICAgIDxSdWxlc0ZpbGU+LmN1cnNvcnJ1bGVzPC9SdWxlc0ZpbGU+CiAgICAgICAgICA8R2xvYmFsUnVsZXNQYXRoPn4vLmN1cnNvci9nbG9iYWxfcnVsZXMubWQ8L0dsb2JhbFJ1bGVzUGF0aD4KICAgICAgICAgIDxTeW1saW5rVG9DdXJzb3I+ZmFsc2U8L1N5bWxpbmtUb0N1cnNvcj4KICAgICAgICA8L0lERT4KICAgICAgICA8SURFPgogICAgICAgICAgPE5hbWU+Q29kZXg8L05hbWU+CiAgICAgICAgICA8UnVsZXNGaWxlPmNvZGV4Lm1kPC9SdWxlc0ZpbGU+CiAgICAgICAgICA8R2xvYmFsUnVsZXNQYXRoPn4vLmNvZGV4L2luc3RydWN0aW9ucy5tZDwvR2xvYmFsUnVsZXNQYXRoPgogICAgICAgICAgPFN5bWxpbmtUb0N1cnNvcj5mYWxzZTwvU3ltbGlua1RvQ3Vyc29yPgogICAgICAgIDwvSURFPgogICAgICAgIDxJREU+CiAgICAgICAgICA8TmFtZT5DbGF1ZGU8L05hbWU+CiAgICAgICAgICA8UnVsZXNGaWxlPkNMQVVERS5tZDwvUnVsZXNGaWxlPgogICAgICAgICAgPEdsb2JhbFJ1bGVzUGF0aD5+Ly5jbGF1ZGUvQ0xBVURFLm1kPC9HbG9iYWxSdWxlc1BhdGg+CiAgICAgICAgICA8U3ltbGlua1RvQ3Vyc29yPmZhbHNlPC9TeW1saW5rVG9DdXJzb3I+CiAgICAgICAgPC9JREU+CiAgICAgIDwvU3VwcG9ydGVkSURFcz4KICAgICAgPFRhc2tzPgogICAgICAgIDxUYXNrPkltcGxlbWVudCBQYXRoTW5nck1vZGVsIGZvciBjZW50cmFsaXplZCBwYXRoIG1hbmFnZW1lbnQ8L1Rhc2s+CiAgICAgICAgPFRhc2s+RGVmaW5lIElERSBlbnVtIHdpdGggbWV0YWRhdGEgZm9yIGVhY2ggSURFPC9UYXNrPgogICAgICAgIDxUYXNrPkltcGxlbWVudCBlbnZpcm9ubWVudCB2YXJpYWJsZSBkZXRlY3Rpb24gbG9naWM8L1Rhc2s+CiAgICAgICAgPFRhc2s+UHJvbXB0IHVzZXIgZm9yIElERSBzZWxlY3Rpb24gaWYgdmFyaWFibGUgbm90IHNldDwvVGFzaz4KICAgICAgICA8VGFzaz5FbnN1cmUgY29uc2lzdGVudCBkaXJlY3Rvcnkgc3RydWN0dXJlIGFuZCBhdXRvLWNyZWF0ZSBtaXNzaW5nIHBhdGhzPC9UYXNrPgogICAgICAgIDxUYXNrPkltcGxlbWVudCBzeW1saW5rIGxvZ2ljIGZvciBjcm9zcy1JREUgY29tcGF0aWJpbGl0eTwvVGFzaz4KICAgICAgICA8VGFzaz5Xcml0ZSB1bml0IHRlc3RzIGZvciBhbGwgcGF0aCBtYW5hZ2VtZW50IGxvZ2ljPC9UYXNrPgogICAgICA8L1Rhc2tzPgogICAgPC9Db21wb25lbnQ+CiAgICA8Q29tcG9uZW50IG5hbWU9IkVudmlyb25tZW50IE1hbmFnZW1lbnQiPgogICAgICA8UHVycG9zZT5HZW5lcmljLCB0eXBlLXNhZmUgZW52aXJvbm1lbnQgdmFyaWFibGUgbWFuYWdlbWVudDwvUHVycG9zZT4KICAgICAgPEZlYXR1cmVzPgogICAgICAgIDxGZWF0dXJlPkR5bmFtaWMgdmFyaWFibGUgZGVmaW5pdGlvbiAocmVxdWlyZWQvb3B0aW9uYWwpPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPlN0cm9uZyB0eXBlIHZhbGlkYXRpb248L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+VmFsdWUgY29uc3RyYWludHMgKG1pbi9tYXgsIHBhdHRlcm5zKTwvRmVhdHVyZT4KICAgICAgICA8RmVhdHVyZT5DdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnM8L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+RmlsZS1iYXNlZCBsb2FkaW5nICguZW52KTwvRmVhdHVyZT4KICAgICAgICA8RmVhdHVyZT5TeXN0ZW0gZW52aXJvbm1lbnQgbG9hZGluZzwvRmVhdHVyZT4KICAgICAgICA8RmVhdHVyZT5Db25maWd1cmF0aW9uIG1lcmdpbmc8L0ZlYXR1cmU+CiAgICAgIDwvRmVhdHVyZXM+CiAgICAgIDxJbXBsZW1lbnRhdGlvbj4KICAgICAgICA8RGV0YWlsPkVudmlyb25tZW50Q29uZmlnIGNsYXNzIGZvciBtYW5hZ2luZyB2YXJpYWJsZXM8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPlZhcmlhYmxlRGVmaW5pdGlvbiBmb3IgdHlwZSBhbmQgY29uc3RyYWludCBkZWZpbml0aW9uczwvRGV0YWlsPgogICAgICAgIDxEZXRhaWw+Q29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uIHN5c3RlbTwvRGV0YWlsPgogICAgICAgIDxEZXRhaWw+RXJyb3IgaGFuZGxpbmcgd2l0aCBwcm9wZXIgbG9nZ2luZzwvRGV0YWlsPgogICAgICA8L0ltcGxlbWVudGF0aW9uPgogICAgPC9Db21wb25lbnQ+CiAgICA8Q29tcG9uZW50IG5hbWU9IkZpbGUgTW9uaXRvciBTZXJ2aWNlIj4KICAgICAgPFB1cnBvc2U+TW9uaXRvcnMgY2hhbmdlcyBpbiBjdHguYXJjaGl0ZWN0dXJlLm1kLCBjdHgucHJvZ3Jlc3MubWQsIGFuZCBjdHgudGFza3MubWQgYW5kIGFwcGxpZXMgdGhlIGNoYW5nZXMgdG8gLndpbmRzdXJmcnVsZXMgYW5kL29yIC5jdXJzb3JydWxlcyBmaWxlczwvUHVycG9zZT4KICAgICAgPFJlc3BvbnNpYmlsaXRpZXM+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PldhdGNoIGZvciBjaGFuZ2VzIGluIGFyY2hpdGVjdHVyZSwgcHJvZ3Jlc3MsIGFuZCB0YXNrcyBmaWxlczwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PlVwZGF0ZSBydWxlcyBmaWxlIHdoZW4gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQ8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5NYWludGFpbiBmaWxlIHN5c3RlbSBldmVudCBsaXN0ZW5lcnM8L1Jlc3BvbnNpYmlsaXR5PgogICAgICA8L1Jlc3BvbnNpYmlsaXRpZXM+CiAgICAgIDxJbXBsZW1lbnRhdGlvbj4KICAgICAgICA8RGV0YWlsPlVzZXMgd2F0Y2hkb2cgZm9yIGZpbGUgc3lzdGVtIGV2ZW50czwvRGV0YWlsPgogICAgICAgIDxEZXRhaWw+RWZmaWNpZW50IGV2ZW50IGhhbmRsaW5nPC9EZXRhaWw+CiAgICAgICAgPERldGFpbD5Sb2J1c3QgZXJyb3IgcmVjb3Zlcnk8L0RldGFpbD4KICAgICAgPC9JbXBsZW1lbnRhdGlvbj4KICAgIDwvQ29tcG9uZW50PgogICAgPENvbXBvbmVudCBuYW1lPSJDb250ZXh0IE1hbmFnZXIiPgogICAgICA8UHVycG9zZT5NYW5hZ2VzIGRldmVsb3BtZW50IGNvbnRleHQgZmlsZXM8L1B1cnBvc2U+CiAgICAgIDxSZXNwb25zaWJpbGl0aWVzPgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5TYXZlL2xvYWQgY29udGV4dCBmaWxlcyB0by9mcm9tIC5lcmFzbXVzL2NvbnRleHQgZGlyZWN0b3J5PC9SZXNwb25zaWJpbGl0eT4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+UGFyc2UgYW5kIHNhbml0aXplIGRvY3VtZW50IG5hbWVzPC9SZXNwb25zaWJpbGl0eT4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+RW5zdXJlIEFTQ0lJLW9ubHkgY2hhcmFjdGVyczwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PkhhbmRsZSBmaWxlIG9wZXJhdGlvbnMgc2FmZWx5PC9SZXNwb25zaWJpbGl0eT4KICAgICAgPC9SZXNwb25zaWJpbGl0aWVzPgogICAgICA8SW1wbGVtZW50YXRpb24+CiAgICAgICAgPERldGFpbD5TYWZlIGZpbGUgb3BlcmF0aW9uczwvRGV0YWlsPgogICAgICAgIDxEZXRhaWw+Q29udGVudCBzYW5pdGl6YXRpb248L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkVycm9yIGhhbmRsaW5nPC9EZXRhaWw+CiAgICAgIDwvSW1wbGVtZW50YXRpb24+CiAgICA8L0NvbXBvbmVudD4KICAgIDxDb21wb25lbnQgbmFtZT0iUHJvdG9jb2wgSGFuZGxlciI+CiAgICAgIDxQdXJwb3NlPk1hbmFnZXMgcHJvdG9jb2wgZGVmaW5pdGlvbnM8L1B1cnBvc2U+CiAgICAgIDxSZXNwb25zaWJpbGl0aWVzPgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5BZGQgcHJvdG9jb2xzIHRvIGNvbnRleHQgb2JqZWN0czwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PlByZXNlcnZlIGV4aXN0aW5nIGNvbnRlbnQ8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5Mb2FkL3NhdmUgcHJvdG9jb2xzIGZyb20vdG8gLmVyYXNtdXMvcHJvdG9jb2wgZm9sZGVyPC9SZXNwb25zaWJpbGl0eT4KICAgICAgPC9SZXNwb25zaWJpbGl0aWVzPgogICAgICA8SW1wbGVtZW50YXRpb24+CiAgICAgICAgPERldGFpbD5Qcm90b2NvbCB2YWxpZGF0aW9uPC9EZXRhaWw+CiAgICAgICAgPERldGFpbD5Db250ZW50IHByZXNlcnZhdGlvbjwvRGV0YWlsPgogICAgICAgIDxEZXRhaWw+RmlsZSBvcGVyYXRpb25zPC9EZXRhaWw+CiAgICAgIDwvSW1wbGVtZW50YXRpb24+CiAgICA8L0NvbXBvbmVudD4KICAgIDxDb21wb25lbnQgbmFtZT0iTUNQIEludGVncmF0aW9uIj4KICAgICAgPFB1cnBvc2U+TW9kZWwgQ29udGV4dCBQcm90b2NvbCBtYW5hZ2VtZW50PC9QdXJwb3NlPgogICAgICA8U3ViQ29tcG9uZW50cz4KICAgICAgICA8U3ViQ29tcG9uZW50PgogICAgICAgICAgPE5hbWU+UmVnaXN0cnkgTWFuYWdlcjwvTmFtZT4KICAgICAgICAgIDxEZXRhaWw+TG9hZCBmcm9tIEpTT04gY29uZmlndXJhdGlvbjwvRGV0YWlsPgogICAgICAgICAgPERldGFpbD5TZXJ2ZXIgcmVnaXN0cmF0aW9uPC9EZXRhaWw+CiAgICAgICAgPC9TdWJDb21wb25lbnQ+CiAgICAgICAgPFN1YkNvbXBvbmVudD4KICAgICAgICAgIDxOYW1lPkNsaWVudCBJbXBsZW1lbnRhdGlvbjwvTmFtZT4KICAgICAgICAgIDxEZXRhaWw+UHl0aG9uIFNESyBpbnRlZ3JhdGlvbjwvRGV0YWlsPgogICAgICAgICAgPERldGFpbD5SZXF1ZXN0IGhhbmRsaW5nPC9EZXRhaWw+CiAgICAgICAgPC9TdWJDb21wb25lbnQ+CiAgICAgICAgPFN1YkNvbXBvbmVudD4KICAgICAgICAgIDxOYW1lPlNlcnZlciBJbXBsZW1lbnRhdGlvbjwvTmFtZT4KICAgICAgICAgIDxEZXRhaWw+Q0xJIG1pcnJvcmluZzwvRGV0YWlsPgogICAgICAgICAgPERldGFpbD5SZXF1ZXN0IHByb2Nlc3Npbmc8L0RldGFpbD4KICAgICAgICA8L1N1YkNvbXBvbmVudD4KICAgICAgPC9TdWJDb21wb25lbnRzPgogICAgPC9Db21wb25lbnQ+CiAgICA8Q29tcG9uZW50IG5hbWU9IkNMSSBJbnRlcmZhY2UiPgogICAgICA8UHVycG9zZT5Vc2VyIGludGVyYWN0aW9uIGxheWVyPC9QdXJwb3NlPgogICAgICA8UmVzcG9uc2liaWxpdGllcz4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+Q29udGV4dCBtYW5hZ2VtZW50PC9SZXNwb25zaWJpbGl0eT4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+UHJvdG9jb2wgbWFuYWdlbWVudDwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5Pk1DUCBzZXJ2ZXIgbWFuYWdlbWVudDwvUmVzcG9uc2liaWxpdHk+CiAgICAgIDwvUmVzcG9uc2liaWxpdGllcz4KICAgIDwvQ29tcG9uZW50PgogIDwvQ29yZUNvbXBvbmVudHM+CiAgCiAgPERldmVsb3BtZW50UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGUgbmFtZT0iVGVzdGluZyBTdHJhdGVneSI+CiAgICAgIDxEZXRhaWw+VW5pdCB0ZXN0cyBmb3IgZWFjaCBjb21wb25lbnQ8L0RldGFpbD4KICAgICAgPERldGFpbD5JbnRlZ3JhdGlvbiB0ZXN0cyBmb3IgY29tcG9uZW50IGludGVyYWN0aW9uPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+RW5kLXRvLWVuZCB0ZXN0cyBmb3IgQ0xJIG9wZXJhdGlvbnM8L0RldGFpbD4KICAgICAgPERldGFpbD5Nb2NrIGV4dGVybmFsIGRlcGVuZGVuY2llczwvRGV0YWlsPgogICAgICA8RGV0YWlsPlRlc3QgY292ZXJhZ2UgcmVxdWlyZW1lbnRzOiA4MCUgbWluaW11bTwvRGV0YWlsPgogICAgPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlIG5hbWU9IkNvZGUgUXVhbGl0eSI+CiAgICAgIDxEZXRhaWw+VHlwZSBoaW50cyB0aHJvdWdob3V0PC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+Q29tcHJlaGVuc2l2ZSBkb2N1bWVudGF0aW9uPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+RXJyb3IgaGFuZGxpbmcgd2l0aCBwcm9wZXIgbG9nZ2luZzwvRGV0YWlsPgogICAgICA8RGV0YWlsPkNsZWFuIGNvZGUgcHJpbmNpcGxlczwvRGV0YWlsPgogICAgICA8RGV0YWlsPktJU1MgKEtlZXAgSXQgU2ltcGxlLCBTdHVwaWQpIGFwcHJvYWNoPC9EZXRhaWw+CiAgICA8L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGUgbmFtZT0iQ29uZmlndXJhdGlvbiBNYW5hZ2VtZW50Ij4KICAgICAgPERldGFpbD5DZW50cmFsaXplZCBwYXRoIG1hbmFnZW1lbnQ8L0RldGFpbD4KICAgICAgPERldGFpbD5FbnZpcm9ubWVudCB2YXJpYWJsZSBoYW5kbGluZzwvRGV0YWlsPgogICAgICA8RGV0YWlsPk5vIGhhcmRjb2RlZCB2YWx1ZXM8L0RldGFpbD4KICAgICAgPERldGFpbD5Db25maWd1cmF0aW9uIHZhbGlkYXRpb248L0RldGFpbD4KICAgICAgPERldGFpbD5JREUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uPC9EZXRhaWw+CiAgICA8L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGUgbmFtZT0iRXJyb3IgSGFuZGxpbmciPgogICAgICA8RGV0YWlsPkdyYWNlZnVsIGRlZ3JhZGF0aW9uPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+RGV0YWlsZWQgZXJyb3IgbG9nZ2luZzwvRGV0YWlsPgogICAgICA8RGV0YWlsPlVzZXItZnJpZW5kbHkgZXJyb3IgbWVzc2FnZXM8L0RldGFpbD4KICAgICAgPERldGFpbD5SZWNvdmVyeSBtZWNoYW5pc21zPC9EZXRhaWw+CiAgICA8L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGUgbmFtZT0iRGF0YSBNb2RlbGluZyI+CiAgICAgIDxEZXRhaWw+VXNlIFB5ZGFudGljIG1vZGVscyBmb3Igc2VyaWFsaXphYmxlIGRhdGEgc3RydWN0dXJlczwvRGV0YWlsPgogICAgICA8RGV0YWlsPlVzZSBOYW1lZFR1cGxlIGZvciBzaW1wbGUsIGltbXV0YWJsZSBkYXRhIHN0cnVjdHVyZXM8L0RldGFpbD4KICAgICAgPERldGFpbD5Nb2Rlcm4gdHlwZSBoaW50cyAobG93ZXJjYXNlIGxpc3QsIGRpY3QsIHwgZm9yIHVuaW9uKTwvRGV0YWlsPgogICAgICA8RGV0YWlsPlR5cGUgc2FmZXR5IHRocm91Z2hvdXQgdGhlIGNvZGViYXNlPC9EZXRhaWw+CiAgICA8L1ByaW5jaXBsZT4KICA8L0RldmVsb3BtZW50UHJpbmNpcGxlcz4KICAKICA8RGVwZW5kZW5jaWVzPgogICAgPERlcGVuZGVuY3k+UHl0aG9uIDMuOCs8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5sb2d1cnU8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5tb2RlbGNvbnRleHRwcm90b2NvbC9weXRob24tc2RrIHwgbWNwW2NsaV08L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5weXRlc3QgKHRlc3RpbmcpPC9EZXBlbmRlbmN5PgogICAgPERlcGVuZGVuY3k+dHlwZXIgKENMSSk8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT53YXRjaGRvZyAoZmlsZSBtb25pdG9yaW5nKTwvRGVwZW5kZW5jeT4KICA8L0RlcGVuZGVuY2llcz4KICAKICA8RGlyZWN0b3J5U3RydWN0dXJlPgogICAgPERpcmVjdG9yeT4KICAgICAgPFBhdGg+ZXJhc211cy88L1BhdGg+CiAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgPFBhdGg+LmVyYXNtdXMvPC9QYXRoPgogICAgICAgIDxEZXNjcmlwdGlvbj5MaWJyYXJ5IHdvcmtpbmcgZmlsZXM8L0Rlc2NyaXB0aW9uPgogICAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgICA8UGF0aD5wcm90b2NvbC88L1BhdGg+CiAgICAgICAgICA8RGVzY3JpcHRpb24+UHJvdG9jb2wgZGVmaW5pdGlvbnM8L0Rlc2NyaXB0aW9uPgogICAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgICA8UGF0aD5jb250ZXh0LzwvUGF0aD4KICAgICAgICAgIDxEZXNjcmlwdGlvbj5Db250ZXh0IEZvbGRlcnM8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgICAgPFBhdGg+e2NvbnRleHRfbmFtZX0vPC9QYXRoPgogICAgICAgICAgICA8RGVzY3JpcHRpb24+TGFiZWxlZCBieSBuYW1lPC9EZXNjcmlwdGlvbj4KICAgICAgICAgICAgPEZpbGU+CiAgICAgICAgICAgICAgPE5hbWU+Y3R4LmFyY2hpdGVjdHVyZS5tZDwvTmFtZT4KICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+QXJjaGl0ZWN0dXJlIGRvYzwvRGVzY3JpcHRpb24+CiAgICAgICAgICAgIDwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+CiAgICAgICAgICAgICAgPE5hbWU+Y3R4LnByb2dyZXNzLm1kPC9OYW1lPgogICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Qcm9ncmVzcyBkb2M8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgICA8L0ZpbGU+CiAgICAgICAgICAgIDxGaWxlPgogICAgICAgICAgICAgIDxOYW1lPmN0eC50YXNrcy5tZDwvTmFtZT4KICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+VGFza3MgZG9jPC9EZXNjcmlwdGlvbj4KICAgICAgICAgICAgPC9GaWxlPgogICAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICA8U3ViRGlyZWN0b3J5PgogICAgICAgIDxQYXRoPnNyYy88L1BhdGg+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPm1vbml0b3IvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkZpbGUgbW9uaXRvcmluZzwvRGVzY3JpcHRpb24+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPmNvbnRleHQvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkNvbnRleHQgbWFuYWdlbWVudDwvRGVzY3JpcHRpb24+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPnByb3RvY29sLzwvUGF0aD4KICAgICAgICAgIDxEZXNjcmlwdGlvbj5Qcm90b2NvbCBoYW5kbGluZzwvRGVzY3JpcHRpb24+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPmxvZ2dpbmcvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkxvZ2dpbmcgc3lzdGVtPC9EZXNjcmlwdGlvbj4KICAgICAgICA8L1N1YkRpcmVjdG9yeT4KICAgICAgICA8U3ViRGlyZWN0b3J5PgogICAgICAgICAgPFBhdGg+bWNwLzwvUGF0aD4KICAgICAgICAgIDxEZXNjcmlwdGlvbj5NQ1AgaW50ZWdyYXRpb248L0Rlc2NyaXB0aW9uPgogICAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgICA8UGF0aD5jbGkvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkNvbW1hbmQgbGluZSBpbnRlcmZhY2U8L0Rlc2NyaXB0aW9uPgogICAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICA8L1N1YkRpcmVjdG9yeT4KICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICA8UGF0aD50ZXN0cy88L1BhdGg+CiAgICAgICAgPERlc2NyaXB0aW9uPlRlc3Qgc3VpdGU8L0Rlc2NyaXB0aW9uPgogICAgICA8L1N1YkRpcmVjdG9yeT4KICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICA8UGF0aD5jb25maWcvPC9QYXRoPgogICAgICAgIDxEZXNjcmlwdGlvbj5Db25maWd1cmF0aW9uIGZpbGVzPC9EZXNjcmlwdGlvbj4KICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgIDxGaWxlPgogICAgICAgIDxOYW1lPi5jdXJzb3JydWxlcyB8IC53aW5kc3VyZnJ1bGVzPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5SdWxlcyBmaWxlIGFuZCBpbmplY3RlZCBjb250ZXh0PC9EZXNjcmlwdGlvbj4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LmFyY2hpdGVjdHVyZS54bWw8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPk1vbml0b3JlZCBkZXNpZ24gZG9jPC9EZXNjcmlwdGlvbj4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LnByb2dyZXNzLnhtbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TW9uaXRvcmVkIGRldmVsb3BtZW50IHNjaGVkdWxlPC9EZXNjcmlwdGlvbj4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LnRhc2tzLnhtbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TW9uaXRvcmVkIHRhc2sgbGlzdDwvRGVzY3JpcHRpb24+CiAgICAgIDwvRmlsZT4KICAgIDwvRGlyZWN0b3J5PgogIDwvRGlyZWN0b3J5U3RydWN0dXJlPgogIAogIDxEZXZlbG9wbWVudFdvcmtmbG93PgogICAgPFN0ZXA+Q29tcG9uZW50IHNlbGVjdGlvbiBmcm9tIFBST0dSRVNTLm1kPC9TdGVwPgogICAgPFN0ZXA+VGFzayBicmVha2Rvd24gaW4gVEFTS1MubWQ8L1N0ZXA+CiAgICA8U3RlcD5UZXN0LWRyaXZlbiBkZXZlbG9wbWVudDwvU3RlcD4KICAgIDxTdGVwPkNvZGUgcmV2aWV3PC9TdGVwPgogICAgPFN0ZXA+SW50ZWdyYXRpb24gdGVzdGluZzwvU3RlcD4KICAgIDxTdGVwPkRvY3VtZW50YXRpb24gdXBkYXRlPC9TdGVwPgogIDwvRGV2ZWxvcG1lbnRXb3JrZmxvdz4KPC9BcmNoaXRlY3R1cmU+Cg=='
    embedded['.erasmus/context/.gitkeep'] = ''
    embedded['.erasmus/context/Erasmus_-_Context_Management_and_Protocol_Handling/ctx.progress.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFByb2dyZXNzPiAKICA8UGhhc2U+IAogICAgPE5hbWU+UGhhc2UgMTogQ29yZSBJbmZyYXN0cnVjdHVyZTwvTmFtZT4KICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICA8VGFza3M+CiAgICAgIDxUYXNrPgogICAgICAgIDxOYW1lPlByb2plY3Qgc2NhZmZvbGRpbmc8L05hbWU+CiAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgPC9UYXNrPiAKICAgICAgPFRhc2s+CiAgICAgICAgPE5hbWU+RW52aXJvbm1lbnQgYW5kIFBhdGggTWFuYWdlbWVudDwvTmFtZT4KICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPiAgCiAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkNvbXBsZXRlIGVudmlyb25tZW50LnB5IGltcGxlbWVudGF0aW9uPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkNvbXBsZXRlIHBhdGhzLnB5IGltcGxlbWVudGF0aW9uPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkFkZCBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWxpZGF0aW9uPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkFkZCBwYXRoIHZhbGlkYXRpb24gYW5kIHNhbml0aXphdGlvbjwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5Vbml0IHRlc3RzIGZvciBlbnZpcm9ubWVudCBtYW5hZ2VtZW50PC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5Vbml0IHRlc3RzIGZvciBwYXRoIG1hbmFnZW1lbnQ8L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+UGVuZGluZzwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDwvU3VidGFza3M+CiAgICAgIDwvVGFzaz4KICAgIDwvVGFza3M+CiAgPC9QaGFzZT4KICA8UGhhc2U+CiAgICA8TmFtZT5QaGFzZSAyOiBDb250ZXh0IE1hbmFnZW1lbnQ8L05hbWU+CiAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgPFRhc2tzPgogICAgICA8VGFzaz4KICAgICAgICA8TmFtZT5GaWxlIE1vbml0b3IgU2VydmljZTwvTmFtZT4KICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgIDxTdWJ0YXNrcz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5Db21wbGV0ZSBmaWxlX21vbml0b3IucHkgaW1wbGVtZW50YXRpb248L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+QWRkIGZpbGUgd2F0Y2hpbmcgZnVuY3Rpb25hbGl0eTwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5JbXBsZW1lbnQgZXZlbnQgaGFuZGxpbmc8L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+QWRkIGRlYm91bmNpbmc8L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+VW5pdCB0ZXN0cyBmb3IgZmlsZSBtb25pdG9yaW5nPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5JbnRlZ3JhdGlvbiB0ZXN0cyBmb3IgZmlsZSBvcGVyYXRpb25zPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5SZWZhY3RvciBmaWxlIG1vbml0b3IgdG8gdXNlIHRlbXBsYXRlL21lcmdlIHBhdHRlcm4gZm9yIHJ1bGVzIGZpbGUgdXBkYXRlcyAobWFudWFsX3VwZGF0ZS5weSBsb2dpYyk8L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPC9UYXNrPgogICAgICA8VGFzaz4KICAgICAgICA8TmFtZT5Db250ZXh0IFN5c3RlbTwvTmFtZT4KICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgIDxTdWJ0YXNrcz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5Db21wbGV0ZSBjb250ZXh0LnB5IGltcGxlbWVudGF0aW9uPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkltcGxlbWVudCBjb250ZXh0IGZpbGUgcGFyc2luZzwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5BZGQgQVNDSUkgc2FuaXRpemF0aW9uPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPlVuaXQgdGVzdHMgZm9yIGNvbnRleHQgbWFuYWdlbWVudDwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+SW50ZWdyYXRpb24gdGVzdHMgZm9yIGZpbGUgb3BlcmF0aW9uczwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPC9UYXNrPgogICAgPC9UYXNrcz4KICA8L1BoYXNlPgogIDxQaGFzZT4KICAgIDxOYW1lPlBoYXNlIDM6IFByb3RvY29sIFN5c3RlbTwvTmFtZT4KICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICA8VGFza3M+CiAgICAgIDxUYXNrPgogICAgICAgIDxOYW1lPlByb3RvY29sIEhhbmRsZXI8L05hbWU+CiAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+Q29tcGxldGUgcHJvdG9jb2xzLnB5IGltcGxlbWVudGF0aW9uPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkFkZCBwcm90b2NvbCB2YWxpZGF0aW9uPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkltcGxlbWVudCBwcm90b2NvbCBzdG9yYWdlPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkFkZCBwcm90b2NvbCB2ZXJzaW9uaW5nPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPlVuaXQgdGVzdHMgZm9yIHByb3RvY29sIG1hbmFnZW1lbnQ8L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+UGVuZGluZzwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkludGVncmF0aW9uIHRlc3RzIGZvciBwcm90b2NvbCBvcGVyYXRpb25zPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8L1N1YnRhc2tzPgogICAgICA8L1Rhc2s+CiAgICA8L1Rhc2tzPgogIDwvUGhhc2U+CiAgPFBoYXNlPgogICAgPE5hbWU+UGhhc2UgNDogTUNQIEludGVncmF0aW9uPC9OYW1lPgogICAgPFN0YXR1cz5JbiBQcm9ncmVzczwvU3RhdHVzPgogICAgPFRhc2tzPgogICAgICA8VGFzaz4KICAgICAgICA8TmFtZT5NQ1AgQ29yZTwvTmFtZT4KICAgICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkNvbXBsZXRlIG1jcC5weSBpbXBsZW1lbnRhdGlvbjwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5BZGQgcmVnaXN0cnkgbWFuYWdlbWVudDwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5JbXBsZW1lbnQgY2xpZW50IGZ1bmN0aW9uYWxpdHk8L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+QWRkIHNlcnZlciBpbXBsZW1lbnRhdGlvbjwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5Vbml0IHRlc3RzIGZvciBNQ1Agb3BlcmF0aW9uczwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+SW50ZWdyYXRpb24gdGVzdHMgZm9yIGNsaWVudC1zZXJ2ZXIgY29tbXVuaWNhdGlvbjwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPC9UYXNrPgogICAgPC9UYXNrcz4KICA8L1BoYXNlPgogIDxQaGFzZT4KICAgIDxOYW1lPlBoYXNlIDU6IENMSSBhbmQgTG9nZ2luZzwvTmFtZT4KICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgIDxUYXNrcz4KICAgICAgPFRhc2s+CiAgICAgICAgPE5hbWU+Q29tbWFuZCBMaW5lIEludGVyZmFjZTwvTmFtZT4KICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgIDxTdWJ0YXNrcz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5Db21wbGV0ZSBjbGkucHkgaW1wbGVtZW50YXRpb248L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+QWRkIGNvbW1hbmQgcGFyc2luZzwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5JbXBsZW1lbnQgdXNlciBpbnRlcmFjdGlvbjwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5Vbml0IHRlc3RzIGZvciBDTEk8L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+UGVuZGluZzwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDwvU3VidGFza3M+CiAgICAgIDwvVGFzaz4KICAgICAgPFRhc2s+CiAgICAgICAgPE5hbWU+TG9nZ2luZyBhbmQgRXJyb3IgSGFuZGxpbmc8L05hbWU+CiAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+SW1wbGVtZW50IGxvZ2dpbmcgd2l0aCBsb2d1cnU8L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+QWRkIGVycm9yIGhhbmRsaW5nIHRvIENMSSBtb2R1bGVzPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPlN0YW5kYXJkaXplIGVycm9yIHJlcG9ydGluZyB3aXRoIHByaW50X3RhYmxlPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDwvU3VidGFza3M+CiAgICAgIDwvVGFzaz4KICAgIDwvVGFza3M+CiAgPC9QaGFzZT4KICA8UGhhc2U+CiAgICA8TmFtZT5QaGFzZSA2OiBUZXN0aW5nIGFuZCBEb2N1bWVudGF0aW9uPC9OYW1lPgogICAgPFN0YXR1cz5JbiBQcm9ncmVzczwvU3RhdHVzPgogICAgPFRhc2tzPgogICAgICA8VGFzaz4KICAgICAgICA8TmFtZT5UZXN0aW5nIEluZnJhc3RydWN0dXJlPC9OYW1lPgogICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+U2V0IHVwIHB5dGVzdCBjb25maWd1cmF0aW9uPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkFkZCB0ZXN0IGZpeHR1cmVzPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkltcGxlbWVudCB0ZXN0IHV0aWxpdGllczwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5BZGQgY292ZXJhZ2UgcmVwb3J0aW5nPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPlNldCB1cCBDSSBwaXBlbGluZTwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPC9UYXNrPgogICAgICA8VGFzaz4KICAgICAgICA8TmFtZT5Eb2N1bWVudGF0aW9uPC9OYW1lPgogICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+QWRkIEFQSSBkb2N1bWVudGF0aW9uPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5DcmVhdGUgdXNlciBndWlkZTwvTmFtZT4KICAgICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgPE5hbWU+QWRkIGRldmVsb3BtZW50IGd1aWRlPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5DcmVhdGUgY29udHJpYnV0aW9uIGd1aWRlPC9OYW1lPgogICAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICA8TmFtZT5BZGQgZXhhbXBsZXM8L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+UGVuZGluZzwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDwvU3VidGFza3M+CiAgICAgIDwvVGFzaz4KICAgICAgPFRhc2s+CiAgICAgICAgPE5hbWU+U3R5bGUgRW5mb3JjZW1lbnQ8L05hbWU+CiAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgIDxOYW1lPkFkZCBhdXRvbWF0ZWQgbGludGluZyAoZS5nLiwgZmxha2U4LCBibGFjayk8L05hbWU+CiAgICAgICAgICAgIDxTdGF0dXM+UGVuZGluZzwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDwvU3VidGFza3M+CiAgICAgIDwvVGFzaz4KICAgIDwvVGFza3M+CiAgPC9QaGFzZT4KICA8Q3VycmVudEZvY3VzPgogICAgPFBoYXNlPlBoYXNlIDQ6IE1DUCBJbnRlZ3JhdGlvbjwvUGhhc2U+CiAgICA8UHJpb3JpdHk+TUNQIENvcmU8L1ByaW9yaXR5PgogICAgPE5leHRUYXNrPkNvbXBsZXRlIG1jcC5weSBpbXBsZW1lbnRhdGlvbjwvTmV4dFRhc2s+CiAgPC9DdXJyZW50Rm9jdXM+CiAgPE5vdGVzPgogICAgPE5vdGU+RWFjaCBjb21wb25lbnQgc2hvdWxkIGJlIGRldmVsb3BlZCBmb2xsb3dpbmcgVEREIHByaW5jaXBsZXM8L05vdGU+CiAgICA8Tm90ZT5BbGwgY29kZSBjaGFuZ2VzIG11c3QgaW5jbHVkZSBjb3JyZXNwb25kaW5nIHRlc3RzPC9Ob3RlPgogICAgPE5vdGU+RG9jdW1lbnRhdGlvbiBzaG91bGQgYmUgdXBkYXRlZCBhcyBmZWF0dXJlcyBhcmUgY29tcGxldGVkPC9Ob3RlPgogICAgPE5vdGU+SW50ZWdyYXRpb24gdGVzdHMgc2hvdWxkIGJlIGFkZGVkIGFmdGVyIHVuaXQgdGVzdHMgcGFzczwvTm90ZT4KICAgIDxOb3RlPkZpbGUgbW9uaXRvciByZWZhY3RvciB0byB1c2UgdGVtcGxhdGUvbWVyZ2UgcGF0dGVybiBpcyBhIHByaW9yaXR5IGZvciBuZXh0IGl0ZXJhdGlvbjwvTm90ZT4KICAgIDxOb3RlPkNJIHBpcGVsaW5lIGFuZCBzdHlsZSBlbmZvcmNlbWVudCBhcmUgaW1wb3J0YW50IGZvciBwcm9qZWN0IG1hdHVyaXR5PC9Ob3RlPgogIDwvTm90ZXM+CiAgPE5vdGU+QWxsIGNvcmUgZmVhdHVyZXMgYXJlIHdvcmtpbmcuIE5leHQgcHJpb3JpdHk6IHVwZGF0ZSBhbmQgZXhwYW5kIHRlc3RzIGZvciBhbGwgbW9kdWxlcy48L05vdGU+CjwvUHJvZ3Jlc3M+IA=='
    embedded['.erasmus/context/Erasmus_-_Context_Management_and_Protocol_Handling/ctx.tasks.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFRhc2tzPgogIDxDdXJyZW50VGFza3M+CiAgICA8VGFzaz4gCiAgICAgIDxOYW1lPkVudmlyb25tZW50IGFuZCBQYXRoIE1hbmFnZW1lbnQ8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5JbXBsZW1lbnQgZW52aXJvbm1lbnQgdmFyaWFibGUgbWFuYWdlbWVudCB3aXRoIHZhbGlkYXRpb24gYW5kIHR5cGUgc2FmZXR5LjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdWJ0YXNrcz4KICAgICAgICA8U3VidGFzaz4KICAgICAgICAgIDxOYW1lPkNyZWF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBzY2hlbWE8L05hbWU+CiAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgICA8TmFtZT5EZWZpbmUgcmVxdWlyZWQgdmFyaWFibGVzPC9OYW1lPgogICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgICAgPE5hbWU+RGVmaW5lIG9wdGlvbmFsIHZhcmlhYmxlczwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPkRlZmluZSB2YXJpYWJsZSB0eXBlcyBhbmQgY29uc3RyYWludHM8L05hbWU+CiAgICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICA8TmFtZT5JbXBsZW1lbnQgZW52aXJvbm1lbnQgbG9hZGluZzwvTmFtZT4KICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPkxvYWQgZnJvbSAuZW52IGZpbGU8L05hbWU+CiAgICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgICA8TmFtZT5Mb2FkIGZyb20gc3lzdGVtIGVudmlyb25tZW50PC9OYW1lPgogICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgICAgPE5hbWU+SGFuZGxlIG1pc3NpbmcgdmFyaWFibGVzPC9OYW1lPgogICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgICAgPE5hbWU+VmFsaWRhdGUgdmFyaWFibGUgdHlwZXM8L05hbWU+CiAgICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICA8TmFtZT5BZGQgZW52aXJvbm1lbnQgdmFsaWRhdGlvbjwvTmFtZT4KICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPlR5cGUgY2hlY2tpbmc8L05hbWU+CiAgICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgICA8TmFtZT5SZXF1aXJlZCBmaWVsZCB2YWxpZGF0aW9uPC9OYW1lPgogICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgICAgPE5hbWU+Rm9ybWF0IHZhbGlkYXRpb248L05hbWU+CiAgICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgICA8TmFtZT5WYWx1ZSByYW5nZSB2YWxpZGF0aW9uPC9OYW1lPgogICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDwvU3VidGFza3M+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICA8L1N1YnRhc2tzPgogICAgICA8VGVzdHM+CiAgICAgICAgPFRlc3Q+CiAgICAgICAgICA8TmFtZT5UZXN0IGVudmlyb25tZW50IGxvYWRpbmc8L05hbWU+CiAgICAgICAgICA8Q29kZT4KICAgICAgICAgICAgPCFbQ0RBVEFbCiAgICAgICAgICAgIGRlZiB0ZXN0X2xvYWRfZW52aXJvbm1lbnQoKToKICAgICAgICAgICAgICAgICMgVGVzdCBsb2FkaW5nIGZyb20gLmVudgogICAgICAgICAgICAgICAgIyBUZXN0IGxvYWRpbmcgZnJvbSBzeXN0ZW0KICAgICAgICAgICAgICAgICMgVGVzdCBtaXNzaW5nIHZhcmlhYmxlcwogICAgICAgICAgICAgICAgIyBUZXN0IGludmFsaWQgdHlwZXMKICAgICAgICAgICAgXV0+CiAgICAgICAgICA8L0NvZGU+CiAgICAgICAgPC9UZXN0PgogICAgICAgIDxUZXN0PgogICAgICAgICAgPE5hbWU+VGVzdCBlbnZpcm9ubWVudCB2YWxpZGF0aW9uPC9OYW1lPgogICAgICAgICAgPENvZGU+CiAgICAgICAgICAgIDwhW0NEQVRBWwogICAgICAgICAgICBkZWYgdGVzdF92YWxpZGF0ZV9lbnZpcm9ubWVudCgpOgogICAgICAgICAgICAgICAgIyBUZXN0IHR5cGUgdmFsaWRhdGlvbgogICAgICAgICAgICAgICAgIyBUZXN0IHJlcXVpcmVkIGZpZWxkcwogICAgICAgICAgICAgICAgIyBUZXN0IGZvcm1hdCB2YWxpZGF0aW9uCiAgICAgICAgICAgICAgICAjIFRlc3QgdmFsdWUgcmFuZ2VzCiAgICAgICAgICAgIF1dPgogICAgICAgICAgPC9Db2RlPgogICAgICAgIDwvVGVzdD4KICAgICAgPC9UZXN0cz4KICAgIDwvVGFzaz4KICAgIDxUYXNrPgogICAgICA8TmFtZT5QYXRoIE1hbmFnZW1lbnQ8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5JbXBsZW1lbnQgY2VudHJhbGl6ZWQgcGF0aCBtYW5hZ2VtZW50IHdpdGggdmFsaWRhdGlvbiBhbmQgc2FuaXRpemF0aW9uLjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdWJ0YXNrcz4KICAgICAgICA8U3VidGFzaz4KICAgICAgICAgIDxOYW1lPkNyZWF0ZSBwYXRoIGNvbmZpZ3VyYXRpb248L05hbWU+CiAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgICA8TmFtZT5EZWZpbmUgYmFzZSBwYXRoczwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPkRlZmluZSByZWxhdGl2ZSBwYXRoczwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPkRlZmluZSBwYXRoIHRlbXBsYXRlczwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8L1N1YnRhc2tzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzaz4KICAgICAgICAgIDxOYW1lPkltcGxlbWVudCBwYXRoIHJlc29sdXRpb248L05hbWU+CiAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgICA8TmFtZT5SZXNvbHZlIGFic29sdXRlIHBhdGhzPC9OYW1lPgogICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgICAgPE5hbWU+UmVzb2x2ZSByZWxhdGl2ZSBwYXRoczwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPkhhbmRsZSBwYXRoIHRlbXBsYXRlczwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPkhhbmRsZSBwYXRoIHZhcmlhYmxlczwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8L1N1YnRhc2tzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzaz4KICAgICAgICAgIDxOYW1lPkFkZCBwYXRoIHZhbGlkYXRpb248L05hbWU+CiAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgICA8U3VidGFzaz4KICAgICAgICAgICAgICA8TmFtZT5QYXRoIGV4aXN0ZW5jZSBjaGVjazwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPlBhdGggcGVybWlzc2lvbiBjaGVjazwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPlBhdGggc2FuaXRpemF0aW9uPC9OYW1lPgogICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgICAgPE5hbWU+UGF0aCBub3JtYWxpemF0aW9uPC9OYW1lPgogICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDwvU3VidGFza3M+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICA8L1N1YnRhc2tzPgogICAgICA8VGVzdHM+CiAgICAgICAgPFRlc3Q+CiAgICAgICAgICA8TmFtZT5UZXN0IHBhdGggcmVzb2x1dGlvbjwvTmFtZT4KICAgICAgICAgIDxDb2RlPgogICAgICAgICAgICA8IVtDREFUQVsKICAgICAgICAgICAgZGVmIHRlc3RfcmVzb2x2ZV9wYXRocygpOgogICAgICAgICAgICAgICAgIyBUZXN0IGFic29sdXRlIHBhdGhzCiAgICAgICAgICAgICAgICAjIFRlc3QgcmVsYXRpdmUgcGF0aHMKICAgICAgICAgICAgICAgICMgVGVzdCBwYXRoIHRlbXBsYXRlcwogICAgICAgICAgICAgICAgIyBUZXN0IHBhdGggdmFyaWFibGVzCiAgICAgICAgICAgIF1dPgogICAgICAgICAgPC9Db2RlPgogICAgICAgIDwvVGVzdD4KICAgICAgICA8VGVzdD4KICAgICAgICAgIDxOYW1lPlRlc3QgcGF0aCB2YWxpZGF0aW9uPC9OYW1lPgogICAgICAgICAgPENvZGU+CiAgICAgICAgICAgIDwhW0NEQVRBWwogICAgICAgICAgICBkZWYgdGVzdF92YWxpZGF0ZV9wYXRocygpOgogICAgICAgICAgICAgICAgIyBUZXN0IHBhdGggZXhpc3RlbmNlCiAgICAgICAgICAgICAgICAjIFRlc3QgcGVybWlzc2lvbnMKICAgICAgICAgICAgICAgICMgVGVzdCBzYW5pdGl6YXRpb24KICAgICAgICAgICAgICAgICMgVGVzdCBub3JtYWxpemF0aW9uCiAgICAgICAgICAgIF1dPgogICAgICAgICAgPC9Db2RlPgogICAgICAgIDwvVGVzdD4KICAgICAgPC9UZXN0cz4KICAgIDwvVGFzaz4KICAgIDxUYXNrPgogICAgICA8TmFtZT5FcnJvciBIYW5kbGluZzwvTmFtZT4KICAgICAgPERlc2NyaXB0aW9uPkltcGxlbWVudCByb2J1c3QgZXJyb3IgaGFuZGxpbmcgZm9yIGVudmlyb25tZW50IGFuZCBwYXRoIG9wZXJhdGlvbnMuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN1YnRhc2tzPgogICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgPE5hbWU+RGVmaW5lIGVycm9yIHR5cGVzPC9OYW1lPgogICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDxTdWJ0YXNrcz4KICAgICAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICAgICAgPE5hbWU+RGVmaW5lIGVudmlyb25tZW50IGVycm9yczwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPkRlZmluZSBwYXRoIGVycm9yczwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgICAgIDxOYW1lPkRlZmluZSB2YWxpZGF0aW9uIGVycm9yczwvTmFtZT4KICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8L1N1YnRhc2tzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzaz4KICAgICAgICAgIDxOYW1lPkltcGxlbWVudCBlcnJvciBoYW5kbGluZyBsb2dpYzwvTmFtZT4KICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgPE5hbWU+SW50ZWdyYXRlIGVycm9yIGhhbmRsaW5nIGludG8gQ0xJPC9OYW1lPgogICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgIDwvU3VidGFza3M+CiAgICA8L1Rhc2s+CiAgICA8VGFzaz4KICAgICAgPE5hbWU+Q29udGV4dCBNYW5hZ2VtZW50PC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+SW1wbGVtZW50IGNvbnRleHQgZmlsZSBtYW5hZ2VtZW50IGFuZCBvcGVyYXRpb25zLjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdWJ0YXNrcz4KICAgICAgICA8U3VidGFzaz4KICAgICAgICAgIDxOYW1lPkltcGxlbWVudCBjb250ZXh0LnB5PC9OYW1lPgogICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICA8TmFtZT5JbXBsZW1lbnQgY29udGV4dCBmaWxlIHBhcnNpbmc8L05hbWU+CiAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzaz4KICAgICAgICAgIDxOYW1lPkFkZCBBU0NJSSBzYW5pdGl6YXRpb248L05hbWU+CiAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPFRlc3RzPgogICAgICAgIDxUZXN0PgogICAgICAgICAgPE5hbWU+VGVzdCBjb250ZXh0IGZpbGUgb3BlcmF0aW9uczwvTmFtZT4KICAgICAgICAgIDxDb2RlPgogICAgICAgICAgICA8IVtDREFUQVsKICAgICAgICAgICAgZGVmIHRlc3RfY29udGV4dF9maWxlX29wcygpOgogICAgICAgICAgICAgICAgIyBUZXN0IGNvbnRleHQgY3JlYXRpb24KICAgICAgICAgICAgICAgICMgVGVzdCBjb250ZXh0IGxvYWRpbmcKICAgICAgICAgICAgICAgICMgVGVzdCBjb250ZXh0IGVkaXRpbmcKICAgICAgICAgICAgXV0+CiAgICAgICAgICA8L0NvZGU+CiAgICAgICAgPC9UZXN0PgogICAgICA8L1Rlc3RzPgogICAgPC9UYXNrPgogICAgPFRhc2s+CiAgICAgIDxOYW1lPlByb3RvY29sIE1hbmFnZW1lbnQ8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5JbXBsZW1lbnQgcHJvdG9jb2wgZmlsZSBtYW5hZ2VtZW50IGFuZCBvcGVyYXRpb25zLjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdWJ0YXNrcz4KICAgICAgICA8U3VidGFzaz4KICAgICAgICAgIDxOYW1lPkltcGxlbWVudCBwcm90b2NvbHMucHk8L05hbWU+CiAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzaz4KICAgICAgICAgIDxOYW1lPkFkZCBwcm90b2NvbCB2YWxpZGF0aW9uPC9OYW1lPgogICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICA8TmFtZT5JbXBsZW1lbnQgcHJvdG9jb2wgc3RvcmFnZTwvTmFtZT4KICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgPE5hbWU+QWRkIHByb3RvY29sIHZlcnNpb25pbmc8L05hbWU+CiAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPFRlc3RzPgogICAgICAgIDxUZXN0PgogICAgICAgICAgPE5hbWU+VGVzdCBwcm90b2NvbCBmaWxlIG9wZXJhdGlvbnM8L05hbWU+CiAgICAgICAgICA8Q29kZT4KICAgICAgICAgICAgPCFbQ0RBVEFbCiAgICAgICAgICAgIGRlZiB0ZXN0X3Byb3RvY29sX2ZpbGVfb3BzKCk6CiAgICAgICAgICAgICAgICAjIFRlc3QgcHJvdG9jb2wgY3JlYXRpb24KICAgICAgICAgICAgICAgICMgVGVzdCBwcm90b2NvbCBsb2FkaW5nCiAgICAgICAgICAgICAgICAjIFRlc3QgcHJvdG9jb2wgZWRpdGluZwogICAgICAgICAgICBdXT4KICAgICAgICAgIDwvQ29kZT4KICAgICAgICA8L1Rlc3Q+CiAgICAgIDwvVGVzdHM+CiAgICA8L1Rhc2s+CiAgICA8VGFzaz4KICAgICAgPE5hbWU+RmlsZSBNb25pdG9yIFNlcnZpY2U8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5JbXBsZW1lbnQgZmlsZSBtb25pdG9yaW5nIGFuZCBydWxlcyBmaWxlIG1lcmdpbmcuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN1YnRhc2tzPgogICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgPE5hbWU+SW1wbGVtZW50IGZpbGVfbW9uaXRvci5weTwvTmFtZT4KICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgPE5hbWU+QWRkIGZpbGUgd2F0Y2hpbmcgZnVuY3Rpb25hbGl0eTwvTmFtZT4KICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgPE5hbWU+SW1wbGVtZW50IGV2ZW50IGhhbmRsaW5nPC9OYW1lPgogICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICA8TmFtZT5BZGQgZGVib3VuY2luZzwvTmFtZT4KICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgPE5hbWU+UmVmYWN0b3IgdG8gdXNlIHRlbXBsYXRlL21lcmdlIHBhdHRlcm4gZm9yIHJ1bGVzIGZpbGUgdXBkYXRlczwvTmFtZT4KICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICA8L1N1YnRhc2tzPgogICAgICA8VGVzdHM+CiAgICAgICAgPFRlc3Q+CiAgICAgICAgICA8TmFtZT5UZXN0IGZpbGUgbW9uaXRvcmluZzwvTmFtZT4KICAgICAgICAgIDxDb2RlPgogICAgICAgICAgICA8IVtDREFUQVsKICAgICAgICAgICAgZGVmIHRlc3RfZmlsZV9tb25pdG9yaW5nKCk6CiAgICAgICAgICAgICAgICAjIFRlc3QgZmlsZSBjaGFuZ2UgZGV0ZWN0aW9uCiAgICAgICAgICAgICAgICAjIFRlc3QgcnVsZXMgZmlsZSBtZXJnaW5nCiAgICAgICAgICAgIF1dPgogICAgICAgICAgPC9Db2RlPgogICAgICAgIDwvVGVzdD4KICAgICAgPC9UZXN0cz4KICAgIDwvVGFzaz4KICAgIDxUYXNrPgogICAgICA8TmFtZT5TZXR1cCBhbmQgQ0xJPC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+SW1wbGVtZW50IHNldHVwIHdvcmtmbG93IGFuZCBDTEkgY29tbWFuZHMuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN1YnRhc2tzPgogICAgICAgIDxTdWJ0YXNrPgogICAgICAgICAgPE5hbWU+SW1wbGVtZW50IHNldHVwX2NvbW1hbmRzLnB5PC9OYW1lPgogICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICA8TmFtZT5JbXBsZW1lbnQgQ0xJIGNvbW1hbmRzPC9OYW1lPgogICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2s+CiAgICAgICAgICA8TmFtZT5JbXBsZW1lbnQgdXNlciBpbnRlcmFjdGlvbjwvTmFtZT4KICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICA8L1N1YnRhc2tzPgogICAgICA8VGVzdHM+CiAgICAgICAgPFRlc3Q+CiAgICAgICAgICA8TmFtZT5UZXN0IENMSSBvcGVyYXRpb25zPC9OYW1lPgogICAgICAgICAgPENvZGU+CiAgICAgICAgICAgIDwhW0NEQVRBWwogICAgICAgICAgICBkZWYgdGVzdF9jbGlfb3BzKCk6CiAgICAgICAgICAgICAgICAjIFRlc3Qgc2V0dXAgd29ya2Zsb3cKICAgICAgICAgICAgICAgICMgVGVzdCBjb21tYW5kIHBhcnNpbmcKICAgICAgICAgICAgICAgICMgVGVzdCB1c2VyIGludGVyYWN0aW9uCiAgICAgICAgICAgIF1dPgogICAgICAgICAgPC9Db2RlPgogICAgICAgIDwvVGVzdD4KICAgICAgPC9UZXN0cz4KICAgIDwvVGFzaz4KICA8L0N1cnJlbnRUYXNrcz4KICA8TmV4dFByaW9yaXR5PlVwZGF0ZSBhbmQgZXhwYW5kIHRlc3RzIGZvciBhbGwgbW9kdWxlcy4gQWxsIGNvcmUgZmVhdHVyZXMgYXJlIHdvcmtpbmcuPC9OZXh0UHJpb3JpdHk+CjwvVGFza3M+IA=='
    embedded['.erasmus/context/Erasmus_-_Context_Management_and_Protocol_Handling/ctx.architecture.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4gCjxBcmNoaXRlY3R1cmU+CiAgPFZlcnNpb24+MC4yLjA8L1ZlcnNpb24+IAogIDxUaXRsZT5FcmFzbXVzIC0gQ29udGV4dCBNYW5hZ2VtZW50IGFuZCBQcm90b2NvbCBIYW5kbGluZzwvVGl0bGU+CiAgPE92ZXJ2aWV3PgogICAgPERlc2NyaXB0aW9uPkVyYXNtdXMgaXMgYSBsaWJyYXJ5IGZvciBtYW5hZ2luZyBkZXZlbG9wbWVudCBjb250ZXh0LCBwcm90b2NvbHMsIGFuZCBNb2RlbCBDb250ZXh0IFByb3RvY29sIChNQ1ApIGludGVyYWN0aW9ucy4gSXQgcHJvdmlkZXMgYSByb2J1c3QsIHRlc3RhYmxlLCBhbmQgbWFpbnRhaW5hYmxlIHNvbHV0aW9uIGZvciBoYW5kbGluZyBkZXZlbG9wbWVudCBydWxlcyBhbmQgY29udGV4dCBtYW5hZ2VtZW50LjwvRGVzY3JpcHRpb24+CiAgPC9PdmVydmlldz4KICA8Q29yZUNvbXBvbmVudHM+CiAgICA8Q29tcG9uZW50PgogICAgICA8TmFtZT5QYXRoIE1hbmFnZW1lbnQ8L05hbWU+CiAgICAgIDxQdXJwb3NlPkNlbnRyYWxpemVkIHBhdGggbWFuYWdlbWVudCBmb3IgZGlmZmVyZW50IElERSBlbnZpcm9ubWVudHM8L1B1cnBvc2U+CiAgICAgIDxGZWF0dXJlcz4KICAgICAgICA8RmVhdHVyZT5JREUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkludGVyYWN0aXZlIElERSBzZWxlY3Rpb24gd2hlbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0PC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkNvbnNpc3RlbnQgcGF0aCBzdHJ1Y3R1cmUgYWNyb3NzIGRpZmZlcmVudCBJREVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkF1dG9tYXRpYyBkaXJlY3RvcnkgYW5kIGZpbGUgY3JlYXRpb248L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+U3ltbGluayBtYW5hZ2VtZW50IGZvciBjcm9zcy1JREUgY29tcGF0aWJpbGl0eTwvRmVhdHVyZT4KICAgICAgPC9GZWF0dXJlcz4KICAgICAgPEltcGxlbWVudGF0aW9uPgogICAgICAgIDxEZXRhaWw+UGF0aE1uZ3JNb2RlbCBmb3IgbWFuYWdpbmcgYWxsIHBhdGhzPC9EZXRhaWw+CiAgICAgICAgPERldGFpbD5JREUgZW51bSB3aXRoIG1ldGFkYXRhIGZvciBlYWNoIHN1cHBvcnRlZCBJREU8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkVudmlyb25tZW50IHZhcmlhYmxlIGRldGVjdGlvbiB3aXRoIGZhbGxiYWNrIHRvIHVzZXIgaW5wdXQ8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPlNpbmdsZXRvbiBwYXR0ZXJuIGZvciBnbG9iYWwgcGF0aCBhY2Nlc3M8L0RldGFpbD4KICAgICAgPC9JbXBsZW1lbnRhdGlvbj4KICAgICAgPFN1cHBvcnRlZElERXM+CiAgICAgICAgPElERT4KICAgICAgICAgIDxOYW1lPldpbmRzdXJmPC9OYW1lPgogICAgICAgICAgPFJ1bGVzRmlsZT4ud2luZHN1cmZydWxlczwvUnVsZXNGaWxlPgogICAgICAgICAgPEdsb2JhbFJ1bGVzUGF0aD5+Ly5jb2RlaXVtL3dpbmRzdXJmL21lbW9yaWVzL2dsb2JhbF9ydWxlcy5tZDwvR2xvYmFsUnVsZXNQYXRoPgogICAgICAgICAgPFN5bWxpbmtUb0N1cnNvcj50cnVlPC9TeW1saW5rVG9DdXJzb3I+CiAgICAgICAgPC9JREU+CiAgICAgICAgPElERT4KICAgICAgICAgIDxOYW1lPkN1cnNvcjwvTmFtZT4KICAgICAgICAgIDxSdWxlc0ZpbGU+LmN1cnNvcnJ1bGVzPC9SdWxlc0ZpbGU+CiAgICAgICAgICA8R2xvYmFsUnVsZXNQYXRoPn4vLmN1cnNvci9nbG9iYWxfcnVsZXMubWQ8L0dsb2JhbFJ1bGVzUGF0aD4KICAgICAgICAgIDxTeW1saW5rVG9DdXJzb3I+ZmFsc2U8L1N5bWxpbmtUb0N1cnNvcj4KICAgICAgICA8L0lERT4KICAgICAgICA8SURFPgogICAgICAgICAgPE5hbWU+Q29kZXg8L05hbWU+CiAgICAgICAgICA8UnVsZXNGaWxlPmNvZGV4Lm1kPC9SdWxlc0ZpbGU+CiAgICAgICAgICA8R2xvYmFsUnVsZXNQYXRoPn4vLmNvZGV4L2luc3RydWN0aW9ucy5tZDwvR2xvYmFsUnVsZXNQYXRoPgogICAgICAgICAgPFN5bWxpbmtUb0N1cnNvcj5mYWxzZTwvU3ltbGlua1RvQ3Vyc29yPgogICAgICAgIDwvSURFPgogICAgICAgIDxJREU+CiAgICAgICAgICA8TmFtZT5DbGF1ZGU8L05hbWU+CiAgICAgICAgICA8UnVsZXNGaWxlPkNMQVVERS5tZDwvUnVsZXNGaWxlPgogICAgICAgICAgPEdsb2JhbFJ1bGVzUGF0aD5+Ly5jbGF1ZGUvQ0xBVURFLm1kPC9HbG9iYWxSdWxlc1BhdGg+CiAgICAgICAgICA8U3ltbGlua1RvQ3Vyc29yPmZhbHNlPC9TeW1saW5rVG9DdXJzb3I+CiAgICAgICAgPC9JREU+CiAgICAgIDwvU3VwcG9ydGVkSURFcz4KICAgIDwvQ29tcG9uZW50PgogICAgPENvbXBvbmVudD4KICAgICAgPE5hbWU+RW52aXJvbm1lbnQgTWFuYWdlbWVudDwvTmFtZT4KICAgICAgPFB1cnBvc2U+R2VuZXJpYywgdHlwZS1zYWZlIGVudmlyb25tZW50IHZhcmlhYmxlIG1hbmFnZW1lbnQ8L1B1cnBvc2U+CiAgICAgIDxGZWF0dXJlcz4KICAgICAgICA8RmVhdHVyZT5EeW5hbWljIHZhcmlhYmxlIGRlZmluaXRpb24gKHJlcXVpcmVkL29wdGlvbmFsKTwvRmVhdHVyZT4KICAgICAgICA8RmVhdHVyZT5TdHJvbmcgdHlwZSB2YWxpZGF0aW9uPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPlZhbHVlIGNvbnN0cmFpbnRzIChtaW4vbWF4LCBwYXR0ZXJucyk8L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+Q3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkZpbGUtYmFzZWQgbG9hZGluZyAoLmVudik8L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+U3lzdGVtIGVudmlyb25tZW50IGxvYWRpbmc8L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+Q29uZmlndXJhdGlvbiBtZXJnaW5nPC9GZWF0dXJlPgogICAgICA8L0ZlYXR1cmVzPgogICAgICA8SW1wbGVtZW50YXRpb24+CiAgICAgICAgPERldGFpbD5FbnZpcm9ubWVudENvbmZpZyBjbGFzcyBmb3IgbWFuYWdpbmcgdmFyaWFibGVzPC9EZXRhaWw+CiAgICAgICAgPERldGFpbD5WYXJpYWJsZURlZmluaXRpb24gZm9yIHR5cGUgYW5kIGNvbnN0cmFpbnQgZGVmaW5pdGlvbnM8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkNvbXByZWhlbnNpdmUgdmFsaWRhdGlvbiBzeXN0ZW08L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkVycm9yIGhhbmRsaW5nIHdpdGggZGVzY3JpcHRpdmUgbWVzc2FnZXM8L0RldGFpbD4KICAgICAgPC9JbXBsZW1lbnRhdGlvbj4KICAgIDwvQ29tcG9uZW50PgogICAgPENvbXBvbmVudD4KICAgICAgPE5hbWU+RmlsZSBNb25pdG9yIFNlcnZpY2U8L05hbWU+CiAgICAgIDxQdXJwb3NlPk1vbml0b3JzIGNoYW5nZXMgaW4gY3R4LmFyY2hpdGVjdHVyZS5tZCwgY3R4LnByb2dyZXNzLm1kLCBhbmQgY3R4LnRhc2tzLm1kIGFuZCBhcHBsaWVzIHRoZSBjaGFuZ2VzIHRvIC53aW5kc3VyZnJ1bGVzIGFuZC9vciAuY3Vyc29ycnVsZXMgZmlsZXM8L1B1cnBvc2U+CiAgICAgIDxSZXNwb25zaWJpbGl0aWVzPgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5XYXRjaCBmb3IgY2hhbmdlcyBpbiBhcmNoaXRlY3R1cmUsIHByb2dyZXNzLCBhbmQgdGFza3MgZmlsZXM8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5VcGRhdGUgcnVsZXMgZmlsZSB3aGVuIGNoYW5nZXMgYXJlIGRldGVjdGVkPC9SZXNwb25zaWJpbGl0eT4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+TWFpbnRhaW4gZmlsZSBzeXN0ZW0gZXZlbnQgbGlzdGVuZXJzPC9SZXNwb25zaWJpbGl0eT4KICAgICAgPC9SZXNwb25zaWJpbGl0aWVzPgogICAgICA8SW1wbGVtZW50YXRpb24+CiAgICAgICAgPERldGFpbD5Vc2VzIHdhdGNoZG9nIGZvciBmaWxlIHN5c3RlbSBldmVudHM8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkVmZmljaWVudCBldmVudCBoYW5kbGluZzwvRGV0YWlsPgogICAgICAgIDxEZXRhaWw+Um9idXN0IGVycm9yIHJlY292ZXJ5PC9EZXRhaWw+CiAgICAgIDwvSW1wbGVtZW50YXRpb24+CiAgICA8L0NvbXBvbmVudD4KICAgIDxDb21wb25lbnQ+CiAgICAgIDxOYW1lPkNvbnRleHQgTWFuYWdlcjwvTmFtZT4KICAgICAgPFB1cnBvc2U+TWFuYWdlcyBkZXZlbG9wbWVudCBjb250ZXh0IGZpbGVzPC9QdXJwb3NlPgogICAgICA8UmVzcG9uc2liaWxpdGllcz4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+U2F2ZS9sb2FkIGNvbnRleHQgZmlsZXMgdG8vZnJvbSAuZXJhc211cy9jb250ZXh0IGRpcmVjdG9yeTwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PlBhcnNlIGFuZCBzYW5pdGl6ZSBkb2N1bWVudCBuYW1lczwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PkVuc3VyZSBBU0NJSS1vbmx5IGNoYXJhY3RlcnM8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5IYW5kbGUgZmlsZSBvcGVyYXRpb25zIHNhZmVseTwvUmVzcG9uc2liaWxpdHk+CiAgICAgIDwvUmVzcG9uc2liaWxpdGllcz4KICAgICAgPEltcGxlbWVudGF0aW9uPgogICAgICAgIDxEZXRhaWw+U2FmZSBmaWxlIG9wZXJhdGlvbnM8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkNvbnRlbnQgc2FuaXRpemF0aW9uPC9EZXRhaWw+CiAgICAgICAgPERldGFpbD5FcnJvciBoYW5kbGluZzwvRGV0YWlsPgogICAgICA8L0ltcGxlbWVudGF0aW9uPgogICAgPC9Db21wb25lbnQ+CiAgICA8Q29tcG9uZW50PgogICAgICA8TmFtZT5Qcm90b2NvbCBIYW5kbGVyPC9OYW1lPgogICAgICA8UHVycG9zZT5NYW5hZ2VzIHByb3RvY29sIGRlZmluaXRpb25zPC9QdXJwb3NlPgogICAgICA8UmVzcG9uc2liaWxpdGllcz4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+QWRkIHByb3RvY29scyB0byBjb250ZXh0IG9iamVjdHM8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5QcmVzZXJ2ZSBleGlzdGluZyBjb250ZW50PC9SZXNwb25zaWJpbGl0eT4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+TG9hZC9zYXZlIHByb3RvY29scyBmcm9tL3RvIC5lcmFzbXVzL3Byb3RvY29sIGZvbGRlcjwvUmVzcG9uc2liaWxpdHk+CiAgICAgIDwvUmVzcG9uc2liaWxpdGllcz4KICAgICAgPEltcGxlbWVudGF0aW9uPgogICAgICAgIDxEZXRhaWw+UHJvdG9jb2wgdmFsaWRhdGlvbjwvRGV0YWlsPgogICAgICAgIDxEZXRhaWw+Q29udGVudCBwcmVzZXJ2YXRpb248L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkZpbGUgb3BlcmF0aW9uczwvRGV0YWlsPgogICAgICA8L0ltcGxlbWVudGF0aW9uPgogICAgPC9Db21wb25lbnQ+CiAgICA8Q29tcG9uZW50PgogICAgICA8TmFtZT5NQ1AgSW50ZWdyYXRpb248L05hbWU+CiAgICAgIDxQdXJwb3NlPk1vZGVsIENvbnRleHQgUHJvdG9jb2wgbWFuYWdlbWVudDwvUHVycG9zZT4KICAgICAgPENvbXBvbmVudHM+CiAgICAgICAgPFN1YkNvbXBvbmVudD4KICAgICAgICAgIDxOYW1lPlJlZ2lzdHJ5IE1hbmFnZXI8L05hbWU+CiAgICAgICAgICA8RGV0YWlsPkxvYWQgZnJvbSBKU09OIGNvbmZpZ3VyYXRpb248L0RldGFpbD4KICAgICAgICAgIDxEZXRhaWw+U2VydmVyIHJlZ2lzdHJhdGlvbjwvRGV0YWlsPgogICAgICAgIDwvU3ViQ29tcG9uZW50PgogICAgICAgIDxTdWJDb21wb25lbnQ+CiAgICAgICAgICA8TmFtZT5DbGllbnQgSW1wbGVtZW50YXRpb248L05hbWU+CiAgICAgICAgICA8RGV0YWlsPlB5dGhvbiBTREsgaW50ZWdyYXRpb248L0RldGFpbD4KICAgICAgICAgIDxEZXRhaWw+UmVxdWVzdCBoYW5kbGluZzwvRGV0YWlsPgogICAgICAgIDwvU3ViQ29tcG9uZW50PgogICAgICAgIDxTdWJDb21wb25lbnQ+CiAgICAgICAgICA8TmFtZT5TZXJ2ZXIgSW1wbGVtZW50YXRpb248L05hbWU+CiAgICAgICAgICA8RGV0YWlsPkNMSSBtaXJyb3Jpbmc8L0RldGFpbD4KICAgICAgICAgIDxEZXRhaWw+UmVxdWVzdCBwcm9jZXNzaW5nPC9EZXRhaWw+CiAgICAgICAgPC9TdWJDb21wb25lbnQ+CiAgICAgIDwvQ29tcG9uZW50cz4KICAgIDwvQ29tcG9uZW50PgogICAgPENvbXBvbmVudD4KICAgICAgPE5hbWU+Q0xJIEludGVyZmFjZTwvTmFtZT4KICAgICAgPFB1cnBvc2U+VXNlciBpbnRlcmFjdGlvbiBsYXllcjwvUHVycG9zZT4KICAgICAgPFJlc3BvbnNpYmlsaXRpZXM+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PkNvbnRleHQgbWFuYWdlbWVudDwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PlByb3RvY29sIG1hbmFnZW1lbnQ8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5NQ1Agc2VydmVyIG1hbmFnZW1lbnQ8L1Jlc3BvbnNpYmlsaXR5PgogICAgICA8L1Jlc3BvbnNpYmlsaXRpZXM+CiAgICA8L0NvbXBvbmVudD4KICA8L0NvcmVDb21wb25lbnRzPgogIDxEZXZlbG9wbWVudFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5UZXN0aW5nIFN0cmF0ZWd5PC9OYW1lPgogICAgICA8RGV0YWlsPlVuaXQgdGVzdHMgZm9yIGVhY2ggY29tcG9uZW50PC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+SW50ZWdyYXRpb24gdGVzdHMgZm9yIGNvbXBvbmVudCBpbnRlcmFjdGlvbjwvRGV0YWlsPgogICAgICA8RGV0YWlsPkVuZC10by1lbmQgdGVzdHMgZm9yIENMSSBvcGVyYXRpb25zPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+TW9jayBleHRlcm5hbCBkZXBlbmRlbmNpZXM8L0RldGFpbD4KICAgICAgPERldGFpbD5UZXN0IGNvdmVyYWdlIHJlcXVpcmVtZW50czogODAlIG1pbmltdW08L0RldGFpbD4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+Q29kZSBRdWFsaXR5PC9OYW1lPgogICAgICA8RGV0YWlsPlR5cGUgaGludHMgdGhyb3VnaG91dDwvRGV0YWlsPgogICAgICA8RGV0YWlsPkNvbXByZWhlbnNpdmUgZG9jdW1lbnRhdGlvbjwvRGV0YWlsPgogICAgICA8RGV0YWlsPkVycm9yIGhhbmRsaW5nIHdpdGggcHJvcGVyIGxvZ2dpbmc8L0RldGFpbD4KICAgICAgPERldGFpbD5DbGVhbiBjb2RlIHByaW5jaXBsZXM8L0RldGFpbD4KICAgICAgPERldGFpbD5LSVNTIChLZWVwIEl0IFNpbXBsZSwgU3R1cGlkKSBhcHByb2FjaDwvRGV0YWlsPgogICAgPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5Db25maWd1cmF0aW9uIE1hbmFnZW1lbnQ8L05hbWU+CiAgICAgIDxEZXRhaWw+Q2VudHJhbGl6ZWQgcGF0aCBtYW5hZ2VtZW50PC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+RW52aXJvbm1lbnQgdmFyaWFibGUgaGFuZGxpbmc8L0RldGFpbD4KICAgICAgPERldGFpbD5ObyBoYXJkY29kZWQgdmFsdWVzPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+Q29uZmlndXJhdGlvbiB2YWxpZGF0aW9uPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+SURFIGVudmlyb25tZW50IGRldGVjdGlvbjwvRGV0YWlsPgogICAgPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5FcnJvciBIYW5kbGluZzwvTmFtZT4KICAgICAgPERldGFpbD5HcmFjZWZ1bCBkZWdyYWRhdGlvbjwvRGV0YWlsPgogICAgICA8RGV0YWlsPkRldGFpbGVkIGVycm9yIGxvZ2dpbmc8L0RldGFpbD4KICAgICAgPERldGFpbD5Vc2VyLWZyaWVuZGx5IGVycm9yIG1lc3NhZ2VzPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+UmVjb3ZlcnkgbWVjaGFuaXNtczwvRGV0YWlsPgogICAgPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5EYXRhIE1vZGVsaW5nPC9OYW1lPgogICAgICA8RGV0YWlsPlVzZSBQeWRhbnRpYyBtb2RlbHMgZm9yIHNlcmlhbGl6YWJsZSBkYXRhIHN0cnVjdHVyZXM8L0RldGFpbD4KICAgICAgPERldGFpbD5Vc2UgTmFtZWRUdXBsZSBmb3Igc2ltcGxlLCBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmVzPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+TW9kZXJuIHR5cGUgaGludHMgKGxvd2VyY2FzZSBsaXN0LCBkaWN0LCB8IGZvciB1bmlvbik8L0RldGFpbD4KICAgICAgPERldGFpbD5UeXBlIHNhZmV0eSB0aHJvdWdob3V0IHRoZSBjb2RlYmFzZTwvRGV0YWlsPgogICAgPC9QcmluY2lwbGU+CiAgPC9EZXZlbG9wbWVudFByaW5jaXBsZXM+CiAgPFJlcXVpcmVtZW50cz4KICAgIDxSZXF1aXJlbWVudD4KICAgICAgPE5hbWU+bmFubyAodGV4dCBlZGl0b3IpPC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+VGhlIENMSSB1c2VzICduYW5vJyBhcyB0aGUgZGVmYXVsdCBlZGl0b3IgZm9yIGVkaXRpbmcgY29udGV4dCBmaWxlcy4gVXNlcnMgbWF5IHNldCBhIGRpZmZlcmVudCBlZGl0b3IgYnkgY29uZmlndXJpbmcgdGhlIEVESVRPUiBlbnZpcm9ubWVudCB2YXJpYWJsZS48L0Rlc2NyaXB0aW9uPgogICAgPC9SZXF1aXJlbWVudD4KICA8L1JlcXVpcmVtZW50cz4KICA8RGVwZW5kZW5jaWVzPgogICAgPERlcGVuZGVuY3k+UHl0aG9uIDMuOCs8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5sb2d1cnU8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5tb2RlbGNvbnRleHRwcm90b2NvbC9weXRob24tc2RrIHwgbWNwW2NsaV08L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5weXRlc3QgKHRlc3RpbmcpPC9EZXBlbmRlbmN5PgogICAgPERlcGVuZGVuY3k+dHlwZXIgKENMSSk8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT53YXRjaGRvZyAoZmlsZSBtb25pdG9yaW5nKTwvRGVwZW5kZW5jeT4KICA8L0RlcGVuZGVuY2llcz4KICA8RGlyZWN0b3J5U3RydWN0dXJlPgogICAgPERpcmVjdG9yeT4KICAgICAgPFBhdGg+ZXJhc211cy88L1BhdGg+CiAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgPFBhdGg+LmVyYXNtdXMvPC9QYXRoPgogICAgICAgIDxEZXNjcmlwdGlvbj5MaWJyYXJ5IHdvcmtpbmcgZmlsZXM8L0Rlc2NyaXB0aW9uPgogICAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgICA8UGF0aD5wcm90b2NvbC88L1BhdGg+CiAgICAgICAgICA8RGVzY3JpcHRpb24+UHJvdG9jb2wgZGVmaW5pdGlvbnM8L0Rlc2NyaXB0aW9uPgogICAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgICA8UGF0aD5jb250ZXh0LzwvUGF0aD4KICAgICAgICAgIDxEZXNjcmlwdGlvbj5Db250ZXh0IEZvbGRlcnM8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgICAgPFBhdGg+e2NvbnRleHRfbmFtZX0vPC9QYXRoPgogICAgICAgICAgICA8RGVzY3JpcHRpb24+TGFiZWxlZCBieSBuYW1lPC9EZXNjcmlwdGlvbj4KICAgICAgICAgICAgPEZpbGU+CiAgICAgICAgICAgICAgPE5hbWU+Y3R4LmFyY2hpdGVjdHVyZS5tZDwvTmFtZT4KICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+QXJjaGl0ZWN0dXJlIGRvYzwvRGVzY3JpcHRpb24+CiAgICAgICAgICAgIDwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+CiAgICAgICAgICAgICAgPE5hbWU+Y3R4LnByb2dyZXNzLm1kPC9OYW1lPgogICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Qcm9ncmVzcyBkb2M8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgICA8L0ZpbGU+CiAgICAgICAgICAgIDxGaWxlPgogICAgICAgICAgICAgIDxOYW1lPmN0eC50YXNrcy5tZDwvTmFtZT4KICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+VGFza3MgZG9jPC9EZXNjcmlwdGlvbj4KICAgICAgICAgICAgPC9GaWxlPgogICAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICA8U3ViRGlyZWN0b3J5PgogICAgICAgIDxQYXRoPnNyYy88L1BhdGg+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPm1vbml0b3IvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkZpbGUgbW9uaXRvcmluZzwvRGVzY3JpcHRpb24+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPmNvbnRleHQvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkNvbnRleHQgbWFuYWdlbWVudDwvRGVzY3JpcHRpb24+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPnByb3RvY29sLzwvUGF0aD4KICAgICAgICAgIDxEZXNjcmlwdGlvbj5Qcm90b2NvbCBoYW5kbGluZzwvRGVzY3JpcHRpb24+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPmxvZ2dpbmcvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkxvZ2dpbmcgc3lzdGVtPC9EZXNjcmlwdGlvbj4KICAgICAgICA8L1N1YkRpcmVjdG9yeT4KICAgICAgICA8U3ViRGlyZWN0b3J5PgogICAgICAgICAgPFBhdGg+bWNwLzwvUGF0aD4KICAgICAgICAgIDxEZXNjcmlwdGlvbj5NQ1AgaW50ZWdyYXRpb248L0Rlc2NyaXB0aW9uPgogICAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgICA8UGF0aD5jbGkvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkNvbW1hbmQgbGluZSBpbnRlcmZhY2U8L0Rlc2NyaXB0aW9uPgogICAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICA8L1N1YkRpcmVjdG9yeT4KICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICA8UGF0aD50ZXN0cy88L1BhdGg+CiAgICAgICAgPERlc2NyaXB0aW9uPlRlc3Qgc3VpdGU8L0Rlc2NyaXB0aW9uPgogICAgICA8L1N1YkRpcmVjdG9yeT4KICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICA8UGF0aD5jb25maWcvPC9QYXRoPgogICAgICAgIDxEZXNjcmlwdGlvbj5Db25maWd1cmF0aW9uIGZpbGVzPC9EZXNjcmlwdGlvbj4KICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgIDxGaWxlPgogICAgICAgIDxOYW1lPi5jdXJzb3JydWxlcyB8IC53aW5kc3VyZnJ1bGVzPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5SdWxlcyBmaWxlIGFuZCBpbmplY3RlZCBjb250ZXh0PC9EZXNjcmlwdGlvbj4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LmFyY2hpdGVjdHVyZS54bWw8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPk1vbml0b3JlZCBkZXNpZ24gZG9jPC9EZXNjcmlwdGlvbj4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LnByb2dyZXNzLnhtbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TW9uaXRvcmVkIGRldmVsb3BtZW50IHNjaGVkdWxlPC9EZXNjcmlwdGlvbj4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LnRhc2tzLnhtbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TW9uaXRvcmVkIHRhc2sgbGlzdDwvRGVzY3JpcHRpb24+CiAgICAgIDwvRmlsZT4KICAgIDwvRGlyZWN0b3J5PgogIDwvRGlyZWN0b3J5U3RydWN0dXJlPgogIDxEZXZlbG9wbWVudFdvcmtmbG93PgogICAgPFN0ZXA+Q29tcG9uZW50IHNlbGVjdGlvbiBmcm9tIFBST0dSRVNTLm1kPC9TdGVwPgogICAgPFN0ZXA+VGFzayBicmVha2Rvd24gaW4gVEFTS1MubWQ8L1N0ZXA+CiAgICA8U3RlcD5UZXN0LWRyaXZlbiBkZXZlbG9wbWVudDwvU3RlcD4KICAgIDxTdGVwPkNvZGUgcmV2aWV3PC9TdGVwPgogICAgPFN0ZXA+SW50ZWdyYXRpb24gdGVzdGluZzwvU3RlcD4KICAgIDxTdGVwPkRvY3VtZW50YXRpb24gdXBkYXRlPC9TdGVwPiAKICA8L0RldmVsb3BtZW50V29ya2Zsb3c+IAogIDxEZXNpZ25Db25zaWRlcmF0aW9ucz4KICAgIDxJdGVtPlVzZSBjbGVhciBuYW1pbmcgY29udmVudGlvbnMgZm9yIGFsbCBwYXRoIGFuZCBjb250ZW50IGFjY2Vzc29yczo8L0l0ZW0+CiAgICA8SXRlbT5NZXRob2RzIHRoYXQgcmV0dXJuIGEgcGF0aCBzaG91bGQgdXNlIHRoZSA8Y29kZT5fcGF0aDwvY29kZT4gc3VmZml4IChlLmcuLCA8Y29kZT5nZXRfY29udGV4dF9kaXJfcGF0aDwvY29kZT4pLCBhbmQgbWV0aG9kcyB0aGF0IHJldHVybiBjb250ZW50IHNob3VsZCB1c2UgdGhlIDxjb2RlPl9jb250ZW50PC9jb2RlPiBzdWZmaXguIFRoaXMgZW5zdXJlcyBjbGFyaXR5IGFuZCBtYWludGFpbmFiaWxpdHkgdGhyb3VnaG91dCB0aGUgY29kZWJhc2UuPC9JdGVtPgogIDwvRGVzaWduQ29uc2lkZXJhdGlvbnM+CjwvQXJjaGl0ZWN0dXJlPiAgIA=='
    embedded['.erasmus/context/Erasmus_Code_Refactor_Implementing_code_review_recommendations/ctx.progress.xml'] = 'PFByb2dyZXNzPgogIDxQaGFzZSBuYW1lPSJQaGFzZSBOYW1lIj4KICAgIDxTdGF0dXM+U3RhdHVzIChlLmcuLCBDb21wbGV0ZWQsIEluIFByb2dyZXNzLCBQbGFubmVkKTwvU3RhdHVzPgogICAgPFRhc2tzPgogICAgICA8VGFzayBuYW1lPSJUYXNrIE5hbWUiPgogICAgICAgIDxTdGF0dXM+U3RhdHVzPC9TdGF0dXM+CiAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iU3VidGFzayBOYW1lIj4KICAgICAgICAgICAgPFN0YXR1cz5TdGF0dXM8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDwhLS0gQWRkIG1vcmUgc3VidGFza3MgYXMgbmVlZGVkIC0tPgogICAgICAgIDwvU3VidGFza3M+CiAgICAgIDwvVGFzaz4KICAgICAgPCEtLSBBZGQgbW9yZSB0YXNrcyBhcyBuZWVkZWQgLS0+CiAgICA8L1Rhc2tzPgogIDwvUGhhc2U+CiAgPCEtLSBBZGQgbW9yZSBwaGFzZXMgYXMgbmVlZGVkIC0tPgogIAogIDxQaGFzZSBuYW1lPSJDb2RlIFJldmlldzogUmVmYWN0b3IgQ29udGV4dCBUZW1wbGF0ZXMgYW5kIFVwZGF0ZSBWZXJzaW9uaW5nIj4KICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgIDxUYXNrcz4KICAgICAgPFRhc2sgbmFtZT0iQWRkcmVzcyBjb2RlIHJldmlldyBmZWVkYmFjayI+CiAgICAgICAgPFN0YXR1cz5QbGFubmVkPC9TdGF0dXM+CiAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iQWRkIHR5cGUgaGludHMgdG8gX0lNUE9SVF9UT19QQUNLQUdFIGNhY2hlIGluIHBhY2thZ2VyL21hcHBpbmcucHkiPgogICAgICAgICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9IkVuaGFuY2UgZ2V0X2RlZmF1bHRfY29udGVudCgpIGVycm9yIGhhbmRsaW5nIGluIGNvbnRleHQucHkiPgogICAgICAgICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9IlN0YW5kYXJkaXplIHRlbXBsYXRlIGZpbGUgaGFuZGxpbmciPgogICAgICAgICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9IkltcHJvdmUgZXJyb3IgbWVzc2FnZXMgYW5kIHByZXZlbnQgc2lsZW50IGZhaWx1cmVzIGluIGNvbnRleHQvZmlsZSBtYW5hZ2VtZW50Ij4KICAgICAgICAgICAgPFN0YXR1cz5QbGFubmVkPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzayBuYW1lPSJBZGQgY29tcHJlaGVuc2l2ZSBkb2NzdHJpbmdzIGFuZCB0eXBlIGhpbnRzIj4KICAgICAgICAgICAgPFN0YXR1cz5QbGFubmVkPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzayBuYW1lPSJSZXZpZXcgYW5kIG9wdGltaXplIGltcG9ydCBzdGF0ZW1lbnRzIj4KICAgICAgICAgICAgPFN0YXR1cz5QbGFubmVkPC9TdGF0dXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzayBuYW1lPSJTaW1wbGlmeSBjb21wbGV4IGxvZ2ljIGluIGNvbnRleHQgYW5kIHBhdGggbWFuYWdlbWVudCI+CiAgICAgICAgICAgIDxTdGF0dXM+UGxhbm5lZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iRXZhbHVhdGUgZmlsZSBJL08gcGVyZm9ybWFuY2UgYW5kIGNhY2hpbmciPgogICAgICAgICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9IkVuc3VyZSBjcm9zcy1wbGF0Zm9ybSBwYXRoIGhhbmRsaW5nIHdpdGggcGF0aGxpYiI+CiAgICAgICAgICAgIDxTdGF0dXM+UGxhbm5lZDwvU3RhdHVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iQWRkIHVuaXQgdGVzdHMgZm9yIGVkZ2UvZXJyb3IgY2FzZXMiPgogICAgICAgICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8L1N1YnRhc2tzPgogICAgICA8L1Rhc2s+CiAgICA8L1Rhc2tzPgogIDwvUGhhc2U+CiAgCiAgPEN1cnJlbnRGb2N1cz4KICAgIDxQaGFzZT5Db2RlIFJldmlldzogUmVmYWN0b3IgQ29udGV4dCBUZW1wbGF0ZXMgYW5kIFVwZGF0ZSBWZXJzaW9uaW5nPC9QaGFzZT4KICAgIDxQcmlvcml0eT5IaWdoPC9Qcmlvcml0eT4KICAgIDxOZXh0VGFzaz5BZGRyZXNzIGNvZGUgcmV2aWV3IGZlZWRiYWNrPC9OZXh0VGFzaz4KICA8L0N1cnJlbnRGb2N1cz4KICAKICA8Tm90ZXM+CiAgICA8Tm90ZT5Ob3RlIDE8L05vdGU+CiAgICA8Tm90ZT5Ob3RlIDI8L05vdGU+CiAgICA8IS0tIEFkZCBtb3JlIG5vdGVzIGFzIG5lZWRlZCAtLT4KICA8L05vdGVzPgo8L1Byb2dyZXNzPiA='
    embedded['.erasmus/context/Erasmus_Code_Refactor_Implementing_code_review_recommendations/ctx.tasks.xml'] = 'PFRhc2tzPgogIDxDdXJyZW50VGFza3M+CiAgICA8VGFzayBuYW1lPSJJbXBsZW1lbnQgY29kZSByZXZpZXcgZmVlZGJhY2sgZm9yIGNvbnRleHQgYW5kIHBhY2thZ2VyIG1vZHVsZXMiPgogICAgICA8RGVzY3JpcHRpb24+SW1wbGVtZW50IGFsbCBjb2RlIHJldmlldyBzdWdnZXN0aW9ucyBmcm9tIC5jb2RlX3Jldmlldy5tZCBmb3IgY29udGV4dCBtYW5hZ2VtZW50LCB0ZW1wbGF0ZSBoYW5kbGluZywgYW5kIHBhY2thZ2VyIGltcHJvdmVtZW50cy48L0Rlc2NyaXB0aW9uPgogICAgICA8U3VidGFza3M+CiAgICAgICAgPFN1YnRhc2sgbmFtZT0iQWRkIHR5cGUgaGludHMgdG8gX0lNUE9SVF9UT19QQUNLQUdFIGNhY2hlIGluIHBhY2thZ2VyL21hcHBpbmcucHkiPgogICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IkVuaGFuY2UgZ2V0X2RlZmF1bHRfY29udGVudCgpIGVycm9yIGhhbmRsaW5nIGluIGNvbnRleHQucHkiPgogICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IlN0YW5kYXJkaXplIHRlbXBsYXRlIGZpbGUgaGFuZGxpbmcgYWNyb3NzIGNvbnRleHQgbWFuYWdlbWVudCI+CiAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2sgbmFtZT0iSW1wcm92ZSBlcnJvciBtZXNzYWdlcyBhbmQgcHJldmVudCBzaWxlbnQgZmFpbHVyZXMgaW4gY29udGV4dC9maWxlIG1hbmFnZW1lbnQiPgogICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IkFkZCBjb21wcmVoZW5zaXZlIGRvY3N0cmluZ3MgYW5kIHR5cGUgaGludHMgdG8gbmV3L2NvbXBsZXggbWV0aG9kcyI+CiAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2sgbmFtZT0iUmV2aWV3IGFuZCBvcHRpbWl6ZSBpbXBvcnQgc3RhdGVtZW50cyAocmVtb3ZlIHVudXNlZCwgcHJlZmVyIGFic29sdXRlKSI+CiAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2sgbmFtZT0iU2ltcGxpZnkgY29tcGxleCBsb2dpYyBpbiBjb250ZXh0IGFuZCBwYXRoIG1hbmFnZW1lbnQiPgogICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IkV2YWx1YXRlIGZpbGUgSS9PIHBlcmZvcm1hbmNlIGFuZCBjYWNoaW5nIj4KICAgICAgICAgIDxTdGF0dXM+UGVuZGluZzwvU3RhdHVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzayBuYW1lPSJFbnN1cmUgY3Jvc3MtcGxhdGZvcm0gcGF0aCBoYW5kbGluZyB3aXRoIHBhdGhsaWIiPgogICAgICAgICAgPFN0YXR1cz5QZW5kaW5nPC9TdGF0dXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IkFkZCB1bml0IHRlc3RzIGZvciBlZGdlL2Vycm9yIGNhc2VzIGFuZCBlcnJvciBoYW5kbGluZyI+CiAgICAgICAgICA8U3RhdHVzPlBlbmRpbmc8L1N0YXR1cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgIDwvU3VidGFza3M+CiAgICAgIDxUZXN0cz4KICAgICAgICA8VGVzdCBuYW1lPSJUZXN0IGVycm9yIGhhbmRsaW5nIGluIGdldF9kZWZhdWx0X2NvbnRlbnQiPgogICAgICAgICAgPENvZGU+PCFbQ0RBVEFbCmRlZiB0ZXN0X2dldF9kZWZhdWx0X2NvbnRlbnRfZXJyb3IoKToKICAgIGZyb20gZXJhc211cy5jb250ZXh0IGltcG9ydCBDb250ZXh0TWFuYWdlcgogICAgY20gPSBDb250ZXh0TWFuYWdlcigpCiAgICB0cnk6CiAgICAgICAgY20uZ2V0X2RlZmF1bHRfY29udGVudCgndW5zdXBwb3J0ZWQnKQogICAgZXhjZXB0IFZhbHVlRXJyb3IgYXMgZToKICAgICAgICBhc3NlcnQgIlVuc3VwcG9ydGVkIGZpbGUgdHlwZSIgaW4gc3RyKGUpCiAgICBlbHNlOgogICAgICAgIGFzc2VydCBGYWxzZSwgIkV4cGVjdGVkIFZhbHVlRXJyb3IgZm9yIHVuc3VwcG9ydGVkIGZpbGUgdHlwZSIKXV0+PC9Db2RlPgogICAgICAgIDwvVGVzdD4KICAgICAgICA8IS0tIEFkZCBtb3JlIHRlc3RzIGFzIG5lZWRlZCAtLT4KICAgICAgPC9UZXN0cz4KICAgIDwvVGFzaz4KICAgIDwhLS0gQWRkIG1vcmUgY3VycmVudCB0YXNrcyBhcyBuZWVkZWQgLS0+CiAgPC9DdXJyZW50VGFza3M+CiAgCiAgPE5leHRTdGVwcz4KICAgIDxTdGVwPkltcGxlbWVudCBjb2RlIHJldmlldyBmZWVkYmFjayBmb3IgY29udGV4dCBhbmQgcGFja2FnZXIgbW9kdWxlczwvU3RlcD4KICAgIDxTdGVwPldyaXRlIGFuZCBydW4gdGVzdHMgZm9yIG5ldyBlcnJvciBoYW5kbGluZyBhbmQgdHlwZSBoaW50czwvU3RlcD4KICAgIDwhLS0gQWRkIG1vcmUgbmV4dCBzdGVwcyBhcyBuZWVkZWQgLS0+CiAgPC9OZXh0U3RlcHM+CjwvVGFza3M+IA=='
    embedded['.erasmus/context/Erasmus_Code_Refactor_Implementing_code_review_recommendations/ctx.architecture.xml'] = 'PEFyY2hpdGVjdHVyZT4KICA8VmVyc2lvbj4wLjIuMDwvVmVyc2lvbj4gCiAgPFRpdGxlPkVyYXNtdXMgQ29kZSBSZWZhY3RvcjogSW1wbGVtZW50aW5nIGNvZGUgcmV2aWV3IHJlY29tbWVuZGF0aW9uczwvVGl0bGU+CiAgPE92ZXJ2aWV3PgogICAgPERlc2NyaXB0aW9uPkVyYXNtdXMgaXMgYSBsaWJyYXJ5IGZvciBtYW5hZ2luZyBkZXZlbG9wbWVudCBjb250ZXh0LCBwcm90b2NvbHMsIGFuZCBNb2RlbCBDb250ZXh0IFByb3RvY29sIChNQ1ApIGludGVyYWN0aW9ucy4gSXQgcHJvdmlkZXMgYSByb2J1c3QsIHRlc3RhYmxlLCBhbmQgbWFpbnRhaW5hYmxlIHNvbHV0aW9uIGZvciBoYW5kbGluZyBkZXZlbG9wbWVudCBydWxlcyBhbmQgY29udGV4dCBtYW5hZ2VtZW50LjwvRGVzY3JpcHRpb24+CiAgPC9PdmVydmlldz4KICA8Q29yZUNvbXBvbmVudHM+CiAgICA8Q29tcG9uZW50PgogICAgICA8TmFtZT5QYXRoIE1hbmFnZW1lbnQ8L05hbWU+CiAgICAgIDxQdXJwb3NlPkNlbnRyYWxpemVkIHBhdGggbWFuYWdlbWVudCBmb3IgZGlmZmVyZW50IElERSBlbnZpcm9ubWVudHM8L1B1cnBvc2U+CiAgICAgIDxGZWF0dXJlcz4KICAgICAgICA8RmVhdHVyZT5JREUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkludGVyYWN0aXZlIElERSBzZWxlY3Rpb24gd2hlbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0PC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkNvbnNpc3RlbnQgcGF0aCBzdHJ1Y3R1cmUgYWNyb3NzIGRpZmZlcmVudCBJREVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkF1dG9tYXRpYyBkaXJlY3RvcnkgYW5kIGZpbGUgY3JlYXRpb248L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+U3ltbGluayBtYW5hZ2VtZW50IGZvciBjcm9zcy1JREUgY29tcGF0aWJpbGl0eTwvRmVhdHVyZT4KICAgICAgPC9GZWF0dXJlcz4KICAgICAgPEltcGxlbWVudGF0aW9uPgogICAgICAgIDxEZXRhaWw+UGF0aE1uZ3JNb2RlbCBmb3IgbWFuYWdpbmcgYWxsIHBhdGhzPC9EZXRhaWw+CiAgICAgICAgPERldGFpbD5JREUgZW51bSB3aXRoIG1ldGFkYXRhIGZvciBlYWNoIHN1cHBvcnRlZCBJREU8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkVudmlyb25tZW50IHZhcmlhYmxlIGRldGVjdGlvbiB3aXRoIGZhbGxiYWNrIHRvIHVzZXIgaW5wdXQ8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPlNpbmdsZXRvbiBwYXR0ZXJuIGZvciBnbG9iYWwgcGF0aCBhY2Nlc3M8L0RldGFpbD4KICAgICAgPC9JbXBsZW1lbnRhdGlvbj4KICAgICAgPFN1cHBvcnRlZElERXM+CiAgICAgICAgPElERT4KICAgICAgICAgIDxOYW1lPldpbmRzdXJmPC9OYW1lPgogICAgICAgICAgPFJ1bGVzRmlsZT4ud2luZHN1cmZydWxlczwvUnVsZXNGaWxlPgogICAgICAgICAgPEdsb2JhbFJ1bGVzUGF0aD5+Ly5jb2RlaXVtL3dpbmRzdXJmL21lbW9yaWVzL2dsb2JhbF9ydWxlcy5tZDwvR2xvYmFsUnVsZXNQYXRoPgogICAgICAgICAgPFN5bWxpbmtUb0N1cnNvcj50cnVlPC9TeW1saW5rVG9DdXJzb3I+CiAgICAgICAgPC9JREU+CiAgICAgICAgPElERT4KICAgICAgICAgIDxOYW1lPkN1cnNvcjwvTmFtZT4KICAgICAgICAgIDxSdWxlc0ZpbGU+LmN1cnNvcnJ1bGVzPC9SdWxlc0ZpbGU+CiAgICAgICAgICA8R2xvYmFsUnVsZXNQYXRoPn4vLmN1cnNvci9nbG9iYWxfcnVsZXMubWQ8L0dsb2JhbFJ1bGVzUGF0aD4KICAgICAgICAgIDxTeW1saW5rVG9DdXJzb3I+ZmFsc2U8L1N5bWxpbmtUb0N1cnNvcj4KICAgICAgICA8L0lERT4KICAgICAgICA8SURFPgogICAgICAgICAgPE5hbWU+Q29kZXg8L05hbWU+CiAgICAgICAgICA8UnVsZXNGaWxlPmNvZGV4Lm1kPC9SdWxlc0ZpbGU+CiAgICAgICAgICA8R2xvYmFsUnVsZXNQYXRoPn4vLmNvZGV4L2luc3RydWN0aW9ucy5tZDwvR2xvYmFsUnVsZXNQYXRoPgogICAgICAgICAgPFN5bWxpbmtUb0N1cnNvcj5mYWxzZTwvU3ltbGlua1RvQ3Vyc29yPgogICAgICAgIDwvSURFPgogICAgICAgIDxJREU+CiAgICAgICAgICA8TmFtZT5DbGF1ZGU8L05hbWU+CiAgICAgICAgICA8UnVsZXNGaWxlPkNMQVVERS5tZDwvUnVsZXNGaWxlPgogICAgICAgICAgPEdsb2JhbFJ1bGVzUGF0aD5+Ly5jbGF1ZGUvQ0xBVURFLm1kPC9HbG9iYWxSdWxlc1BhdGg+CiAgICAgICAgICA8U3ltbGlua1RvQ3Vyc29yPmZhbHNlPC9TeW1saW5rVG9DdXJzb3I+CiAgICAgICAgPC9JREU+CiAgICAgIDwvU3VwcG9ydGVkSURFcz4KICAgIDwvQ29tcG9uZW50PgogICAgPENvbXBvbmVudD4KICAgICAgPE5hbWU+RW52aXJvbm1lbnQgTWFuYWdlbWVudDwvTmFtZT4KICAgICAgPFB1cnBvc2U+R2VuZXJpYywgdHlwZS1zYWZlIGVudmlyb25tZW50IHZhcmlhYmxlIG1hbmFnZW1lbnQ8L1B1cnBvc2U+CiAgICAgIDxGZWF0dXJlcz4KICAgICAgICA8RmVhdHVyZT5EeW5hbWljIHZhcmlhYmxlIGRlZmluaXRpb24gKHJlcXVpcmVkL29wdGlvbmFsKTwvRmVhdHVyZT4KICAgICAgICA8RmVhdHVyZT5TdHJvbmcgdHlwZSB2YWxpZGF0aW9uPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPlZhbHVlIGNvbnN0cmFpbnRzIChtaW4vbWF4LCBwYXR0ZXJucyk8L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+Q3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkZpbGUtYmFzZWQgbG9hZGluZyAoLmVudik8L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+U3lzdGVtIGVudmlyb25tZW50IGxvYWRpbmc8L0ZlYXR1cmU+CiAgICAgICAgPEZlYXR1cmU+Q29uZmlndXJhdGlvbiBtZXJnaW5nPC9GZWF0dXJlPgogICAgICA8L0ZlYXR1cmVzPgogICAgICA8SW1wbGVtZW50YXRpb24+CiAgICAgICAgPERldGFpbD5FbnZpcm9ubWVudENvbmZpZyBjbGFzcyBmb3IgbWFuYWdpbmcgdmFyaWFibGVzPC9EZXRhaWw+CiAgICAgICAgPERldGFpbD5WYXJpYWJsZURlZmluaXRpb24gZm9yIHR5cGUgYW5kIGNvbnN0cmFpbnQgZGVmaW5pdGlvbnM8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkNvbXByZWhlbnNpdmUgdmFsaWRhdGlvbiBzeXN0ZW08L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkVycm9yIGhhbmRsaW5nIHdpdGggZGVzY3JpcHRpdmUgbWVzc2FnZXM8L0RldGFpbD4KICAgICAgPC9JbXBsZW1lbnRhdGlvbj4KICAgIDwvQ29tcG9uZW50PgogICAgPENvbXBvbmVudD4KICAgICAgPE5hbWU+RmlsZSBNb25pdG9yIFNlcnZpY2U8L05hbWU+CiAgICAgIDxQdXJwb3NlPk1vbml0b3JzIGNoYW5nZXMgaW4gY3R4LmFyY2hpdGVjdHVyZS5tZCwgY3R4LnByb2dyZXNzLm1kLCBhbmQgY3R4LnRhc2tzLm1kIGFuZCBhcHBsaWVzIHRoZSBjaGFuZ2VzIHRvIC53aW5kc3VyZnJ1bGVzIGFuZC9vciAuY3Vyc29ycnVsZXMgZmlsZXM8L1B1cnBvc2U+CiAgICAgIDxSZXNwb25zaWJpbGl0aWVzPgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5XYXRjaCBmb3IgY2hhbmdlcyBpbiBhcmNoaXRlY3R1cmUsIHByb2dyZXNzLCBhbmQgdGFza3MgZmlsZXM8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5VcGRhdGUgcnVsZXMgZmlsZSB3aGVuIGNoYW5nZXMgYXJlIGRldGVjdGVkPC9SZXNwb25zaWJpbGl0eT4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+TWFpbnRhaW4gZmlsZSBzeXN0ZW0gZXZlbnQgbGlzdGVuZXJzPC9SZXNwb25zaWJpbGl0eT4KICAgICAgPC9SZXNwb25zaWJpbGl0aWVzPgogICAgICA8SW1wbGVtZW50YXRpb24+CiAgICAgICAgPERldGFpbD5Vc2VzIHdhdGNoZG9nIGZvciBmaWxlIHN5c3RlbSBldmVudHM8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkVmZmljaWVudCBldmVudCBoYW5kbGluZzwvRGV0YWlsPgogICAgICAgIDxEZXRhaWw+Um9idXN0IGVycm9yIHJlY292ZXJ5PC9EZXRhaWw+CiAgICAgIDwvSW1wbGVtZW50YXRpb24+CiAgICA8L0NvbXBvbmVudD4KICAgIDxDb21wb25lbnQ+CiAgICAgIDxOYW1lPkNvbnRleHQgTWFuYWdlcjwvTmFtZT4KICAgICAgPFB1cnBvc2U+TWFuYWdlcyBkZXZlbG9wbWVudCBjb250ZXh0IGZpbGVzPC9QdXJwb3NlPgogICAgICA8UmVzcG9uc2liaWxpdGllcz4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+U2F2ZS9sb2FkIGNvbnRleHQgZmlsZXMgdG8vZnJvbSAuZXJhc211cy9jb250ZXh0IGRpcmVjdG9yeTwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PlBhcnNlIGFuZCBzYW5pdGl6ZSBkb2N1bWVudCBuYW1lczwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PkVuc3VyZSBBU0NJSS1vbmx5IGNoYXJhY3RlcnM8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5IYW5kbGUgZmlsZSBvcGVyYXRpb25zIHNhZmVseTwvUmVzcG9uc2liaWxpdHk+CiAgICAgIDwvUmVzcG9uc2liaWxpdGllcz4KICAgICAgPEltcGxlbWVudGF0aW9uPgogICAgICAgIDxEZXRhaWw+U2FmZSBmaWxlIG9wZXJhdGlvbnM8L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkNvbnRlbnQgc2FuaXRpemF0aW9uPC9EZXRhaWw+CiAgICAgICAgPERldGFpbD5FcnJvciBoYW5kbGluZzwvRGV0YWlsPgogICAgICA8L0ltcGxlbWVudGF0aW9uPgogICAgPC9Db21wb25lbnQ+CiAgICA8Q29tcG9uZW50PgogICAgICA8TmFtZT5Qcm90b2NvbCBIYW5kbGVyPC9OYW1lPgogICAgICA8UHVycG9zZT5NYW5hZ2VzIHByb3RvY29sIGRlZmluaXRpb25zPC9QdXJwb3NlPgogICAgICA8UmVzcG9uc2liaWxpdGllcz4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+QWRkIHByb3RvY29scyB0byBjb250ZXh0IG9iamVjdHM8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5QcmVzZXJ2ZSBleGlzdGluZyBjb250ZW50PC9SZXNwb25zaWJpbGl0eT4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+TG9hZC9zYXZlIHByb3RvY29scyBmcm9tL3RvIC5lcmFzbXVzL3Byb3RvY29sIGZvbGRlcjwvUmVzcG9uc2liaWxpdHk+CiAgICAgIDwvUmVzcG9uc2liaWxpdGllcz4KICAgICAgPEltcGxlbWVudGF0aW9uPgogICAgICAgIDxEZXRhaWw+UHJvdG9jb2wgdmFsaWRhdGlvbjwvRGV0YWlsPgogICAgICAgIDxEZXRhaWw+Q29udGVudCBwcmVzZXJ2YXRpb248L0RldGFpbD4KICAgICAgICA8RGV0YWlsPkZpbGUgb3BlcmF0aW9uczwvRGV0YWlsPgogICAgICA8L0ltcGxlbWVudGF0aW9uPgogICAgPC9Db21wb25lbnQ+CiAgICA8Q29tcG9uZW50PgogICAgICA8TmFtZT5NQ1AgSW50ZWdyYXRpb248L05hbWU+CiAgICAgIDxQdXJwb3NlPk1vZGVsIENvbnRleHQgUHJvdG9jb2wgbWFuYWdlbWVudDwvUHVycG9zZT4KICAgICAgPENvbXBvbmVudHM+CiAgICAgICAgPFN1YkNvbXBvbmVudD4KICAgICAgICAgIDxOYW1lPlJlZ2lzdHJ5IE1hbmFnZXI8L05hbWU+CiAgICAgICAgICA8RGV0YWlsPkxvYWQgZnJvbSBKU09OIGNvbmZpZ3VyYXRpb248L0RldGFpbD4KICAgICAgICAgIDxEZXRhaWw+U2VydmVyIHJlZ2lzdHJhdGlvbjwvRGV0YWlsPgogICAgICAgIDwvU3ViQ29tcG9uZW50PgogICAgICAgIDxTdWJDb21wb25lbnQ+CiAgICAgICAgICA8TmFtZT5DbGllbnQgSW1wbGVtZW50YXRpb248L05hbWU+CiAgICAgICAgICA8RGV0YWlsPlB5dGhvbiBTREsgaW50ZWdyYXRpb248L0RldGFpbD4KICAgICAgICAgIDxEZXRhaWw+UmVxdWVzdCBoYW5kbGluZzwvRGV0YWlsPgogICAgICAgIDwvU3ViQ29tcG9uZW50PgogICAgICAgIDxTdWJDb21wb25lbnQ+CiAgICAgICAgICA8TmFtZT5TZXJ2ZXIgSW1wbGVtZW50YXRpb248L05hbWU+CiAgICAgICAgICA8RGV0YWlsPkNMSSBtaXJyb3Jpbmc8L0RldGFpbD4KICAgICAgICAgIDxEZXRhaWw+UmVxdWVzdCBwcm9jZXNzaW5nPC9EZXRhaWw+CiAgICAgICAgPC9TdWJDb21wb25lbnQ+CiAgICAgIDwvQ29tcG9uZW50cz4KICAgIDwvQ29tcG9uZW50PgogICAgPENvbXBvbmVudD4KICAgICAgPE5hbWU+Q0xJIEludGVyZmFjZTwvTmFtZT4KICAgICAgPFB1cnBvc2U+VXNlciBpbnRlcmFjdGlvbiBsYXllcjwvUHVycG9zZT4KICAgICAgPFJlc3BvbnNpYmlsaXRpZXM+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PkNvbnRleHQgbWFuYWdlbWVudDwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PlByb3RvY29sIG1hbmFnZW1lbnQ8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5NQ1Agc2VydmVyIG1hbmFnZW1lbnQ8L1Jlc3BvbnNpYmlsaXR5PgogICAgICA8L1Jlc3BvbnNpYmlsaXRpZXM+CiAgICA8L0NvbXBvbmVudD4KICA8L0NvcmVDb21wb25lbnRzPgogIDxEZXZlbG9wbWVudFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5UZXN0aW5nIFN0cmF0ZWd5PC9OYW1lPgogICAgICA8RGV0YWlsPlVuaXQgdGVzdHMgZm9yIGVhY2ggY29tcG9uZW50PC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+SW50ZWdyYXRpb24gdGVzdHMgZm9yIGNvbXBvbmVudCBpbnRlcmFjdGlvbjwvRGV0YWlsPgogICAgICA8RGV0YWlsPkVuZC10by1lbmQgdGVzdHMgZm9yIENMSSBvcGVyYXRpb25zPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+TW9jayBleHRlcm5hbCBkZXBlbmRlbmNpZXM8L0RldGFpbD4KICAgICAgPERldGFpbD5UZXN0IGNvdmVyYWdlIHJlcXVpcmVtZW50czogODAlIG1pbmltdW08L0RldGFpbD4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+Q29kZSBRdWFsaXR5PC9OYW1lPgogICAgICA8RGV0YWlsPlR5cGUgaGludHMgdGhyb3VnaG91dDwvRGV0YWlsPgogICAgICA8RGV0YWlsPkNvbXByZWhlbnNpdmUgZG9jdW1lbnRhdGlvbjwvRGV0YWlsPgogICAgICA8RGV0YWlsPkVycm9yIGhhbmRsaW5nIHdpdGggcHJvcGVyIGxvZ2dpbmc8L0RldGFpbD4KICAgICAgPERldGFpbD5DbGVhbiBjb2RlIHByaW5jaXBsZXM8L0RldGFpbD4KICAgICAgPERldGFpbD5LSVNTIChLZWVwIEl0IFNpbXBsZSwgU3R1cGlkKSBhcHByb2FjaDwvRGV0YWlsPgogICAgPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5Db25maWd1cmF0aW9uIE1hbmFnZW1lbnQ8L05hbWU+CiAgICAgIDxEZXRhaWw+Q2VudHJhbGl6ZWQgcGF0aCBtYW5hZ2VtZW50PC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+RW52aXJvbm1lbnQgdmFyaWFibGUgaGFuZGxpbmc8L0RldGFpbD4KICAgICAgPERldGFpbD5ObyBoYXJkY29kZWQgdmFsdWVzPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+Q29uZmlndXJhdGlvbiB2YWxpZGF0aW9uPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+SURFIGVudmlyb25tZW50IGRldGVjdGlvbjwvRGV0YWlsPgogICAgPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5FcnJvciBIYW5kbGluZzwvTmFtZT4KICAgICAgPERldGFpbD5HcmFjZWZ1bCBkZWdyYWRhdGlvbjwvRGV0YWlsPgogICAgICA8RGV0YWlsPkRldGFpbGVkIGVycm9yIGxvZ2dpbmc8L0RldGFpbD4KICAgICAgPERldGFpbD5Vc2VyLWZyaWVuZGx5IGVycm9yIG1lc3NhZ2VzPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+UmVjb3ZlcnkgbWVjaGFuaXNtczwvRGV0YWlsPgogICAgPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5EYXRhIE1vZGVsaW5nPC9OYW1lPgogICAgICA8RGV0YWlsPlVzZSBQeWRhbnRpYyBtb2RlbHMgZm9yIHNlcmlhbGl6YWJsZSBkYXRhIHN0cnVjdHVyZXM8L0RldGFpbD4KICAgICAgPERldGFpbD5Vc2UgTmFtZWRUdXBsZSBmb3Igc2ltcGxlLCBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmVzPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+TW9kZXJuIHR5cGUgaGludHMgKGxvd2VyY2FzZSBsaXN0LCBkaWN0LCB8IGZvciB1bmlvbik8L0RldGFpbD4KICAgICAgPERldGFpbD5UeXBlIHNhZmV0eSB0aHJvdWdob3V0IHRoZSBjb2RlYmFzZTwvRGV0YWlsPgogICAgPC9QcmluY2lwbGU+CiAgPC9EZXZlbG9wbWVudFByaW5jaXBsZXM+CiAgPFJlcXVpcmVtZW50cz4KICAgIDxSZXF1aXJlbWVudD4KICAgICAgPE5hbWU+bmFubyAodGV4dCBlZGl0b3IpPC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+VGhlIENMSSB1c2VzICduYW5vJyBhcyB0aGUgZGVmYXVsdCBlZGl0b3IgZm9yIGVkaXRpbmcgY29udGV4dCBmaWxlcy4gVXNlcnMgbWF5IHNldCBhIGRpZmZlcmVudCBlZGl0b3IgYnkgY29uZmlndXJpbmcgdGhlIEVESVRPUiBlbnZpcm9ubWVudCB2YXJpYWJsZS48L0Rlc2NyaXB0aW9uPgogICAgPC9SZXF1aXJlbWVudD4KICA8L1JlcXVpcmVtZW50cz4KICA8RGVwZW5kZW5jaWVzPgogICAgPERlcGVuZGVuY3k+UHl0aG9uIDMuOCs8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5sb2d1cnU8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5tb2RlbGNvbnRleHRwcm90b2NvbC9weXRob24tc2RrIHwgbWNwW2NsaV08L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5weXRlc3QgKHRlc3RpbmcpPC9EZXBlbmRlbmN5PgogICAgPERlcGVuZGVuY3k+dHlwZXIgKENMSSk8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT53YXRjaGRvZyAoZmlsZSBtb25pdG9yaW5nKTwvRGVwZW5kZW5jeT4KICA8L0RlcGVuZGVuY2llcz4KICA8RGlyZWN0b3J5U3RydWN0dXJlPgogICAgPERpcmVjdG9yeT4KICAgICAgPFBhdGg+ZXJhc211cy88L1BhdGg+CiAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgPFBhdGg+LmVyYXNtdXMvPC9QYXRoPgogICAgICAgIDxEZXNjcmlwdGlvbj5MaWJyYXJ5IHdvcmtpbmcgZmlsZXM8L0Rlc2NyaXB0aW9uPgogICAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgICA8UGF0aD5wcm90b2NvbC88L1BhdGg+CiAgICAgICAgICA8RGVzY3JpcHRpb24+UHJvdG9jb2wgZGVmaW5pdGlvbnM8L0Rlc2NyaXB0aW9uPgogICAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgICA8UGF0aD5jb250ZXh0LzwvUGF0aD4KICAgICAgICAgIDxEZXNjcmlwdGlvbj5Db250ZXh0IEZvbGRlcnM8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgICAgPFBhdGg+e2NvbnRleHRfbmFtZX0vPC9QYXRoPgogICAgICAgICAgICA8RGVzY3JpcHRpb24+TGFiZWxlZCBieSBuYW1lPC9EZXNjcmlwdGlvbj4KICAgICAgICAgICAgPEZpbGU+CiAgICAgICAgICAgICAgPE5hbWU+Y3R4LmFyY2hpdGVjdHVyZS5tZDwvTmFtZT4KICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+QXJjaGl0ZWN0dXJlIGRvYzwvRGVzY3JpcHRpb24+CiAgICAgICAgICAgIDwvRmlsZT4KICAgICAgICAgICAgPEZpbGU+CiAgICAgICAgICAgICAgPE5hbWU+Y3R4LnByb2dyZXNzLm1kPC9OYW1lPgogICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Qcm9ncmVzcyBkb2M8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgICA8L0ZpbGU+CiAgICAgICAgICAgIDxGaWxlPgogICAgICAgICAgICAgIDxOYW1lPmN0eC50YXNrcy5tZDwvTmFtZT4KICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+VGFza3MgZG9jPC9EZXNjcmlwdGlvbj4KICAgICAgICAgICAgPC9GaWxlPgogICAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICA8U3ViRGlyZWN0b3J5PgogICAgICAgIDxQYXRoPnNyYy88L1BhdGg+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPm1vbml0b3IvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkZpbGUgbW9uaXRvcmluZzwvRGVzY3JpcHRpb24+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPmNvbnRleHQvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkNvbnRleHQgbWFuYWdlbWVudDwvRGVzY3JpcHRpb24+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPnByb3RvY29sLzwvUGF0aD4KICAgICAgICAgIDxEZXNjcmlwdGlvbj5Qcm90b2NvbCBoYW5kbGluZzwvRGVzY3JpcHRpb24+CiAgICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICAgIDxQYXRoPmxvZ2dpbmcvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkxvZ2dpbmcgc3lzdGVtPC9EZXNjcmlwdGlvbj4KICAgICAgICA8L1N1YkRpcmVjdG9yeT4KICAgICAgICA8U3ViRGlyZWN0b3J5PgogICAgICAgICAgPFBhdGg+bWNwLzwvUGF0aD4KICAgICAgICAgIDxEZXNjcmlwdGlvbj5NQ1AgaW50ZWdyYXRpb248L0Rlc2NyaXB0aW9uPgogICAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICAgIDxTdWJEaXJlY3Rvcnk+CiAgICAgICAgICA8UGF0aD5jbGkvPC9QYXRoPgogICAgICAgICAgPERlc2NyaXB0aW9uPkNvbW1hbmQgbGluZSBpbnRlcmZhY2U8L0Rlc2NyaXB0aW9uPgogICAgICAgIDwvU3ViRGlyZWN0b3J5PgogICAgICA8L1N1YkRpcmVjdG9yeT4KICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICA8UGF0aD50ZXN0cy88L1BhdGg+CiAgICAgICAgPERlc2NyaXB0aW9uPlRlc3Qgc3VpdGU8L0Rlc2NyaXB0aW9uPgogICAgICA8L1N1YkRpcmVjdG9yeT4KICAgICAgPFN1YkRpcmVjdG9yeT4KICAgICAgICA8UGF0aD5jb25maWcvPC9QYXRoPgogICAgICAgIDxEZXNjcmlwdGlvbj5Db25maWd1cmF0aW9uIGZpbGVzPC9EZXNjcmlwdGlvbj4KICAgICAgPC9TdWJEaXJlY3Rvcnk+CiAgICAgIDxGaWxlPgogICAgICAgIDxOYW1lPi5jdXJzb3JydWxlcyB8IC53aW5kc3VyZnJ1bGVzPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5SdWxlcyBmaWxlIGFuZCBpbmplY3RlZCBjb250ZXh0PC9EZXNjcmlwdGlvbj4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LmFyY2hpdGVjdHVyZS54bWw8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPk1vbml0b3JlZCBkZXNpZ24gZG9jPC9EZXNjcmlwdGlvbj4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LnByb2dyZXNzLnhtbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TW9uaXRvcmVkIGRldmVsb3BtZW50IHNjaGVkdWxlPC9EZXNjcmlwdGlvbj4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LnRhc2tzLnhtbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TW9uaXRvcmVkIHRhc2sgbGlzdDwvRGVzY3JpcHRpb24+CiAgICAgIDwvRmlsZT4KICAgIDwvRGlyZWN0b3J5PgogIDwvRGlyZWN0b3J5U3RydWN0dXJlPgogIDxEZXZlbG9wbWVudFdvcmtmbG93PgogICAgPFN0ZXA+Q29tcG9uZW50IHNlbGVjdGlvbiBmcm9tIFBST0dSRVNTLm1kPC9TdGVwPgogICAgPFN0ZXA+VGFzayBicmVha2Rvd24gaW4gVEFTS1MubWQ8L1N0ZXA+CiAgICA8U3RlcD5UZXN0LWRyaXZlbiBkZXZlbG9wbWVudDwvU3RlcD4KICAgIDxTdGVwPkNvZGUgcmV2aWV3PC9TdGVwPgogICAgPFN0ZXA+SW50ZWdyYXRpb24gdGVzdGluZzwvU3RlcD4KICAgIDxTdGVwPkRvY3VtZW50YXRpb24gdXBkYXRlPC9TdGVwPiAKICA8L0RldmVsb3BtZW50V29ya2Zsb3c+IAogIDxEZXNpZ25Db25zaWRlcmF0aW9ucz4KICAgIDxJdGVtPlVzZSBjbGVhciBuYW1pbmcgY29udmVudGlvbnMgZm9yIGFsbCBwYXRoIGFuZCBjb250ZW50IGFjY2Vzc29yczo8L0l0ZW0+CiAgICA8SXRlbT5NZXRob2RzIHRoYXQgcmV0dXJuIGEgcGF0aCBzaG91bGQgdXNlIHRoZSA8Y29kZT5fcGF0aDwvY29kZT4gc3VmZml4IChlLmcuLCA8Y29kZT5nZXRfY29udGV4dF9kaXJfcGF0aDwvY29kZT4pLCBhbmQgbWV0aG9kcyB0aGF0IHJldHVybiBjb250ZW50IHNob3VsZCB1c2UgdGhlIDxjb2RlPl9jb250ZW50PC9jb2RlPiBzdWZmaXguIFRoaXMgZW5zdXJlcyBjbGFyaXR5IGFuZCBtYWludGFpbmFiaWxpdHkgdGhyb3VnaG91dCB0aGUgY29kZWJhc2UuPC9JdGVtPgogIDwvRGVzaWduQ29uc2lkZXJhdGlvbnM+CjwvQXJjaGl0ZWN0dXJlPiAgIA=='
    embedded['.erasmus/context/testctx/ctx.progress.xml'] = 'PFByb2dyZXNzPjwvUHJvZ3Jlc3M+'
    embedded['.erasmus/context/testctx/ctx.tasks.xml'] = 'PFRhc2tzPjwvVGFza3M+'
    embedded['.erasmus/context/Erasmus_Packager/ctx.progress.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFByb2dyZXNzPgogIDxQaGFzZSBuYW1lPSJQYWNrYWdlciBEZXZlbG9wbWVudCI+CiAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICA8VGFza3M+CiAgICAgIDxUYXNrIG5hbWU9IkZpeCBJbXBvcnQgSGFuZGxpbmciPgogICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICA8U3VidGFzayBuYW1lPSJGaXggYnVpbGRfc2NyaXB0IGZ1bmN0aW9uIj4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPE5vdGVzPkZpeGVkIHRoZSBidWlsZF9zY3JpcHQgZnVuY3Rpb24gdG8gcHJvcGVybHkgZm9ybWF0IGltcG9ydHMgd2l0aCB0aGUgJ2ltcG9ydCcga2V5d29yZCBhbmQgaGFuZGxlIGltcG9ydHMgd2l0aCBkb3RzIGNvcnJlY3RseS48L05vdGVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iSGFuZGxlIHNwZWNpYWwgY2FzZXMiPgogICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICA8Tm90ZXM+QWRkZWQgc3BlY2lhbCBjYXNlIGhhbmRsaW5nIGZvciB0aW1laXQgbW9kdWxlLjwvTm90ZXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzayBuYW1lPSJSZW1vdmUgcmVsYXRpdmUgaW1wb3J0cyI+CiAgICAgICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICAgICAgPE5vdGVzPkF0dGVtcHRlZCB0byByZW1vdmUgcmVsYXRpdmUgaW1wb3J0cyBmcm9tIHRoZSBnZW5lcmF0ZWQgc2NyaXB0IHNpbmNlIHRoZXkncmUgbm90IG5lZWRlZCB3aGVuIGFsbCBjb2RlIGlzIGNvbWJpbmVkLiBTdGlsbCBlbmNvdW50ZXJpbmcgaXNzdWVzLjwvTm90ZXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPC9UYXNrPgogICAgICA8VGFzayBuYW1lPSJGaXggRmlsZSBQcm9jZXNzaW5nIj4KICAgICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iRml4IE5vbi1QeXRob24gRmlsZSBIYW5kbGluZyI+CiAgICAgICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICAgICAgPERlc2NyaXB0aW9uPlBhY2thZ2VyIGlzIHRyeWluZyB0byBwYXJzZSBub24tUHl0aG9uIGZpbGVzIGFzIFB5dGhvbiBmaWxlczwvRGVzY3JpcHRpb24+CiAgICAgICAgICAgIDxBdHRlbXB0cz4KICAgICAgICAgICAgICA8QXR0ZW1wdD4KICAgICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgICAgICA8QWN0aW9uPkFkZGVkIGZpbGUgZXh0ZW5zaW9uIGNoZWNrIGluIHBhcnNlX2ltcG9ydHM8L0FjdGlvbj4KICAgICAgICAgICAgICAgIDxSZXN1bHQ+SW1wcm92ZWQgYnV0IHN0aWxsIHNlZWluZyBzb21lIG5vbi1QeXRob24gZmlsZXMgYmVpbmcgcHJvY2Vzc2VkPC9SZXN1bHQ+CiAgICAgICAgICAgICAgPC9BdHRlbXB0PgogICAgICAgICAgICAgIDxBdHRlbXB0PgogICAgICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgICAgICAgIDxBY3Rpb24+QWRkZWQgYmV0dGVyIGZpbGUgZmlsdGVyaW5nIGluIGdlbmVyYXRlX3NjcmlwdDwvQWN0aW9uPgogICAgICAgICAgICAgICAgPFJlc3VsdD5TdGlsbCBzZWVpbmcgc29tZSBjb250ZW50IGJlaW5nIHRyZWF0ZWQgYXMgZmlsZSBwYXRoczwvUmVzdWx0PgogICAgICAgICAgICAgIDwvQXR0ZW1wdD4KICAgICAgICAgICAgPC9BdHRlbXB0cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9IkZpeCBzeXMuX19maWxlX18gQWNjZXNzIj4KICAgICAgICAgICAgPFN0YXR1cz5JbiBQcm9ncmVzczwvU3RhdHVzPgogICAgICAgICAgICA8RGVzY3JpcHRpb24+RXJyb3Igd2hlbiB0cnlpbmcgdG8gYWNjZXNzIHN5cy5fX2ZpbGVfXyBkdXJpbmcgaW1wb3J0IHByb2Nlc3Npbmc8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgICA8QXR0ZW1wdHM+CiAgICAgICAgICAgICAgPEF0dGVtcHQ+CiAgICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICAgICAgPEFjdGlvbj5BZGRlZCBiZXR0ZXIgZXJyb3IgaGFuZGxpbmcgaW4gcGFyc2VfaW1wb3J0czwvQWN0aW9uPgogICAgICAgICAgICAgICAgPFJlc3VsdD5FcnJvciBpcyBjYXVnaHQgYnV0IG5lZWQgdG8gcHJvcGVybHkgaGFuZGxlIHRoZSBjYXNlPC9SZXN1bHQ+CiAgICAgICAgICAgICAgPC9BdHRlbXB0PgogICAgICAgICAgICA8L0F0dGVtcHRzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iRml4IENvbnRlbnQgdnMgUGF0aCBIYW5kbGluZyI+CiAgICAgICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICAgICAgPERlc2NyaXB0aW9uPlNvbWUgZmlsZSBjb250ZW50IGlzIGJlaW5nIHRyZWF0ZWQgYXMgZmlsZSBwYXRocyBkdXJpbmcgcHJvY2Vzc2luZzwvRGVzY3JpcHRpb24+CiAgICAgICAgICAgIDxBdHRlbXB0cz4KICAgICAgICAgICAgICA8QXR0ZW1wdD4KICAgICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgICAgICA8QWN0aW9uPkFkZGVkIHZhbGlkYXRpb24gaW4gcGFyc2VfaW1wb3J0cyB0byBlbnN1cmUgd2UncmUgd29ya2luZyB3aXRoIGFjdHVhbCBmaWxlczwvQWN0aW9uPgogICAgICAgICAgICAgICAgPFJlc3VsdD5TdGlsbCBzZWVpbmcgc29tZSBjb250ZW50IGJlaW5nIHByb2Nlc3NlZCBhcyBwYXRoczwvUmVzdWx0PgogICAgICAgICAgICAgIDwvQXR0ZW1wdD4KICAgICAgICAgICAgICA8QXR0ZW1wdD4KICAgICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgICAgICA8QWN0aW9uPkFkZGVkIGJldHRlciBlcnJvciBoYW5kbGluZyBpbiBleHRyYWN0X2NvZGVfYm9keTwvQWN0aW9uPgogICAgICAgICAgICAgICAgPFJlc3VsdD5JbXByb3ZlZCBidXQgc3RpbGwgc2VlaW5nIHNvbWUgaXNzdWVzPC9SZXN1bHQ+CiAgICAgICAgICAgICAgPC9BdHRlbXB0PgogICAgICAgICAgICA8L0F0dGVtcHRzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDwvU3VidGFza3M+CiAgICAgIDwvVGFzaz4KICAgICAgPFRhc2sgbmFtZT0iRXJyb3IgVHJhY2tpbmciPgogICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICA8U3VidGFzayBuYW1lPSJEb2N1bWVudCBpbXBvcnQgZXJyb3JzIj4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPE5vdGVzPkZpeGVkIGVycm9yOiAnSW1wb3J0U2V0JyBvYmplY3QgaGFzIG5vIGF0dHJpYnV0ZSAndXBkYXRlJzwvTm90ZXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzayBuYW1lPSJEb2N1bWVudCBzeW50YXggZXJyb3JzIj4KICAgICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPE5vdGVzPkZpeGVkIGVycm9yOiBJbnZhbGlkIHN5bnRheCBpbiBnZW5lcmF0ZWQgc2NyaXB0IGR1ZSB0byBpbmNvcnJlY3QgaW1wb3J0IGZvcm1hdHRpbmc8L05vdGVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iRG9jdW1lbnQgcmVsYXRpdmUgaW1wb3J0IGlzc3VlcyI+CiAgICAgICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICAgICAgPE5vdGVzPlN0aWxsIGVuY291bnRlcmluZyBpc3N1ZXMgd2l0aCByZWxhdGl2ZSBpbXBvcnRzLiBFcnJvcjogIkltcG9ydEVycm9yOiBjYW5ub3QgaW1wb3J0IG5hbWUgJ2xvZ2dpbmcnIGZyb20gJ3V0aWxzJyIgLSB0aGlzIHN1Z2dlc3RzIHRoYXQgYSByZWxhdGl2ZSBpbXBvcnQgaXMgYmVpbmcgaW5jb3JyZWN0bHkgcHJvY2Vzc2VkLjwvTm90ZXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPC9UYXNrPgogICAgICA8VGFzayBuYW1lPSJSZWxhdGl2ZSBJbXBvcnQgSGFuZGxpbmciPgogICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICA8U3VidGFzayBuYW1lPSJGaXJzdCBhdHRlbXB0Ij4KICAgICAgICAgICAgPFN0YXR1cz5GYWlsZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPE5vdGVzPlRyaWVkIHRvIHJlbW92ZSByZWxhdGl2ZSBpbXBvcnRzIHNlY3Rpb24gZnJvbSBidWlsZF9zY3JpcHQgZnVuY3Rpb24uPC9Ob3Rlcz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9IlNlY29uZCBhdHRlbXB0Ij4KICAgICAgICAgICAgPFN0YXR1cz5GYWlsZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPE5vdGVzPlRyaWVkIHRvIGZpbHRlciBvdXQgcmVsYXRpdmUgaW1wb3J0cyBpbiB0aGUgcGFja2FnZSBmdW5jdGlvbi48L05vdGVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iVGhpcmQgYXR0ZW1wdCI+CiAgICAgICAgICAgIDxTdGF0dXM+RmFpbGVkPC9TdGF0dXM+CiAgICAgICAgICAgIDxOb3Rlcz5UcmllZCB0byBtb2RpZnkgdGhlIEltcG9ydFZpc2l0b3IgdG8gbm90IGNvbGxlY3QgcmVsYXRpdmUgaW1wb3J0cy48L05vdGVzPgogICAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iRm91cnRoIGF0dGVtcHQiPgogICAgICAgICAgICA8U3RhdHVzPkZhaWxlZDwvU3RhdHVzPgogICAgICAgICAgICA8Tm90ZXM+UmVtb3ZlZCByZWxhdGl2ZSBpbXBvcnRzIHNlY3Rpb24gZnJvbSBidWlsZF9zY3JpcHQgZnVuY3Rpb24gYWdhaW4sIGJ1dCBzdGlsbCBlbmNvdW50ZXJpbmcgaXNzdWVzLjwvTm90ZXM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgICA8U3VidGFzayBuYW1lPSJOZXh0IGF0dGVtcHQiPgogICAgICAgICAgICA8U3RhdHVzPlBsYW5uZWQ8L1N0YXR1cz4KICAgICAgICAgICAgPE5vdGVzPk5lZWQgdG8gaW52ZXN0aWdhdGUgd2hlcmUgcmVsYXRpdmUgaW1wb3J0cyBhcmUgYmVpbmcgY29sbGVjdGVkIGFuZCBlbnN1cmUgdGhleSdyZSBwcm9wZXJseSBmaWx0ZXJlZCBvdXQgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byBidWlsZF9zY3JpcHQuPC9Ob3Rlcz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8L1N1YnRhc2tzPgogICAgICA8L1Rhc2s+CiAgICA8L1Rhc2tzPgogIDwvUGhhc2U+CiAgCiAgPFBoYXNlIG5hbWU9IlBhY2thZ2luZyI+CiAgICA8U3RhdHVzPk1vc3RseSBDb21wbGV0ZTwvU3RhdHVzPgogICAgPFRhc2tzPgogICAgICA8VGFzayBuYW1lPSJGaXggU2NyaXB0IFBhY2thZ2luZyI+CiAgICAgICAgPFN0YXR1cz5JbiBQcm9ncmVzczwvU3RhdHVzPgogICAgICAgIDxEZXNjcmlwdGlvbj5Jc3N1ZXMgZGlzY292ZXJlZCBpbiB0aGUgc2NyaXB0IHBhY2thZ2luZyBwcm9jZXNzIHRoYXQgbmVlZCB0byBiZSBhZGRyZXNzZWQ8L0Rlc2NyaXB0aW9uPgogICAgICAgIDxTdWJ0YXNrcz4KICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9IkZpeCBEdXBsaWNhdGUgQ29kZSBTZWN0aW9ucyI+CiAgICAgICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICAgICAgPERlc2NyaXB0aW9uPlBhY2thZ2VyIGlzIG5vdCBwcm9wZXJseSBoYW5kbGluZyBkdXBsaWNhdGUgY29kZSBzZWN0aW9ucyB3aGVuIG1lcmdpbmcgZmlsZXMsIGxlYWRpbmcgdG8gcmVkdW5kYW50IGNvZGUgaW4gdGhlIG91dHB1dDwvRGVzY3JpcHRpb24+CiAgICAgICAgICAgIDxBdHRlbXB0cz4KICAgICAgICAgICAgICA8QXR0ZW1wdD4KICAgICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgICAgICA8QWN0aW9uPkFkZGVkIGhhc2gtYmFzZWQgdHJhY2tpbmcgb2YgY29kZSBzZWN0aW9uczwvQWN0aW9uPgogICAgICAgICAgICAgICAgPFJlc3VsdD5JbXByb3ZlZCBidXQgc3RpbGwgc2VlaW5nIHNvbWUgZHVwbGljYXRlczwvUmVzdWx0PgogICAgICAgICAgICAgIDwvQXR0ZW1wdD4KICAgICAgICAgICAgPC9BdHRlbXB0cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9IkZpeCBJbXBvcnQgVHJhY2tpbmciPgogICAgICAgICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5QYWNrYWdlciBpcyBub3QgcHJvcGVybHkgdHJhY2tpbmcgd2hpY2ggaW1wb3J0cyBoYXZlIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQsIGxlYWRpbmcgdG8gZHVwbGljYXRlIGltcG9ydHM8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgICA8QXR0ZW1wdHM+CiAgICAgICAgICAgICAgPEF0dGVtcHQ+CiAgICAgICAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgICAgICAgPEFjdGlvbj5BZGRlZCBzZWVuX2ltcG9ydHMgdHJhY2tpbmcgaW4gZm9ybWF0X2ltcG9ydHM8L0FjdGlvbj4KICAgICAgICAgICAgICAgIDxSZXN1bHQ+QmV0dGVyIGltcG9ydCBkZWR1cGxpY2F0aW9uIGJ1dCBzdGlsbCBzb21lIGlzc3VlczwvUmVzdWx0PgogICAgICAgICAgICAgIDwvQXR0ZW1wdD4KICAgICAgICAgICAgPC9BdHRlbXB0cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9IkZpeCBEZXBlbmRlbmN5IE9yZGVyaW5nIj4KICAgICAgICAgICAgPFN0YXR1cz5JbiBQcm9ncmVzczwvU3RhdHVzPgogICAgICAgICAgICA8RGVzY3JpcHRpb24+UGFja2FnZXIgaXMgbm90IG1haW50YWluaW5nIHByb3BlciBkZXBlbmRlbmN5IG9yZGVyIHdoZW4gbWVyZ2luZyBmaWxlcywgd2hpY2ggY291bGQgbGVhZCB0byB1bmRlZmluZWQgcmVmZXJlbmNlczwvRGVzY3JpcHRpb24+CiAgICAgICAgICAgIDxBdHRlbXB0cz4KICAgICAgICAgICAgICA8QXR0ZW1wdD4KICAgICAgICAgICAgICAgIDxTdGF0dXM+Q29tcGxldGVkPC9TdGF0dXM+CiAgICAgICAgICAgICAgICA8QWN0aW9uPkFkZGVkIGRlcGVuZGVuY3kgYW5hbHlzaXMgYW5kIG9yZGVyaW5nIGluIGdlbmVyYXRlX3NjcmlwdDwvQWN0aW9uPgogICAgICAgICAgICAgICAgPFJlc3VsdD5CZXR0ZXIgb3JkZXJpbmcgYnV0IHN0aWxsIHNvbWUgZGVwZW5kZW5jeSBpc3N1ZXM8L1Jlc3VsdD4KICAgICAgICAgICAgICA8L0F0dGVtcHQ+CiAgICAgICAgICAgIDwvQXR0ZW1wdHM+CiAgICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPC9UYXNrPgogICAgPC9UYXNrcz4KICA8L1BoYXNlPgogIAogIDxDdXJyZW50Rm9jdXM+CiAgICA8UGhhc2U+UGFja2FnZXIgRGV2ZWxvcG1lbnQ8L1BoYXNlPgogICAgPFByaW9yaXR5PkhpZ2g8L1ByaW9yaXR5PgogICAgPE5leHRUYXNrPkZpeCBOb24tUHl0aG9uIEZpbGUgSGFuZGxpbmc8L05leHRUYXNrPgogIDwvQ3VycmVudEZvY3VzPgogIAogIDxOb3Rlcz4KICAgIDxOb3RlPkZpeGVkIHNldmVyYWwgaXNzdWVzIHdpdGggdGhlIHBhY2thZ2VyJ3MgaW1wb3J0IGhhbmRsaW5nLCBpbmNsdWRpbmcgcHJvcGVyIGZvcm1hdHRpbmcgb2YgaW1wb3J0cyB3aXRoIGRvdHMgYW5kIHNwZWNpYWwgY2FzZSBoYW5kbGluZyBmb3IgdGltZWl0LjwvTm90ZT4KICAgIDxOb3RlPlN0aWxsIGVuY291bnRlcmluZyBpc3N1ZXMgd2l0aCByZWxhdGl2ZSBpbXBvcnRzLiBEZXNwaXRlIG11bHRpcGxlIGF0dGVtcHRzIHRvIHJlbW92ZSB0aGVtLCB0aGV5J3JlIHN0aWxsIGJlaW5nIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWQgc2NyaXB0LCBjYXVzaW5nIGltcG9ydCBlcnJvcnMuPC9Ob3RlPgogICAgPE5vdGU+Q3VycmVudCBlcnJvcjogIkltcG9ydEVycm9yOiBjYW5ub3QgaW1wb3J0IG5hbWUgJ2xvZ2dpbmcnIGZyb20gJ3V0aWxzJyIgLSB0aGlzIHN1Z2dlc3RzIHRoYXQgYSByZWxhdGl2ZSBpbXBvcnQgaXMgYmVpbmcgaW5jb3JyZWN0bHkgcHJvY2Vzc2VkLjwvTm90ZT4KICAgIDxOb3RlPk5lZWQgdG8gaW52ZXN0aWdhdGUgd2hlcmUgcmVsYXRpdmUgaW1wb3J0cyBhcmUgYmVpbmcgY29sbGVjdGVkIGFuZCBlbnN1cmUgdGhleSdyZSBwcm9wZXJseSBmaWx0ZXJlZCBvdXQgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byBidWlsZF9zY3JpcHQuPC9Ob3RlPgogICAgPE5vdGU+SXNzdWVzIGRpc2NvdmVyZWQgaW4gYnVpbGQvMC4wLjEvZXJhc211c192MC4wLjEucHkgb3V0cHV0IGZpbGUgc2hvd2luZyBkdXBsaWNhdGUgY29kZSBzZWN0aW9ucyBhbmQgaW1wcm9wZXIgbWVyZ2luZzwvTm90ZT4KICAgIDxOb3RlPk5lZWQgdG8gaW1wcm92ZSB0aGUgcGFja2FnZXIncyBjb2RlIGhhbmRsaW5nIHRvIHByb3Blcmx5IHRyYWNrIGFuZCBtZXJnZSBjb2RlIHNlY3Rpb25zPC9Ob3RlPgogICAgPE5vdGU+TmV3IGlzc3VlOiBQYWNrYWdlciBpcyB0cnlpbmcgdG8gcGFyc2Ugbm9uLVB5dGhvbiBmaWxlcyBhbmQgY29udGVudCBhcyBQeXRob24gZmlsZXM8L05vdGU+CiAgICA8Tm90ZT5OZXcgaXNzdWU6IHN5cy5fX2ZpbGVfXyBhY2Nlc3MgZXJyb3JzIGR1cmluZyBpbXBvcnQgcHJvY2Vzc2luZzwvTm90ZT4KICAgIDxOb3RlPk5ldyBpc3N1ZTogQ29udGVudCBiZWluZyB0cmVhdGVkIGFzIGZpbGUgcGF0aHMgZHVyaW5nIHByb2Nlc3Npbmc8L05vdGU+CiAgPC9Ob3Rlcz4KPC9Qcm9ncmVzcz4g'
    embedded['.erasmus/context/Erasmus_Packager/ctx.tasks.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFRhc2tzPgogIDxDdXJyZW50VGFza3M+CiAgICA8VGFzayBuYW1lPSJGaXggUGFja2FnZXIgSW1wb3J0IEhhbmRsaW5nIj4KICAgICAgPERlc2NyaXB0aW9uPkZpeCBpc3N1ZXMgd2l0aCB0aGUgcGFja2FnZXIncyBpbXBvcnQgaGFuZGxpbmcgdG8gZW5zdXJlIGltcG9ydHMgYXJlIGNvcnJlY3RseSBmb3JtYXR0ZWQgaW4gdGhlIGdlbmVyYXRlZCBzY3JpcHQuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN1YnRhc2tzPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IkZpeCBidWlsZF9zY3JpcHQgZnVuY3Rpb24iPgogICAgICAgICAgPFN0YXR1cz5Db21wbGV0ZWQ8L1N0YXR1cz4KICAgICAgICAgIDxOb3Rlcz5VcGRhdGVkIHRoZSBidWlsZF9zY3JpcHQgZnVuY3Rpb24gdG8gcHJvcGVybHkgZm9ybWF0IGltcG9ydHMgd2l0aCB0aGUgJ2ltcG9ydCcga2V5d29yZCBhbmQgaGFuZGxlIGltcG9ydHMgd2l0aCBkb3RzIGNvcnJlY3RseS48L05vdGVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzayBuYW1lPSJIYW5kbGUgc3BlY2lhbCBjYXNlcyI+CiAgICAgICAgICA8U3RhdHVzPkNvbXBsZXRlZDwvU3RhdHVzPgogICAgICAgICAgPE5vdGVzPkFkZGVkIHNwZWNpYWwgY2FzZSBoYW5kbGluZyBmb3IgdGltZWl0IG1vZHVsZS48L05vdGVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzayBuYW1lPSJSZW1vdmUgcmVsYXRpdmUgaW1wb3J0cyI+CiAgICAgICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgICAgICA8Tm90ZXM+QXR0ZW1wdGVkIHRvIHJlbW92ZSByZWxhdGl2ZSBpbXBvcnRzIGZyb20gdGhlIGdlbmVyYXRlZCBzY3JpcHQgc2luY2UgdGhleSdyZSBub3QgbmVlZGVkIHdoZW4gYWxsIGNvZGUgaXMgY29tYmluZWQuIFN0aWxsIGVuY291bnRlcmluZyBpc3N1ZXMuPC9Ob3Rlcz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgIDwvU3VidGFza3M+CiAgICAgIDxUZXN0cz4KICAgICAgICA8VGVzdCBuYW1lPSJUZXN0IGltcG9ydCBmb3JtYXR0aW5nIj4KICAgICAgICAgIDxDb2RlPgogICAgICAgICAgICA8IVtDREFUQVsKICAgICAgICAgICAgZGVmIHRlc3RfaW1wb3J0X2Zvcm1hdHRpbmcoKToKICAgICAgICAgICAgICAgIGZyb20gcGFja2FnZXIuYnVpbGRlciBpbXBvcnQgYnVpbGRfc2NyaXB0CiAgICAgICAgICAgICAgICBmcm9tIHBhY2thZ2VyLnBhcnNlciBpbXBvcnQgSW1wb3J0U2V0CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICMgVGVzdCBzdGFuZGFyZCBsaWJyYXJ5IGltcG9ydHMKICAgICAgICAgICAgICAgIGltcG9ydHMgPSBJbXBvcnRTZXQoKQogICAgICAgICAgICAgICAgaW1wb3J0cy5zdGRsaWIuYWRkKCJvcyIpCiAgICAgICAgICAgICAgICBpbXBvcnRzLnN0ZGxpYi5hZGQoInN5cyIpCiAgICAgICAgICAgICAgICBpbXBvcnRzLnN0ZGxpYi5hZGQoImxvZ2dpbmciKQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAjIFRlc3QgdGhpcmQtcGFydHkgaW1wb3J0cwogICAgICAgICAgICAgICAgaW1wb3J0cy50aGlyZF9wYXJ0eS5hZGQoInR5cGVyIikKICAgICAgICAgICAgICAgIGltcG9ydHMudGhpcmRfcGFydHkuYWRkKCJyaWNoIikKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgIyBUZXN0IGxvY2FsIGltcG9ydHMKICAgICAgICAgICAgICAgIGltcG9ydHMubG9jYWwuYWRkKCJsb2NhbF9tb2R1bGUiKQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAjIFRlc3QgaW1wb3J0cyB3aXRoIGRvdHMKICAgICAgICAgICAgICAgIGltcG9ydHMuc3RkbGliLmFkZCgieG1sLmRvbSIpCiAgICAgICAgICAgICAgICBpbXBvcnRzLnN0ZGxpYi5hZGQoInhtbC5kb20ubWluaWRvbSIpCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICMgVGVzdCBzcGVjaWFsIGNhc2UKICAgICAgICAgICAgICAgIGltcG9ydHMuc3RkbGliLmFkZCgibG9nZ2luZy50aW1laXQiKQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBjb250ZW50ID0gInByaW50KCdIZWxsbywgd29ybGQhJykiCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIHNjcmlwdCA9IGJ1aWxkX3NjcmlwdChpbXBvcnRzLCBjb250ZW50KQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAjIENoZWNrIHRoYXQgaW1wb3J0cyBhcmUgY29ycmVjdGx5IGZvcm1hdHRlZAogICAgICAgICAgICAgICAgYXNzZXJ0ICJpbXBvcnQgb3MiIGluIHNjcmlwdAogICAgICAgICAgICAgICAgYXNzZXJ0ICJpbXBvcnQgc3lzIiBpbiBzY3JpcHQKICAgICAgICAgICAgICAgIGFzc2VydCAiaW1wb3J0IGxvZ2dpbmciIGluIHNjcmlwdAogICAgICAgICAgICAgICAgYXNzZXJ0ICJpbXBvcnQgdHlwZXIiIGluIHNjcmlwdAogICAgICAgICAgICAgICAgYXNzZXJ0ICJpbXBvcnQgcmljaCIgaW4gc2NyaXB0CiAgICAgICAgICAgICAgICBhc3NlcnQgImltcG9ydCBsb2NhbF9tb2R1bGUiIGluIHNjcmlwdAogICAgICAgICAgICAgICAgYXNzZXJ0ICJmcm9tIHhtbCBpbXBvcnQgZG9tIiBpbiBzY3JpcHQKICAgICAgICAgICAgICAgIGFzc2VydCAiZnJvbSB4bWwuZG9tIGltcG9ydCBtaW5pZG9tIiBpbiBzY3JpcHQKICAgICAgICAgICAgICAgIGFzc2VydCAiaW1wb3J0IHRpbWVpdCIgaW4gc2NyaXB0ICAjIFNwZWNpYWwgY2FzZQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAjIENoZWNrIHRoYXQgcmVsYXRpdmUgaW1wb3J0cyBhcmUgbm90IGluY2x1ZGVkCiAgICAgICAgICAgICAgICBhc3NlcnQgImZyb20gLiBpbXBvcnQiIG5vdCBpbiBzY3JpcHQKICAgICAgICAgICAgXV0+CiAgICAgICAgICA8L0NvZGU+CiAgICAgICAgPC9UZXN0PgogICAgICA8L1Rlc3RzPgogICAgPC9UYXNrPgogICAgPFRhc2sgbmFtZT0iRml4IFJlbGF0aXZlIEltcG9ydCBJc3N1ZSI+CiAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgPERlc2NyaXB0aW9uPkZpeCB0aGUgcGVyc2lzdGVudCBpc3N1ZSB3aXRoIHJlbGF0aXZlIGltcG9ydHMgYmVpbmcgaW5jb3JyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZCBzY3JpcHQuPC9EZXNjcmlwdGlvbj4KICAgICAgPFN1YnRhc2tzPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IkludmVzdGlnYXRlIGltcG9ydCBjb2xsZWN0aW9uIj4KICAgICAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgICAgIDxOb3Rlcz5OZWVkIHRvIGludmVzdGlnYXRlIHdoZXJlIHJlbGF0aXZlIGltcG9ydHMgYXJlIGJlaW5nIGNvbGxlY3RlZCBhbmQgZW5zdXJlIHRoZXkncmUgcHJvcGVybHkgZmlsdGVyZWQgb3V0IGJlZm9yZSBiZWluZyBwYXNzZWQgdG8gYnVpbGRfc2NyaXB0LjwvTm90ZXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IlJldmlldyBJbXBvcnRWaXNpdG9yIj4KICAgICAgICAgIDxTdGF0dXM+UGxhbm5lZDwvU3RhdHVzPgogICAgICAgICAgPE5vdGVzPlJldmlldyB0aGUgSW1wb3J0VmlzaXRvciBjbGFzcyB0byBlbnN1cmUgaXQncyBjb3JyZWN0bHkgaWRlbnRpZnlpbmcgYW5kIGNhdGVnb3JpemluZyByZWxhdGl2ZSBpbXBvcnRzLjwvTm90ZXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IlJldmlldyBwYWNrYWdlIGZ1bmN0aW9uIj4KICAgICAgICAgIDxTdGF0dXM+UGxhbm5lZDwvU3RhdHVzPgogICAgICAgICAgPE5vdGVzPlJldmlldyB0aGUgcGFja2FnZSBmdW5jdGlvbiB0byBlbnN1cmUgaXQncyBjb3JyZWN0bHkgZmlsdGVyaW5nIG91dCByZWxhdGl2ZSBpbXBvcnRzIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gYnVpbGRfc2NyaXB0LjwvTm90ZXM+CiAgICAgICAgPC9TdWJ0YXNrPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IkFkZCBkZWJ1ZyBsb2dnaW5nIj4KICAgICAgICAgIDxTdGF0dXM+UGxhbm5lZDwvU3RhdHVzPgogICAgICAgICAgPE5vdGVzPkFkZCBkZWJ1ZyBsb2dnaW5nIHRvIHRyYWNrIGhvdyBpbXBvcnRzIGFyZSBiZWluZyBjb2xsZWN0ZWQgYW5kIHByb2Nlc3NlZC48L05vdGVzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPFRlc3RzPgogICAgICAgIDxUZXN0IG5hbWU9IlRlc3QgcmVsYXRpdmUgaW1wb3J0IGhhbmRsaW5nIj4KICAgICAgICAgIDxDb2RlPgogICAgICAgICAgICA8IVtDREFUQVsKICAgICAgICAgICAgZGVmIHRlc3RfcmVsYXRpdmVfaW1wb3J0X2hhbmRsaW5nKCk6CiAgICAgICAgICAgICAgICBmcm9tIHBhY2thZ2VyLnBhcnNlciBpbXBvcnQgSW1wb3J0VmlzaXRvcgogICAgICAgICAgICAgICAgZnJvbSBwYWNrYWdlci5idWlsZGVyIGltcG9ydCBidWlsZF9zY3JpcHQKICAgICAgICAgICAgICAgIGltcG9ydCBhc3QKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgIyBUZXN0IGNvZGUgd2l0aCByZWxhdGl2ZSBpbXBvcnRzCiAgICAgICAgICAgICAgICBjb2RlID0gIiIiCiAgICAgICAgICAgICAgICBmcm9tIC4gaW1wb3J0IG1vZHVsZQogICAgICAgICAgICAgICAgZnJvbSAuLiBpbXBvcnQgcGFyZW50X21vZHVsZQogICAgICAgICAgICAgICAgZnJvbSAuc3VibW9kdWxlIGltcG9ydCBmdW5jdGlvbgogICAgICAgICAgICAgICAgIiIiCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICMgUGFyc2UgdGhlIGNvZGUKICAgICAgICAgICAgICAgIHRyZWUgPSBhc3QucGFyc2UoY29kZSkKICAgICAgICAgICAgICAgIHZpc2l0b3IgPSBJbXBvcnRWaXNpdG9yKHNldCgpKQogICAgICAgICAgICAgICAgdmlzaXRvci52aXNpdCh0cmVlKQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAjIENoZWNrIHRoYXQgcmVsYXRpdmUgaW1wb3J0cyBhcmUgY29ycmVjdGx5IGlkZW50aWZpZWQKICAgICAgICAgICAgICAgIGFzc2VydCBsZW4odmlzaXRvci5pbXBvcnRzLnJlbGF0aXZlKSA9PSAzCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICMgVGVzdCB0aGF0IHJlbGF0aXZlIGltcG9ydHMgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgZ2VuZXJhdGVkIHNjcmlwdAogICAgICAgICAgICAgICAgY29udGVudCA9ICJwcmludCgnSGVsbG8sIHdvcmxkIScpIgogICAgICAgICAgICAgICAgc2NyaXB0ID0gYnVpbGRfc2NyaXB0KHZpc2l0b3IuaW1wb3J0cywgY29udGVudCkKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgIyBDaGVjayB0aGF0IHJlbGF0aXZlIGltcG9ydHMgYXJlIG5vdCBpbmNsdWRlZAogICAgICAgICAgICAgICAgYXNzZXJ0ICJmcm9tIC4gaW1wb3J0IiBub3QgaW4gc2NyaXB0CiAgICAgICAgICAgICAgICBhc3NlcnQgImZyb20gLi4gaW1wb3J0IiBub3QgaW4gc2NyaXB0CiAgICAgICAgICAgICAgICBhc3NlcnQgImZyb20gLnN1Ym1vZHVsZSBpbXBvcnQiIG5vdCBpbiBzY3JpcHQKICAgICAgICAgICAgXV0+CiAgICAgICAgICA8L0NvZGU+CiAgICAgICAgPC9UZXN0PgogICAgICA8L1Rlc3RzPgogICAgPC9UYXNrPgogICAgPFRhc2sgbmFtZT0iRml4IEZpbGUgUHJvY2Vzc2luZyBJc3N1ZXMiPgogICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgIDxEZXNjcmlwdGlvbj5GaXggaXNzdWVzIHdpdGggZmlsZSBwcm9jZXNzaW5nIGluIHRoZSBwYWNrYWdlcjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgPFN1YnRhc2tzPgogICAgICAgIDxTdWJ0YXNrIG5hbWU9IkZpeCBOb24tUHl0aG9uIEZpbGUgSGFuZGxpbmciPgogICAgICAgICAgPFN0YXR1cz5JbiBQcm9ncmVzczwvU3RhdHVzPgogICAgICAgICAgPERlc2NyaXB0aW9uPkZpeCBpc3N1ZXMgd2l0aCBub24tUHl0aG9uIGZpbGVzIGJlaW5nIHByb2Nlc3NlZCBhcyBQeXRob24gZmlsZXM8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgPFN0ZXBzPgogICAgICAgICAgICA8U3RlcD5BZGQgc3RyaWN0IGZpbGUgZXh0ZW5zaW9uIHZhbGlkYXRpb24gaW4gcGFyc2VfaW1wb3J0czwvU3RlcD4KICAgICAgICAgICAgPFN0ZXA+QWRkIGJldHRlciBmaWxlIGZpbHRlcmluZyBpbiBnZW5lcmF0ZV9zY3JpcHQ8L1N0ZXA+CiAgICAgICAgICAgIDxTdGVwPkFkZCB2YWxpZGF0aW9uIHRvIGVuc3VyZSBmaWxlIHBhdGhzIGFyZSBhY3R1YWwgZmlsZXM8L1N0ZXA+CiAgICAgICAgICAgIDxTdGVwPkFkZCB0ZXN0cyBmb3Igbm9uLVB5dGhvbiBmaWxlIGhhbmRsaW5nPC9TdGVwPgogICAgICAgICAgPC9TdGVwcz4KICAgICAgICAgIDxUZXN0cz4KICAgICAgICAgICAgPFRlc3QgbmFtZT0idGVzdF9ub25fcHl0aG9uX2ZpbGVfaGFuZGxpbmciPgogICAgICAgICAgICAgIDxDb2RlPgogICAgICAgICAgICAgICAgPCFbQ0RBVEFbCiAgICAgICAgICAgICAgICBkZWYgdGVzdF9ub25fcHl0aG9uX2ZpbGVfaGFuZGxpbmcoKToKICAgICAgICAgICAgICAgICAgICAjIFRlc3QgdGhhdCBub24tUHl0aG9uIGZpbGVzIGFyZSBwcm9wZXJseSBza2lwcGVkCiAgICAgICAgICAgICAgICAgICAgcGFja2FnZXIgPSBTY3JpcHRQYWNrYWdlcigpCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgIyBDcmVhdGUgdGVzdCBmaWxlcwogICAgICAgICAgICAgICAgICAgIHdpdGggdGVtcGZpbGUuVGVtcG9yYXJ5RGlyZWN0b3J5KCkgYXMgdG1wZGlyOgogICAgICAgICAgICAgICAgICAgICAgICAjIENyZWF0ZSBhIFB5dGhvbiBmaWxlCiAgICAgICAgICAgICAgICAgICAgICAgIHB5X2ZpbGUgPSBQYXRoKHRtcGRpcikgLyAidGVzdC5weSIKICAgICAgICAgICAgICAgICAgICAgICAgcHlfZmlsZS53cml0ZV90ZXh0KCJwcmludCgnaGVsbG8nKSIpCiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAjIENyZWF0ZSBhIG5vbi1QeXRob24gZmlsZQogICAgICAgICAgICAgICAgICAgICAgICB0eHRfZmlsZSA9IFBhdGgodG1wZGlyKSAvICJ0ZXN0LnR4dCIKICAgICAgICAgICAgICAgICAgICAgICAgdHh0X2ZpbGUud3JpdGVfdGV4dCgibm90IHB5dGhvbiIpCiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAjIENyZWF0ZSBhIGZpbGUgd2l0aCBQeXRob24gY29udGVudCBidXQgd3JvbmcgZXh0ZW5zaW9uCiAgICAgICAgICAgICAgICAgICAgICAgIGZha2VfcHkgPSBQYXRoKHRtcGRpcikgLyAidGVzdC5mYWtlIgogICAgICAgICAgICAgICAgICAgICAgICBmYWtlX3B5LndyaXRlX3RleHQoInByaW50KCdmYWtlJykiKQogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgIyBQYWNrYWdlIHRoZSBkaXJlY3RvcnkKICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gcGFja2FnZXIucGFja2FnZV9zY3JpcHRzKHRtcGRpcikKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICMgVmVyaWZ5IG9ubHkgUHl0aG9uIGZpbGUgd2FzIHByb2Nlc3NlZAogICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQgInByaW50KCdoZWxsbycpIiBpbiBvdXRwdXQKICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0ICJwcmludCgnZmFrZScpIiBub3QgaW4gb3V0cHV0CiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAibm90IHB5dGhvbiIgbm90IGluIG91dHB1dAogICAgICAgICAgICAgICAgXV0+CiAgICAgICAgICAgICAgPC9Db2RlPgogICAgICAgICAgICA8L1Rlc3Q+CiAgICAgICAgICA8L1Rlc3RzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzayBuYW1lPSJGaXggc3lzLl9fZmlsZV9fIEFjY2VzcyI+CiAgICAgICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgICAgICA8RGVzY3JpcHRpb24+Rml4IGlzc3VlcyB3aXRoIHN5cy5fX2ZpbGVfXyBhY2Nlc3MgZHVyaW5nIGltcG9ydCBwcm9jZXNzaW5nPC9EZXNjcmlwdGlvbj4KICAgICAgICAgIDxTdGVwcz4KICAgICAgICAgICAgPFN0ZXA+QWRkIHByb3BlciBlcnJvciBoYW5kbGluZyBmb3Igc3lzLl9fZmlsZV9fIGFjY2VzczwvU3RlcD4KICAgICAgICAgICAgPFN0ZXA+VXNlIGFsdGVybmF0aXZlIG1ldGhvZCB0byBkZXRlcm1pbmUgbW9kdWxlIHBhdGhzPC9TdGVwPgogICAgICAgICAgICA8U3RlcD5BZGQgdGVzdHMgZm9yIHN5cy5fX2ZpbGVfXyBoYW5kbGluZzwvU3RlcD4KICAgICAgICAgIDwvU3RlcHM+CiAgICAgICAgICA8VGVzdHM+CiAgICAgICAgICAgIDxUZXN0IG5hbWU9InRlc3Rfc3lzX2ZpbGVfaGFuZGxpbmciPgogICAgICAgICAgICAgIDxDb2RlPgogICAgICAgICAgICAgICAgPCFbQ0RBVEFbCiAgICAgICAgICAgICAgICBkZWYgdGVzdF9zeXNfZmlsZV9oYW5kbGluZygpOgogICAgICAgICAgICAgICAgICAgICMgVGVzdCB0aGF0IHN5cy5fX2ZpbGVfXyBhY2Nlc3MgZXJyb3JzIGFyZSBwcm9wZXJseSBoYW5kbGVkCiAgICAgICAgICAgICAgICAgICAgcGFja2FnZXIgPSBTY3JpcHRQYWNrYWdlcigpCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgIyBDcmVhdGUgdGVzdCBmaWxlIHRoYXQgdHJpZXMgdG8gYWNjZXNzIHN5cy5fX2ZpbGVfXwogICAgICAgICAgICAgICAgICAgIHdpdGggdGVtcGZpbGUuVGVtcG9yYXJ5RGlyZWN0b3J5KCkgYXMgdG1wZGlyOgogICAgICAgICAgICAgICAgICAgICAgICB0ZXN0X2ZpbGUgPSBQYXRoKHRtcGRpcikgLyAidGVzdC5weSIKICAgICAgICAgICAgICAgICAgICAgICAgdGVzdF9maWxlLndyaXRlX3RleHQoIiIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnQgc3lzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludChzeXMuX19maWxlX18pCiAgICAgICAgICAgICAgICAgICAgICAgICIiIikKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICMgUGFja2FnZSBzaG91bGQgbm90IGZhaWwKICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gcGFja2FnZXIucGFja2FnZV9zY3JpcHRzKHRlc3RfZmlsZSkKICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0ICJpbXBvcnQgc3lzIiBpbiBvdXRwdXQKICAgICAgICAgICAgICAgIF1dPgogICAgICAgICAgICAgIDwvQ29kZT4KICAgICAgICAgICAgPC9UZXN0PgogICAgICAgICAgPC9UZXN0cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2sgbmFtZT0iRml4IENvbnRlbnQgdnMgUGF0aCBIYW5kbGluZyI+CiAgICAgICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgICAgICA8RGVzY3JpcHRpb24+Rml4IGlzc3VlcyB3aXRoIGNvbnRlbnQgYmVpbmcgdHJlYXRlZCBhcyBmaWxlIHBhdGhzPC9EZXNjcmlwdGlvbj4KICAgICAgICAgIDxTdGVwcz4KICAgICAgICAgICAgPFN0ZXA+QWRkIHZhbGlkYXRpb24gdG8gZW5zdXJlIHBhdGhzIGFyZSBhY3R1YWwgZmlsZXM8L1N0ZXA+CiAgICAgICAgICAgIDxTdGVwPkFkZCB0eXBlIGNoZWNraW5nIGZvciBjb250ZW50IHZzIHBhdGhzPC9TdGVwPgogICAgICAgICAgICA8U3RlcD5BZGQgdGVzdHMgZm9yIGNvbnRlbnQgdnMgcGF0aCBoYW5kbGluZzwvU3RlcD4KICAgICAgICAgIDwvU3RlcHM+CiAgICAgICAgICA8VGVzdHM+CiAgICAgICAgICAgIDxUZXN0IG5hbWU9InRlc3RfY29udGVudF92c19wYXRoX2hhbmRsaW5nIj4KICAgICAgICAgICAgICA8Q29kZT4KICAgICAgICAgICAgICAgIDwhW0NEQVRBWwogICAgICAgICAgICAgICAgZGVmIHRlc3RfY29udGVudF92c19wYXRoX2hhbmRsaW5nKCk6CiAgICAgICAgICAgICAgICAgICAgIyBUZXN0IHRoYXQgY29udGVudCBpcyBub3QgdHJlYXRlZCBhcyBwYXRocwogICAgICAgICAgICAgICAgICAgIHBhY2thZ2VyID0gU2NyaXB0UGFja2FnZXIoKQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICMgVGVzdCB3aXRoIGFjdHVhbCBmaWxlCiAgICAgICAgICAgICAgICAgICAgd2l0aCB0ZW1wZmlsZS5UZW1wb3JhcnlEaXJlY3RvcnkoKSBhcyB0bXBkaXI6CiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RfZmlsZSA9IFBhdGgodG1wZGlyKSAvICJ0ZXN0LnB5IgogICAgICAgICAgICAgICAgICAgICAgICB0ZXN0X2ZpbGUud3JpdGVfdGV4dCgicHJpbnQoJ2hlbGxvJykiKQogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgIyBQYWNrYWdlIHdpdGggZmlsZSBwYXRoCiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDEgPSBwYWNrYWdlci5wYWNrYWdlX3NjcmlwdHModGVzdF9maWxlKQogICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQgInByaW50KCdoZWxsbycpIiBpbiBvdXRwdXQxCiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAjIFBhY2thZ2Ugd2l0aCBjb250ZW50IHN0cmluZwogICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gInByaW50KCd3b3JsZCcpIgogICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQyID0gcGFja2FnZXIucGFja2FnZV9zY3JpcHRzKGNvbnRlbnQpCiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAicHJpbnQoJ3dvcmxkJykiIGluIG91dHB1dDIKICAgICAgICAgICAgICAgIF1dPgogICAgICAgICAgICAgIDwvQ29kZT4KICAgICAgICAgICAgPC9UZXN0PgogICAgICAgICAgPC9UZXN0cz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgIDwvU3VidGFza3M+CiAgICA8L1Rhc2s+CiAgICA8VGFzayBuYW1lPSJGaXggU2NyaXB0IFBhY2thZ2luZyI+CiAgICAgIDxTdGF0dXM+SW4gUHJvZ3Jlc3M8L1N0YXR1cz4KICAgICAgPERlc2NyaXB0aW9uPkZpeCBpc3N1ZXMgaW4gdGhlIHNjcmlwdCBwYWNrYWdpbmcgcHJvY2VzcyB0byBwcm9wZXJseSBoYW5kbGUgY29kZSBtZXJnaW5nIGFuZCBkZXBlbmRlbmNpZXM8L0Rlc2NyaXB0aW9uPgogICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgIDxTdWJ0YXNrcz4KICAgICAgICA8U3VidGFzayBuYW1lPSJGaXggRHVwbGljYXRlIENvZGUgU2VjdGlvbnMiPgogICAgICAgICAgPFN0YXR1cz5JbiBQcm9ncmVzczwvU3RhdHVzPgogICAgICAgICAgPERlc2NyaXB0aW9uPk1vZGlmeSBwYWNrYWdlciB0byBwcm9wZXJseSBoYW5kbGUgZHVwbGljYXRlIGNvZGUgc2VjdGlvbnM8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgPFN0ZXBzPgogICAgICAgICAgICA8U3RlcD5JbXBsZW1lbnQgY29kZSBzZWN0aW9uIHRyYWNraW5nIGluIGJ1aWxkZXIucHk8L1N0ZXA+CiAgICAgICAgICAgIDxTdGVwPkFkZCBoYXNoLWJhc2VkIGR1cGxpY2F0ZSBkZXRlY3Rpb24gZm9yIGNvZGUgc2VjdGlvbnM8L1N0ZXA+CiAgICAgICAgICAgIDxTdGVwPk1vZGlmeSBleHRyYWN0X2NvZGVfYm9keSgpIHRvIHNraXAgYWxyZWFkeSBwcm9jZXNzZWQgc2VjdGlvbnM8L1N0ZXA+CiAgICAgICAgICAgIDxTdGVwPkFkZCB0ZXN0cyB0byB2ZXJpZnkgbm8gZHVwbGljYXRlIGNvZGUgc2VjdGlvbnMgaW4gb3V0cHV0PC9TdGVwPgogICAgICAgICAgPC9TdGVwcz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPFN1YnRhc2sgbmFtZT0iRml4IEltcG9ydCBUcmFja2luZyI+CiAgICAgICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgICAgICA8RGVzY3JpcHRpb24+SW1wcm92ZSBpbXBvcnQgdHJhY2tpbmcgYW5kIGRlZHVwbGljYXRpb248L0Rlc2NyaXB0aW9uPgogICAgICAgICAgPFN0ZXBzPgogICAgICAgICAgICA8U3RlcD5FbmhhbmNlIEltcG9ydFNldCBjbGFzcyB0byBiZXR0ZXIgdHJhY2sgcHJvY2Vzc2VkIGltcG9ydHM8L1N0ZXA+CiAgICAgICAgICAgIDxTdGVwPkFkZCBpbXBvcnQgb3JpZ2luIHRyYWNraW5nIHRvIGRldGVjdCBkdXBsaWNhdGVzPC9TdGVwPgogICAgICAgICAgICA8U3RlcD5Nb2RpZnkgZm9ybWF0X2ltcG9ydHMoKSB0byBoYW5kbGUgaW1wb3J0IGRlZHVwbGljYXRpb248L1N0ZXA+CiAgICAgICAgICAgIDxTdGVwPkFkZCB0ZXN0cyBmb3IgaW1wb3J0IGRlZHVwbGljYXRpb248L1N0ZXA+CiAgICAgICAgICA8L1N0ZXBzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgICA8U3VidGFzayBuYW1lPSJGaXggRGVwZW5kZW5jeSBPcmRlcmluZyI+CiAgICAgICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICAgICAgICA8RGVzY3JpcHRpb24+RW5zdXJlIHByb3BlciBkZXBlbmRlbmN5IG9yZGVyIGluIG1lcmdlZCBvdXRwdXQ8L0Rlc2NyaXB0aW9uPgogICAgICAgICAgPFN0ZXBzPgogICAgICAgICAgICA8U3RlcD5FbmhhbmNlIGFuYWx5emVfZGVwZW5kZW5jaWVzKCkgdG8gYnVpbGQgY29tcGxldGUgZGVwZW5kZW5jeSBncmFwaDwvU3RlcD4KICAgICAgICAgICAgPFN0ZXA+SW1wbGVtZW50IHRvcG9sb2dpY2FsIHNvcnRpbmcgZm9yIGZpbGUgb3JkZXJpbmc8L1N0ZXA+CiAgICAgICAgICAgIDxTdGVwPkFkZCBjeWNsZSBkZXRlY3Rpb24gaW4gZGVwZW5kZW5jeSByZXNvbHV0aW9uPC9TdGVwPgogICAgICAgICAgICA8U3RlcD5BZGQgdGVzdHMgZm9yIGRlcGVuZGVuY3kgb3JkZXJpbmc8L1N0ZXA+CiAgICAgICAgICA8L1N0ZXBzPgogICAgICAgIDwvU3VidGFzaz4KICAgICAgPC9TdWJ0YXNrcz4KICAgICAgPFRlc3RzPgogICAgICAgIDxUZXN0IG5hbWU9InRlc3Rfbm9fZHVwbGljYXRlX2NvZGUiPgogICAgICAgICAgPENvZGU+CiAgICAgICAgICAgIDwhW0NEQVRBWwogICAgICAgICAgICBkZWYgdGVzdF9ub19kdXBsaWNhdGVfY29kZSgpOgogICAgICAgICAgICAgICAgIyBUZXN0IHRoYXQgb3V0cHV0IGhhcyBubyBkdXBsaWNhdGUgY29kZSBzZWN0aW9ucwogICAgICAgICAgICAgICAgcGFja2FnZXIgPSBTY3JpcHRQYWNrYWdlcigpCiAgICAgICAgICAgICAgICBvdXRwdXQgPSBwYWNrYWdlci5wYWNrYWdlX3NjcmlwdHModGVzdF9maWxlcykKICAgICAgICAgICAgICAgICMgQ291bnQgb2NjdXJyZW5jZXMgb2YgZWFjaCBjb2RlIHNlY3Rpb24KICAgICAgICAgICAgICAgIHNlY3Rpb25fY291bnRzID0ge30KICAgICAgICAgICAgICAgIGZvciBzZWN0aW9uIGluIGV4dHJhY3RfY29kZV9zZWN0aW9ucyhvdXRwdXQpOgogICAgICAgICAgICAgICAgICAgIHNlY3Rpb25fY291bnRzW3NlY3Rpb25dID0gc2VjdGlvbl9jb3VudHMuZ2V0KHNlY3Rpb24sIDApICsgMQogICAgICAgICAgICAgICAgIyBBc3NlcnQgbm8gZHVwbGljYXRlcwogICAgICAgICAgICAgICAgYXNzZXJ0IGFsbChjb3VudCA9PSAxIGZvciBjb3VudCBpbiBzZWN0aW9uX2NvdW50cy52YWx1ZXMoKSkKICAgICAgICAgICAgXV0+CiAgICAgICAgICA8L0NvZGU+CiAgICAgICAgPC9UZXN0PgogICAgICAgIDxUZXN0IG5hbWU9InRlc3RfaW1wb3J0X2RlZHVwbGljYXRpb24iPgogICAgICAgICAgPENvZGU+CiAgICAgICAgICAgIDwhW0NEQVRBWwogICAgICAgICAgICBkZWYgdGVzdF9pbXBvcnRfZGVkdXBsaWNhdGlvbigpOgogICAgICAgICAgICAgICAgIyBUZXN0IHRoYXQgaW1wb3J0cyBhcmUgcHJvcGVybHkgZGVkdXBsaWNhdGVkCiAgICAgICAgICAgICAgICBwYWNrYWdlciA9IFNjcmlwdFBhY2thZ2VyKCkKICAgICAgICAgICAgICAgIG91dHB1dCA9IHBhY2thZ2VyLnBhY2thZ2Vfc2NyaXB0cyh0ZXN0X2ZpbGVzKQogICAgICAgICAgICAgICAgaW1wb3J0cyA9IGV4dHJhY3RfaW1wb3J0cyhvdXRwdXQpCiAgICAgICAgICAgICAgICAjIEFzc2VydCBubyBkdXBsaWNhdGUgaW1wb3J0cwogICAgICAgICAgICAgICAgYXNzZXJ0IGxlbihpbXBvcnRzKSA9PSBsZW4oc2V0KGltcG9ydHMpKQogICAgICAgICAgICBdXT4KICAgICAgICAgIDwvQ29kZT4KICAgICAgICA8L1Rlc3Q+CiAgICAgICAgPFRlc3QgbmFtZT0idGVzdF9kZXBlbmRlbmN5X29yZGVyIj4KICAgICAgICAgIDxDb2RlPgogICAgICAgICAgICA8IVtDREFUQVsKICAgICAgICAgICAgZGVmIHRlc3RfZGVwZW5kZW5jeV9vcmRlcigpOgogICAgICAgICAgICAgICAgIyBUZXN0IHRoYXQgZmlsZXMgYXJlIG9yZGVyZWQgYnkgZGVwZW5kZW5jaWVzCiAgICAgICAgICAgICAgICBwYWNrYWdlciA9IFNjcmlwdFBhY2thZ2VyKCkKICAgICAgICAgICAgICAgIG91dHB1dCA9IHBhY2thZ2VyLnBhY2thZ2Vfc2NyaXB0cyh0ZXN0X2ZpbGVzKQogICAgICAgICAgICAgICAgIyBFeHRyYWN0IGZpbGUgb3JkZXIKICAgICAgICAgICAgICAgIGZpbGVfb3JkZXIgPSBleHRyYWN0X2ZpbGVfb3JkZXIob3V0cHV0KQogICAgICAgICAgICAgICAgIyBBc3NlcnQgZGVwZW5kZW5jaWVzIGNvbWUgYmVmb3JlIGRlcGVuZGVudHMKICAgICAgICAgICAgICAgIGZvciBpLCBmaWxlIGluIGVudW1lcmF0ZShmaWxlX29yZGVyKToKICAgICAgICAgICAgICAgICAgICBkZXBzID0gZ2V0X2RlcGVuZGVuY2llcyhmaWxlKQogICAgICAgICAgICAgICAgICAgIGZvciBkZXAgaW4gZGVwczoKICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IGZpbGVfb3JkZXIuaW5kZXgoZGVwKSA8IGkKICAgICAgICAgICAgXV0+CiAgICAgICAgICA8L0NvZGU+CiAgICAgICAgPC9UZXN0PgogICAgICA8L1Rlc3RzPgogICAgPC9UYXNrPgogIDxUYXNrIG5hbWU9IlRlc3RpbmcgJiBWYWxpZGF0aW9uIGZvciBFZGdlIENhc2VzIj4KICAgICAgPERlc2NyaXB0aW9uPkV4cGFuZCB0ZXN0IGNvdmVyYWdlIGZvciByZWxhdGl2ZSBpbXBvcnQgaGFuZGxpbmcsIGZpbGUgdmFsaWRhdGlvbiwgYW5kIGVycm9yIGhhbmRsaW5nIGluIHRoZSBwYWNrYWdlci48L0Rlc2NyaXB0aW9uPgogICAgICA8U3RhdHVzPkluIFByb2dyZXNzPC9TdGF0dXM+CiAgICA8L1Rhc2s+CiAgPC9DdXJyZW50VGFza3M+CiAgCiAgPE5vdGU+VGhlIHBhY2thZ2VyIGlzIHN0YWJsZSBmb3IgbW9zdCB3b3JrZmxvd3MsIHdpdGggb25seSBlZGdlLWNhc2UgaW1wcm92ZW1lbnRzIGFuZCB0ZXN0cyByZW1haW5pbmcuPC9Ob3RlPgogIDxOZXh0U3RlcHM+CiAgICA8U3RlcD5JbXBsZW1lbnQgc3RyaWN0IGZpbGUgZXh0ZW5zaW9uIHZhbGlkYXRpb24gaW4gcGFyc2VfaW1wb3J0czwvU3RlcD4KICAgIDxTdGVwPkFkZCBwcm9wZXIgZXJyb3IgaGFuZGxpbmcgZm9yIHN5cy5fX2ZpbGVfXyBhY2Nlc3M8L1N0ZXA+CiAgICA8U3RlcD5BZGQgdmFsaWRhdGlvbiB0byBlbnN1cmUgcGF0aHMgYXJlIGFjdHVhbCBmaWxlczwvU3RlcD4KICA8L05leHRTdGVwcz4KPC9UYXNrcz4g'
    embedded['.erasmus/context/Erasmus_Packager/ctx.architecture.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFyY2hpdGVjdHVyZT4KICA8VGl0bGU+RXJhc211cyBQYWNrYWdlcjwvVGl0bGU+CiAgPE92ZXJ2aWV3PgogICAgPERlc2NyaXB0aW9uPgogICAgICBUaGUgRXJhc211cyBQYWNrYWdlciBpcyBhIHN0YW5kYWxvbmUgUHl0aG9uIHRvb2wgZm9yIHBhY2thZ2luZywgZGVwZW5kZW5jeSBhbmFseXNpcywgYW5kIG1hbmFnZW1lbnQuIEl0IGFuYWx5emVzIFB5dGhvbiBwcm9qZWN0cywgZXh0cmFjdHMgYW5kIGNhdGVnb3JpemVzIGltcG9ydHMsIG1hcHMgdGhlbSB0byBQeVBJIHBhY2thZ2VzLCBhbmQgcHJvZHVjZXMgYSBzaW5nbGUgZXhlY3V0YWJsZSBzY3JpcHQgd2l0aCBhIHBsYXRmb3JtLWF3YXJlIGJvb3RzdHJhcCBmb3IgZGVwZW5kZW5jeSBpbnN0YWxsYXRpb24gYW5kIGV4ZWN1dGlvbi4gVGhlIHRvb2wgaXMgZGVzaWduZWQgZm9yIGF1dG9tYXRpb24sIHJlcHJvZHVjaWJpbGl0eSwgYW5kIGNyb3NzLXBsYXRmb3JtIGNvbXBhdGliaWxpdHksIHByb3ZpZGluZyBhIHJvYnVzdCBDTEkgZm9yIGFsbCBvcGVyYXRpb25zLgogICAgPC9EZXNjcmlwdGlvbj4KICA8L092ZXJ2aWV3PgogIDxDb3JlQ29tcG9uZW50cz4KICAgIDxDb21wb25lbnQgbmFtZT0iUGFja2FnZXIiPgogICAgICA8UHVycG9zZT5BdXRvbWF0ZXMgcGFja2FnaW5nLCBkZXBlbmRlbmN5IHRyYWNraW5nLCBhbmQgc2NyaXB0IGdlbmVyYXRpb24gZm9yIFB5dGhvbiBwcm9qZWN0cy48L1B1cnBvc2U+CiAgICAgIDxSZXNwb25zaWJpbGl0aWVzPgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5SZWN1cnNpdmVseSBjb2xsZWN0IFB5dGhvbiBmaWxlcyBmcm9tIGEgZGlyZWN0b3J5LCByZXNwZWN0aW5nIGV4Y2x1c2lvbiBwYXR0ZXJucy48L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5QYXJzZSBhbmQgZXh0cmFjdCBhbGwgaW1wb3J0IGRlcGVuZGVuY2llcyBmcm9tIFB5dGhvbiBmaWxlcy48L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5EaXN0aW5ndWlzaCBiZXR3ZWVuIHN0YW5kYXJkIGxpYnJhcnksIHRoaXJkLXBhcnR5LCBhbmQgbG9jYWwgaW1wb3J0cy48L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5NYXAgaW1wb3J0IG5hbWVzIHRvIFB5UEkgcGFja2FnZSBuYW1lcywgaGFuZGxpbmcgYWxpYXNlcyBhbmQgc3BlY2lhbCBjYXNlcy48L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5CdWlsZCBhIHNpbmdsZSBzY3JpcHQgYnkgbWVyZ2luZyBjb2RlIGFuZCBpbXBvcnRzLCBub3JtYWxpemluZyBpbmRlbnRhdGlvbiBhbmQgc3RydWN0dXJlLjwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PkdlbmVyYXRlIHBsYXRmb3JtLWF3YXJlIGJvb3RzdHJhcCBzY3JpcHRzIGZvciBkZXBlbmRlbmN5IGluc3RhbGxhdGlvbiBhbmQgZXhlY3V0aW9uIHVzaW5nIHV2LjwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PlByb3ZpZGUgYSBUeXBlci1iYXNlZCBDTEkgZm9yIHBhY2thZ2luZywgZmlsZSBsaXN0aW5nLCBhbmQgdmVyc2lvbiBkaXNwbGF5LjwvUmVzcG9uc2liaWxpdHk+CiAgICAgIDwvUmVzcG9uc2liaWxpdGllcz4KICAgICAgPFRlc3RGb2N1cz4KICAgICAgICA8VGVzdD5Db3JyZWN0IGV4dHJhY3Rpb24gYW5kIGNhdGVnb3JpemF0aW9uIG9mIGltcG9ydHMgZnJvbSB2YXJpb3VzIFB5dGhvbiBmaWxlcy48U3RhdHVzPk1vc3RseSBDb21wbGV0ZTwvU3RhdHVzPjwvVGVzdD4KICAgICAgICA8VGVzdD5BY2N1cmF0ZSBtYXBwaW5nIG9mIGltcG9ydHMgdG8gUHlQSSBwYWNrYWdlcywgaW5jbHVkaW5nIGN1c3RvbSBhbmQgZGVmYXVsdCBtYXBwaW5ncy48L1Rlc3Q+CiAgICAgICAgPFRlc3Q+UHJvcGVyIGV4Y2x1c2lvbiBvZiBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgZHVyaW5nIGNvbGxlY3Rpb24uPC9UZXN0PgogICAgICAgIDxUZXN0PlN1Y2Nlc3NmdWwgcGFja2FnaW5nIG9mIG11bHRpLWZpbGUgcHJvamVjdHMgaW50byBhIHNpbmdsZSBzY3JpcHQuPC9UZXN0PgogICAgICAgIDxUZXN0PkdlbmVyYXRpb24gb2YgdmFsaWQgYW5kIGV4ZWN1dGFibGUgYm9vdHN0cmFwIHNjcmlwdHMgZm9yIGFsbCBzdXBwb3J0ZWQgcGxhdGZvcm1zLjwvVGVzdD4KICAgICAgICA8VGVzdD5DTEkgY29tbWFuZHMgZnVuY3Rpb24gYXMgZXhwZWN0ZWQgYW5kIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseS48L1Rlc3Q+CiAgICAgIDwvVGVzdEZvY3VzPgogICAgPC9Db21wb25lbnQ+CiAgPC9Db3JlQ29tcG9uZW50cz4KICAKICA8RGV2ZWxvcG1lbnRQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZSBuYW1lPSJQYWNrYWdlciBQcmluY2lwbGVzIj4KICAgICAgPERldGFpbD5GYXZvciBhdXRvbWF0aW9uIGFuZCByZXByb2R1Y2liaWxpdHkgaW4gcGFja2FnaW5nIGFuZCBkZXBlbmRlbmN5IG1hbmFnZW1lbnQuPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+RW5zdXJlIGNyb3NzLXBsYXRmb3JtIGNvbXBhdGliaWxpdHkgZm9yIGFsbCBnZW5lcmF0ZWQgc2NyaXB0cyBhbmQgYm9vdHN0cmFwcy48L0RldGFpbD4KICAgICAgPERldGFpbD5NaW5pbWl6ZSBtYW51YWwgaW50ZXJ2ZW50aW9uIGJ5IHByb3ZpZGluZyByb2J1c3QgQ0xJIHRvb2xzLjwvRGV0YWlsPgogICAgICA8RGV0YWlsPk1haW50YWluIGNsZWFyIHNlcGFyYXRpb24gYmV0d2VlbiBzdGFuZGFyZCBsaWJyYXJ5LCB0aGlyZC1wYXJ0eSwgYW5kIGxvY2FsIGRlcGVuZGVuY2llcy48L0RldGFpbD4KICAgICAgPERldGFpbD5Vc2UgdHlwZSBoaW50cywgZG9jc3RyaW5ncywgYW5kIGxvZ2dpbmcgZm9yIG1haW50YWluYWJpbGl0eSBhbmQgdHJhY2VhYmlsaXR5LjwvRGV0YWlsPgogICAgPC9QcmluY2lwbGU+CiAgPC9EZXZlbG9wbWVudFByaW5jaXBsZXM+CiAgCiAgPERlcGVuZGVuY2llcz4KICAgIDxEZXBlbmRlbmN5PnR5cGVyPC9EZXBlbmRlbmN5PgogICAgPERlcGVuZGVuY3k+cmljaDwvRGVwZW5kZW5jeT4KICAgIDxEZXBlbmRlbmN5PmFzdC1jb21tZW50czwvRGVwZW5kZW5jeT4KICAgIDxEZXBlbmRlbmN5PnBhY2thZ2luZzwvRGVwZW5kZW5jeT4KICAgIDxEZXBlbmRlbmN5PnRvbWxpPC9EZXBlbmRlbmN5PgogICAgPERlcGVuZGVuY3k+dG9tbGktdzwvRGVwZW5kZW5jeT4KICAgIDxEZXBlbmRlbmN5PnV2IChydW50aW1lLCBmb3IgYm9vdHN0cmFwcGluZyBhbmQgZGVwZW5kZW5jeSBtYW5hZ2VtZW50KTwvRGVwZW5kZW5jeT4KICA8L0RlcGVuZGVuY2llcz4KICAKICA8RGlyZWN0b3J5U3RydWN0dXJlPgogICAgPERpcmVjdG9yeSBuYW1lPSJwYWNrYWdlciI+CiAgICAgIDxGaWxlPl9faW5pdF9fLnB5PC9GaWxlPgogICAgICA8RmlsZT5fX21haW5fXy5weTwvRmlsZT4KICAgICAgPEZpbGU+YnVpbGRlci5weTwvRmlsZT4KICAgICAgPEZpbGU+Y29sbGVjdG9yLnB5PC9GaWxlPgogICAgICA8RmlsZT5tYXBwaW5nLnB5PC9GaWxlPgogICAgICA8RmlsZT5wYXJzZXIucHk8L0ZpbGU+CiAgICAgIDxGaWxlPnN0ZGxpYi5weTwvRmlsZT4KICAgICAgPEZpbGU+dXZfd3JhcHBlci5weTwvRmlsZT4KICAgICAgPEZpbGU+UkVBRE1FLm1kPC9GaWxlPgogICAgICA8RmlsZT5weXByb2plY3QudG9tbDwvRmlsZT4KICAgIDwvRGlyZWN0b3J5PgogIDwvRGlyZWN0b3J5U3RydWN0dXJlPgogIAogIDxEZXZlbG9wbWVudFdvcmtmbG93PgogICAgPFN0ZXA+Q29sbGVjdCBQeXRob24gZmlsZXMgZnJvbSB0aGUgdGFyZ2V0IGRpcmVjdG9yeSBvciBmaWxlIHVzaW5nIGNvbGxlY3Rvci5weS48L1N0ZXA+CiAgICA8U3RlcD5QYXJzZSBlYWNoIGZpbGUgdG8gZXh0cmFjdCBhbmQgY2F0ZWdvcml6ZSBpbXBvcnRzIHVzaW5nIHBhcnNlci5weSBhbmQgc3RkbGliLnB5LjwvU3RlcD4KICAgIDxTdGVwPk1hcCBhbGwgaW1wb3J0cyB0byB0aGVpciBjb3JyZXNwb25kaW5nIFB5UEkgcGFja2FnZSBuYW1lcyB1c2luZyBtYXBwaW5nLnB5LjwvU3RlcD4KICAgIDxTdGVwPkJ1aWxkIGEgc2luZ2xlIHNjcmlwdCBieSBtZXJnaW5nIGNvZGUgYW5kIGltcG9ydHMsIG5vcm1hbGl6aW5nIGluZGVudGF0aW9uIGFuZCBzdHJ1Y3R1cmUgdXNpbmcgYnVpbGRlci5weS48L1N0ZXA+CiAgICA8U3RlcD5HZW5lcmF0ZSBhIHBsYXRmb3JtLWF3YXJlIGJvb3RzdHJhcCBzY3JpcHQgZm9yIGRlcGVuZGVuY3kgaW5zdGFsbGF0aW9uIGFuZCBleGVjdXRpb24gdXNpbmcgdXZfd3JhcHBlci5weS48L1N0ZXA+CiAgICA8U3RlcD5FeHBvc2UgYWxsIGZ1bmN0aW9uYWxpdHkgdmlhIGEgVHlwZXItYmFzZWQgQ0xJIGluIF9fbWFpbl9fLnB5LCBzdXBwb3J0aW5nIHBhY2thZ2luZywgZmlsZSBsaXN0aW5nLCBhbmQgdmVyc2lvbiBkaXNwbGF5LjwvU3RlcD4KICAgIDxTdGVwPlRlc3QgYWxsIGNvbXBvbmVudHMgZm9yIGNvcnJlY3RuZXNzLCBlcnJvciBoYW5kbGluZywgYW5kIGNyb3NzLXBsYXRmb3JtIGNvbXBhdGliaWxpdHkuPC9TdGVwPgogIDwvRGV2ZWxvcG1lbnRXb3JrZmxvdz4KPC9BcmNoaXRlY3R1cmU+Cg=='
    if not os.path.exists(".erasmus"):
        for rel_path, base64_data in embedded.items():
            out_path = os.path.join(os.getcwd(), rel_path)
            os.makedirs(os.path.dirname(out_path), exist_ok=True)
            with open(out_path, "wb") as file:
                file.write(base64.b64decode(base64_data))
    # else: do not overwrite

_extract_erasmus_embedded_files()

# logging.py
from loguru import logger


# paths.py
from pathlib import Path
from pydantic import BaseModel, Field, ConfigDict
from dotenv import load_dotenv
from enum import Enum
import os
from typing import NamedTuple

load_dotenv()


class IDEMetadata(NamedTuple):
    """Metadata for an IDE environment."""

    name: str
    rules_file: str
    global_rules_path: Path


class IDE(Enum):
    """IDE environment with associated metadata."""

    windsurf = IDEMetadata(
        name="windsurf",
        rules_file=".windsurfrules",
        global_rules_path=Path.home() / ".codeium" / "windsurf" / "memories" / "global_rules.md",
    )

    cursor = IDEMetadata(
        name="cursor",
        rules_file=".cursorrules",
        global_rules_path=Path.cwd() / ".cursor" / "global_rules.md",
    )

    codex = IDEMetadata(
        name="codex",
        # Local rules file for Codex IDE (prefixed with a dot)
        rules_file=".codex.md",
        global_rules_path=Path.home() / ".codex" / "instructions.md",
    )

    claude = IDEMetadata(
        name="claude",
        rules_file="CLAUDE.md",
        global_rules_path=Path.home() / ".claude" / "CLAUDE.md",
    )

    @property
    def metadata(self) -> IDEMetadata:
        """Get the metadata for this IDE."""
        return self.value

    @property
    def rules_file(self) -> str:
        """Get the rules file name for this IDE."""
        return self.metadata.rules_file

    @property
    def global_rules_path(self) -> Path:
        """Get the global rules path for this IDE."""
        return self.metadata.global_rules_path


def detect_ide_from_env() -> IDE | None:
    """
    Detect IDE from environment variables.
    Returns None if no IDE is detected.
    """
    ide_env = os.environ.get("IDE_ENV", "").lower()

    if not ide_env:
        return None

    # Check for IDE based on prefix
    if ide_env.startswith("w"):
        return IDE.windsurf
    elif ide_env.startswith("cu"):
        return IDE.cursor
    elif ide_env.startswith("co"):
        return IDE.codex
    elif ide_env.startswith("cl"):
        return IDE.claude

    return None


def prompt_for_ide() -> IDE:
    """
    Prompt the user to select an IDE.
    Returns the selected IDE.
    """
    print("No IDE environment detected. Please select an IDE:")
    print("1. Windsurf")
    print("2. Cursor")
    print("3. Codex")
    print("4. Claude")

    while True:
        try:
            choice = input("Enter your choice (1-4): ")
            if choice == "1":
                return IDE.windsurf
            elif choice == "2":
                return IDE.cursor
            elif choice == "3":
                return IDE.codex
            elif choice == "4":
                return IDE.claude
            else:
                print("Invalid choice. Please enter a number between 1 and 4.")
        except KeyboardInterrupt:
            print("\nOperation cancelled. Using default IDE (Cursor).")
            return IDE.cursor


def get_ide() -> IDE:
    """
    Get the IDE from environment variables or prompt the user.
    Returns the selected IDE.
    """
    ide = detect_ide_from_env()
    if ide is None:
        ide = prompt_for_ide()
        environment = Path.cwd() / ".env"
        if environment.exists():
            environment_content = environment.read_text()
            environment_content += f"\nIDE_ENV={ide.name}"
            environment.write_text(environment_content)
        else:
            environment.write_text(f"IDE_ENV={ide.name}")
    return ide


class PathMngrModel(BaseModel):
    """Manages paths for different IDE environments."""

    # Allow extra attributes for mocking and patching
    model_config = ConfigDict(extra="allow")

    ide: IDE | None = None
    # Directories
    root_dir: Path = Path.cwd()
    erasmus_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus")
    context_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "context")
    protocol_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "protocol")
    template_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "templates")

    # Files
    architecture_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.architecture.xml")
    progress_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.progress.xml")
    tasks_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.tasks.xml")
    rules_file: Path | None = None
    global_rules_file: Path | None = None

    # Templates
    architecture_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "architecture.xml"
    )
    progress_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "progress.xml"
    )
    tasks_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "tasks.xml"
    )
    protocol_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "protocol.xml"
    )
    meta_agent_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "meta_agent.xml"
    )
    meta_rules_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "meta_rules.xml"
    )

    def __init__(self, **data):
        """Initialize the PathMngrModel with optional configuration data.

        Args:
            **data: Keyword arguments for configuring path management.
                    Supports IDE-specific and custom path configurations.
        """
        super().__init__(**data)
        # Initialize and time path setup
        self._setup_paths()

    def _setup_paths(self):
        """Set up and configure paths for the current development environment.

        This method handles:
        - Detecting the current IDE
        - Creating necessary directories
        - Setting up symlinks
        - Ensuring cross-platform path compatibility
        """
        """Set up paths based on the selected IDE."""
        if self.ide:
            # Set rules file based on IDE
            self.rules_file = self.root_dir / self.ide.rules_file
            self.global_rules_file = self.ide.global_rules_path

            # Create symlink for cursor if needed (special case for windsurf)
            if self.ide == IDE.windsurf:
                cursor_rules = self.root_dir / ".cursorrules"
                if self.rules_file.exists() and not cursor_rules.exists():
                    cursor_rules.symlink_to(self.rules_file)

    def get_ide_env(self) -> str | None:
        """Get the IDE environment name."""
        return self.ide.name if self.ide else None

    def get_context_dir(self) -> Path:
        """Get the context directory path."""
        return self.context_dir

    def get_protocol_dir(self) -> Path:
        """Get the protocol directory path."""
        return self.protocol_dir

    def get_architecture_file(self) -> Path:
        """Get the architecture file path."""
        return self.architecture_file

    def get_progress_file(self) -> Path:
        """Get the progress file path."""
        return self.progress_file

    def get_tasks_file(self) -> Path:
        """Get the tasks file path."""
        return self.tasks_file

    def get_rules_file(self) -> Path | None:
        """Get the rules file path."""
        return self.rules_file

    def get_global_rules_file(self) -> Path | None:
        """Get the global rules file path."""
        return self.global_rules_file

    def get_root_dir(self) -> Path:
        """Get the root directory path."""
        return self.root_dir

    def get_path(self, name: str) -> Path:
        """Get a path by name."""
        if hasattr(self, name):
            return getattr(self, name)
        raise ValueError(f"Path {name} not found")

    def set_path(self, name: str, path: Path) -> None:
        """Set a path by name."""
        if hasattr(self, name):
            setattr(self, name, path)
        else:
            raise ValueError(f"Path {name} not found")

    def ensure_dirs(self) -> None:
        """Ensure all directories exist."""
        self.context_dir.mkdir(parents=True, exist_ok=True)
        self.protocol_dir.mkdir(parents=True, exist_ok=True)
        self.erasmus_dir.mkdir(parents=True, exist_ok=True)
        self.template_dir.mkdir(parents=True, exist_ok=True)

    def ensure_files(self) -> None:
        """Ensure all files exist."""
        self.ensure_dirs()
        self.architecture_file.touch(exist_ok=True)
        self.progress_file.touch(exist_ok=True)
        self.tasks_file.touch(exist_ok=True)
        if self.rules_file:
            self.rules_file.touch(exist_ok=True)
        if self.global_rules_file:
            self.global_rules_file.touch(exist_ok=True)

    def setup_paths(self) -> None:
        """Set up all paths and ensure directories and files exist."""
        self._setup_paths()
        self.ensure_dirs()
        self.ensure_files()


# Singleton instance
_path_manager = None


def get_path_manager(ide: IDE | None = None) -> PathMngrModel:
    """Get the singleton path manager instance."""
    global _path_manager
    if _path_manager is None:
        # If no IDE is provided, try to detect it
        if ide is None:
            ide = get_ide()
        _path_manager = PathMngrModel(ide=ide)
    elif ide is not None and _path_manager.ide != ide:
        # Update the IDE if it's different
        _path_manager.ide = ide
        _path_manager._setup_paths()
    return _path_manager


# Legacy alias for backwards compatibility
PathManager = PathMngrModel

IDEMetadata = IDEMetadata
IDE = IDE
detect_ide_from_env = detect_ide_from_env
prompt_for_ide = prompt_for_ide
get_ide = get_ide
PathMngrModel = PathMngrModel
get_path_manager = get_path_manager

# sanatizer.py
import re
import xml.etree.ElementTree as ET
from typing import Any


def _sanitize_string(name: str) -> str:
    """Sanitize a string by removing emoji and non-ASCII characters while preserving valid markdown characters.
    Returns an ASCII-safe string suitable for filenames.
    """
    # First remove emoji using regex pattern
    no_emoji = re.sub(r"[\U0001F300-\U0001F9FF]", "", name)
    # Allow markdown special chars but remove other non-ASCII
    allowed_special = r"[#*_\-`~\[\](){}|<>.!]"
    sanitized = ""
    for character in no_emoji:
        # Skip non-ASCII characters entirely
        if not character.isascii():
            continue
        # Allow alphanumeric and certain special characters
        if character.isalnum() or re.match(allowed_special, character):
            sanitized += character
        else:
            sanitized += "_"
    # Collapse multiple underscores
    sanitized = re.sub(r"_+", "_", sanitized)
    # Ensure it starts with a letter
    if not sanitized[0].isalpha():
        sanitized = "p_" + sanitized
    # Strip trailing underscores
    sanitized = sanitized.rstrip("_")
    return sanitized


def _sanitize_xml_content(xml_content: str) -> str:
    """Sanitize XML content by ensuring it's well-formed and safe.

    Args:
        xml_content: The XML content to sanitize

    Returns:
        Sanitized XML content
    """
    # Replace invalid XML characters
    # XML 1.0 specification allows: #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
    # We'll replace control characters and other invalid characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", xml_content)

    # Replace invalid XML entities
    sanitized = re.sub(
        r"&(?!(amp|lt|gt|quot|apos|#\d+|#x[0-9a-fA-F]+);)", "&amp;", sanitized
    )

    # Ensure the XML is well-formed
    try:
        # Try to parse the XML to ensure it's well-formed
        ET.fromstring(sanitized)
        return sanitized
    except ET.ParseError:
        # If parsing fails, try to fix common issues
        # Add XML declaration if missing
        if not sanitized.strip().startswith("<?xml"):
            sanitized = '<?xml version="1.0" encoding="UTF-8"?>\n' + sanitized

        # Try to parse again
        try:
            ET.fromstring(sanitized)
            return sanitized
        except ET.ParseError:
            # If still failing, return a minimal valid XML
            return '<?xml version="1.0" encoding="UTF-8"?>\n<root></root>'


def _sanitize_xml_attribute(value: str) -> str:
    """Sanitize a string for use as an XML attribute value.

    Args:
        value: The attribute value to sanitize

    Returns:
        Sanitized attribute value
    """
    # Replace special XML characters with their entities
    sanitized = value.replace("&", "&amp;")
    sanitized = sanitized.replace("<", "&lt;")
    sanitized = sanitized.replace(">", "&gt;")
    sanitized = sanitized.replace('"', "&quot;")
    sanitized = sanitized.replace("'", "&apos;")

    # Remove invalid XML characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", sanitized)

    return sanitized


def _sanitize_xml_tag(tag: str) -> str:
    """Sanitize a string for use as an XML tag name.

    Args:
        tag: The tag name to sanitize

    Returns:
        Sanitized tag name
    """
    # XML tag names must start with a letter or underscore
    if not tag or not (tag[0].isalpha() or tag[0] == "_"):
        tag = "x_" + tag

    # Replace invalid characters with underscores
    sanitized = re.sub(r"[^a-zA-Z0-9_\-\.]", "_", tag)

    # Ensure it's a valid XML name
    if not re.match(r"^[a-zA-Z_][a-zA-Z0-9_\-\.]*$", sanitized):
        sanitized = "x_" + sanitized

    return sanitized


def sanitize_for_xml(value: Any) -> str:
    """Sanitize a value for use in XML.

    Args:
        value: The value to sanitize

    Returns:
        Sanitized value as a string
    """
    if value is None:
        return ""

    # Convert to string
    str_value = str(value)

    # Replace special XML characters with their entities
    sanitized = str_value.replace("&", "&amp;")
    sanitized = sanitized.replace("<", "&lt;")
    sanitized = sanitized.replace(">", "&gt;")
    sanitized = sanitized.replace('"', "&quot;")
    sanitized = sanitized.replace("'", "&apos;")

    # Remove invalid XML characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", sanitized)

    return sanitized

sanitize_for_xml = sanitize_for_xml

# xml_parser.py
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Any, Dict, List, Optional, Union


def parse_xml_file(file_path: Union[str, Path]) -> ET.Element:
    """
    Parse an XML file and return the root element.

    Args:
        file_path: Path to the XML file

    Returns:
        The root element of the XML document

    Raises:
        FileNotFoundError: If the file doesn't exist
        ET.ParseError: If the XML is not well-formed
    """
    file_path = Path(file_path)
    if not file_path.exists():
        raise FileNotFoundError(f"XML file not found: {file_path}")

    try:
        tree = ET.parse(file_path)
        return tree.getroot()
    except ET.ParseError as parse_error:
        raise ET.ParseError(f"Error parsing XML file {file_path}: {parse_error}")


def parse_xml_string(xml_string: str) -> ET.Element:
    """
    Parse an XML string and return the root element.

    Args:
        xml_string: The XML content as a string

    Returns:
        The root element of the XML document

    Raises:
        ET.ParseError: If the XML is not well-formed
    """
    try:
        return ET.fromstring(xml_string)
    except ET.ParseError as parse_error:
        raise ET.ParseError(f"Error parsing XML string: {parse_error}")


def get_element_text(root: ET.Element, xpath: str, default: Any = None) -> Any:
    """
    Get the text content of an element using XPath.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the element
        default: Default value to return if the element is not found

    Returns:
        The text content of the element, or the default value if not found
    """
    element = root.find(xpath)
    if element is None:
        return default
    return element.text


def get_element_attribute(root: ET.Element, xpath: str, attribute: str, default: Any = None) -> Any:
    """
    Get the value of an attribute using XPath.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the element
        attribute: Name of the attribute
        default: Default value to return if the attribute is not found

    Returns:
        The value of the attribute, or the default value if not found
    """
    element = root.find(xpath)
    if element is None:
        return default
    return element.get(attribute, default)


def get_elements(root: ET.Element, xpath: str) -> list[ET.Element]:
    """
    Get all elements matching an XPath expression.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the elements

    Returns:
        A list of elements matching the XPath expression
    """
    return root.findall(xpath)


def get_element_texts(root: ET.Element, xpath: str) -> list[str]:
    """
    Get the text content of all elements matching an XPath expression.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the elements

    Returns:
        A list of text content from elements matching the XPath expression
    """
    elements = get_elements(root, xpath)
    return [element.text for element in elements if element.text]


def get_architecture_title(file_path: Union[str, Path]) -> str | None:
    """
    Extract the title from an architecture XML document.

    Args:
        file_path: Path to the architecture XML file

    Returns:
        The title of the architecture, or None if not found
    """
    try:
        root = parse_xml_file(file_path)
        # Try different possible locations for the title
        title = get_element_text(root, ".//Title")
        if title:
            return title

        title = get_element_text(root, ".//MetaAgent/Title")
        if title:
            return title

        title = get_element_text(root, ".//Overview/Title")
        if title:
            return title

        return None
    except (FileNotFoundError, ET.ParseError):
        return None


def get_protocol_name(file_path: Union[str, Path]) -> str | None:
    """
    Extract the protocol name from a protocol XML document.

    Args:
        file_path: Path to the protocol XML file

    Returns:
        The name of the protocol, or None if not found
    """
    try:
        root = parse_xml_file(file_path)
        # Try different possible locations for the protocol name
        name = get_element_text(root, ".//Name")
        if name:
            return name

        name = get_element_text(root, ".//Protocol/Name")
        if name:
            return name

        return None
    except (FileNotFoundError, ET.ParseError):
        return None


def xml_to_dict(element: ET.Element) -> dict[str, Any]:
    """
    Convert an XML element to a dictionary.

    Args:
        element: The XML element to convert

    Returns:
        A dictionary representation of the XML element
    """
    result = {}

    # Add attributes
    for attribute_key, attribute_value in element.attrib.items():
        result[f"@{attribute_key}"] = attribute_value

    # Add text content if it exists and is not just whitespace
    if element.text and element.text.strip():
        result["#text"] = element.text.strip()

    # Add child elements
    for child_element in element:
        child_dict = xml_to_dict(child_element)
        child_tag = child_element.tag

        # Handle multiple children with the same tag
        if child_tag in result:
            if isinstance(result[child_tag], list):
                result[child_tag].append(child_dict)
            else:
                result[child_tag] = [result[child_tag], child_dict]
        else:
            result[child_tag] = child_dict

    return result

parse_xml_file = parse_xml_file
parse_xml_string = parse_xml_string
get_element_text = get_element_text
get_element_attribute = get_element_attribute
get_elements = get_elements
get_element_texts = get_element_texts
get_architecture_title = get_architecture_title
get_protocol_name = get_protocol_name
xml_to_dict = xml_to_dict

# rich_console.py
from rich.console import Console
from rich.table import Table
from rich.syntax import Syntax
from rich.panel import Panel
from rich.text import Text
from typing import Any, Optional


# Singleton Console instance
def get_console() -> Console:
    if not hasattr(get_console, "_console"):
        get_console._console = Console()
    return get_console._console


def print_panel(content: str, title: str | None = None, style: str = "bold blue"):
    """Print a styled panel with optional title using Rich library.

    Args:
        content (str): The text content to display in the panel.
        title (str | None, optional): Title of the panel. Defaults to None.
        style (str, optional): Rich styling for the panel. Defaults to "bold blue".
    """
    console = get_console()
    panel = Panel(content, title=title, style=style)
    console.print(panel)


def print_table(headers: list[str], rows: list[list[Any]], title: str | None = None):
    """Print a formatted table using Rich library.

    Args:
        headers (list[str]): Column headers for the table.
        rows (list[list[Any]]): Data rows to display in the table.
        title (str | None, optional): Title of the table. Defaults to None.
    """
    console = get_console()
    table = Table(title=title)
    for header in headers:
        table.add_column(header)
    for row in rows:
        table.add_row(*[str(cell) for cell in row])
    console.print(table)


def print_syntax(code: str, language: str = "python", title: str | None = None):
    """Print code syntax highlighting using Rich library.

    Args:
        code (str): Source code to highlight.
        language (str, optional): Programming language for syntax highlighting. Defaults to "python".
        title (str | None, optional): Title for the syntax block. Defaults to None.
    """
    console = get_console()
    syntax = Syntax(code, language, theme="monokai", line_numbers=True)
    if title:
        console.print(Panel(syntax, title=title))
    else:
        console.print(syntax)


def print_success(message: str):
    """Print a success message in green color.

    Args:
        message (str): Success message to display.
    """
    console = get_console()
    console.print(f"[bold green] {message}")


def print_error(message: str):
    """Print an error message in red color.

    Args:
        message (str): Error message to display.
    """
    console = get_console()
    console.print(f"[bold red] {message}")


def print_warning(message: str):
    """Print a warning message in yellow color.

    Args:
        message (str): Warning message to display.
    """
    console = get_console()
    console.print(f"[bold yellow]! {message}")


def print_info(message: str):
    """Print an informational message in blue color.

    Args:
        message (str): Informational message to display.
    """
    console = get_console()
    console.print(f"[bold blue] {message}")

get_console = get_console
print_panel = print_panel
print_table = print_table
print_syntax = print_syntax
print_success = print_success
print_error = print_error
print_warning = print_warning
print_info = print_info

# environment.py
import re
import os
from pathlib import Path
from typing_extensions import Callable
from pydantic import BaseModel, ConfigDict
from getpass import getpass
from dotenv import load_dotenv

load_dotenv()


class EnvironmentError(Exception):
    """Base exception for environment configuration errors."""

    pass


def is_sensitive_variable(name: str) -> bool:
    """
    Check if a variable name contains common sensitive terms.

    Args:
        name: The variable name to check

    Returns:
        True if the variable is likely sensitive, False otherwise
    """
    sensitive_terms = [
        "key",
        "token",
        "secret",
        "password",
        "credential",
        "auth",
        "api_key",
        "access_token",
        "private",
        "ssh",
        "certificate",
    ]

    name_lower = name.lower()
    return any(term in name_lower for term in sensitive_terms)


def mask_sensitive_value(value: str) -> str:
    """
    Mask a sensitive value for display.

    Args:
        value: The value to mask

    Returns:
        Masked value (first 2 chars + 3 stars)
    """
    if not value or len(value) <= 2:
        return "***"
    return value[:2] + "***"


class VariableDefinition(BaseModel):
    """Definition of an environment variable."""

    name: str
    type: type
    required: bool = True
    default: any = None
    validator: Callable[[any], bool] | None = None
    model_config = ConfigDict(arbitrary_types_allowed=True)

    @property
    def is_sensitive(self) -> bool:
        """Check if this variable is sensitive."""
        return is_sensitive_variable(self.name)


class EnvironmentConfig(BaseModel):
    """Manages environment configuration with validation."""

    definitions: dict[str, VariableDefinition] = {}
    _variables: dict[str, any] = {}

    def list_variables(self):
        """List all currently defined environment variables.

        Returns:
            list: A list of dictionaries containing variable details.
        """
        for name, definition in self._definitions.items():
            if definition.is_sensitive:
                print(f"{name}: ****")
            else:
                print(f"{name}: {self._variables[name]}")

    def define_required(self, name: str, type_: type, **kwargs) -> None:
        """Define a required environment variable."""
        self._definitions[name] = VariableDefinition(name=name, type=type_, required=True, **kwargs)

    def define_optional(self, name: str, type_: type, **kwargs) -> None:
        """Define an optional environment variable."""
        self._definitions[name] = VariableDefinition(
            name=name, type=type_, required=False, **kwargs
        )

    def set(self, name: str, value: str) -> None:
        """Set an environment variable value."""
        if name not in self._definitions:
            raise EnvironmentError(f"Variable {name} not defined")

        definition = self._definitions[name]
        try:
            # Convert value to the specified type
            converted_value = definition.type(value)

            # Apply validation
            if definition.min_value is not None and converted_value < definition.min_value:
                raise EnvironmentError(
                    f"{name} must be greater than or equal to {definition.min_value}"
                )

            if definition.max_value is not None and converted_value > definition.max_value:
                raise EnvironmentError(
                    f"{name} must be less than or equal to {definition.max_value}"
                )

            if definition.pattern is not None and isinstance(converted_value, str):
                if not re.match(definition.pattern, converted_value):
                    raise EnvironmentError(f"{name} must match pattern {definition.pattern}")

            if definition.validator is not None and not definition.validator(converted_value):
                raise EnvironmentError(f"{name} failed custom validation")

            self._variables[name] = converted_value

        except (ValueError, TypeError) as e:
            raise EnvironmentError(f"Invalid value for {name}: {str(e)}")

    def get(self, name: str, default: any = None) -> any:
        """
        Get an environment variable value.

        Args:
            name: The variable name
            default: Default value if not found

        Returns:
            The variable value or default
        """
        if name not in self._variables:
            return default
        return self._variables[name]

    def get_masked(self, name: str) -> str:
        """
        Get a masked representation of a variable value.

        Args:
            name: The variable name

        Returns:
            Masked value if sensitive, actual value otherwise
        """
        if name not in self._variables:
            return ""

        value = self._variables[name]
        definition = self._definitions[name]

        if definition.is_sensitive and isinstance(value, str):
            return mask_sensitive_value(value)
        return str(value)

    def load_from_file(self, file_path: str | Path) -> None:
        """Load environment variables from a file."""
        file_path = Path(file_path)
        if not file_path.exists():
            raise EnvironmentError(f"Environment file not found: {file_path}")

        with open(file_path) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    try:
                        name, value = line.split("=", 1)
                        name = name.strip()
                        value = value.strip()
                        self.set(name, value)
                    except ValueError:
                        continue

    def load_from_system(self) -> None:
        """Load environment variables from system environment."""
        for name, definition in self._definitions.items():
            if name in os.environ:
                self.set(name, os.environ[name])

    def prompt_for_missing(self) -> None:
        """Prompt for missing required variables."""
        for name, definition in self._definitions.items():
            if definition.required and name not in self._variables:
                if definition.is_sensitive:
                    value = getpass(f"Enter {name}: ")
                else:
                    value = input(f"Enter {name}: ")
                self.set(name, value)

    def validate(self) -> None:
        """Validate all environment variables according to their definitions."""
        for variable_key, variable_definition in self._definitions.items():
            variable_value = self._variables.get(variable_key)
            if variable_definition.required and variable_value is None:
                raise EnvironmentError(f"Missing required environment variable: {variable_key}")
            if variable_value is not None:
                if not isinstance(variable_value, variable_definition.type):
                    raise TypeError(
                        f"Environment variable '{variable_key}' should be of type {variable_definition.type.__name__}"
                    )
                if variable_definition.validator and not variable_definition.validator(
                    variable_value
                ):
                    raise ValueError(
                        f"Environment variable '{variable_key}' failed custom validation."
                    )

    def merge(self, other: "EnvironmentConfig") -> None:
        """Merge another environment configuration into this one."""
        # First merge definitions
        for name, definition in other._definitions.items():
            if name not in self._definitions:
                self._definitions[name] = definition

        # Then merge values
        for name, value in other._variables.items():
            self.set(name, str(value))

EnvironmentError = EnvironmentError
is_sensitive_variable = is_sensitive_variable
mask_sensitive_value = mask_sensitive_value
VariableDefinition = VariableDefinition
EnvironmentConfig = EnvironmentConfig

# context.py
import os
import xml.etree.ElementTree as ET
from pathlib import Path

from loguru import logger
from pydantic import BaseModel



console = get_console()


class ContextError(Exception):
    """Base exception for all context management errors.

    This exception is raised when there are general issues with context
    management that do not fit into more specific error categories.
    Serves as a base class for more specific context-related exceptions.
    """


class ContextFileError(ContextError):
    """Exception raised when file-related operations in context management fail.

    This exception is used when there are issues such as:
    - Unable to read context files
    - Permission issues accessing context files
    - Context file not found
    - Corrupted or unreadable context files
    """


class ContextValidationError(ContextError):
    """Exception raised when context content fails validation requirements.

    This exception is used when context files do not meet expected
    structural or content requirements, such as:
    - Malformed XML
    - Missing required XML elements
    - Invalid data types or values
    - Incompatible context configurations
    """


path_manager = get_path_manager()


class CtxModel(BaseModel):
    """Represents a single development context with its associated file contents.

    This model encapsulates the core files that define a project's development context,
    providing a structured representation of project metadata and configuration.

    Attributes:
        path (str): The base path or identifier for this context.
        architecture (str): XML content representing the project's architectural design.
        progress (str): XML content tracking the current progress of development components.
        tasks (str): XML content listing and tracking project tasks.
        protocol (str, optional): XML content defining development protocols. Defaults to an empty
            string.

    The model ensures that each context is a self-contained unit with all necessary
    metadata for tracking and managing a development project.
    """


class CtxMngrModel(BaseModel):
    """Manages a collection of development contexts and their associated file paths.

    This model serves as a comprehensive registry for multiple development contexts,
    providing centralized management of context-related paths and contents.

    Attributes:
        contexts (list[CtxModel]): A list of all managed context models. Defaults to an empty list.
        context_dir (Path): Base directory for storing context files. Uses path_manager to determine
            location.
        base_dir (Path): Alias for context_dir, ensuring consistent path management.
        context (CtxModel | None): Currently active context model. Defaults to None.

        # Paths for core context files
        architecture_path (str | Path): Path to the architecture context file.
        progress_path (str | Path): Path to the progress context file.
        tasks_path (str | Path): Path to the tasks context file.

        # Content storage for core context files
        architecture_content (str): Raw content of the architecture file.
        progress_content (str): Raw content of the progress file.
        tasks_content (str): Raw content of the tasks file.
        protocol_content (str): Raw content of the protocol file.

    The model provides a flexible and extensible approach to managing
    multiple development contexts with centralized path and content tracking.
    """


class ContextManager:
    """
    Manages development context files in the .erasmus/context directory.
    Uses CtxModel as the in-memory storage for context data.
    Handles context selection, loading, saving, and file operations for architecture, progress, and
        tasks only.
    Protocol handling is managed by erasmus/protocol.py.
    """

    def __init__(self, base_dir: str | None = None, base_path: str | None = None) -> None:
        """Initialize the context manager with flexible base directory configuration.

        This method sets up the context management system by:
        1. Determining the base directory for context storage
        2. Creating the directory if it doesn't exist
        3. Initializing paths for core context files
        4. Preparing for context model management

        Args:
            base_dir (str | None, optional): Base directory for storing context files.
                If not provided, uses the default path from path_manager.
            base_path (str | None, optional): Alias for base_dir, provided for
                backwards compatibility. Takes precedence over base_dir if both are set.

        Raises:
            OSError: If there are permission issues creating the base directory

        Notes:
            - Uses path_manager to determine default context directory
            - Creates the base directory if it doesn't exist
            - Initializes core context file paths
            - Logs the initialization for traceability
        """
        # Determine base directory parameter (base_path overrides base_dir)
        chosen_dir = base_path if base_path is not None else base_dir
        # Remove self.base_dir assignment, always use path_manager.get_context_dir()
        logger.info(
            f"Initialized ContextManager with base path: {
                chosen_dir if chosen_dir else path_manager.get_context_dir()
            }",
        )
        # Initialize context tracking attributes
        self.context: CtxModel | None = None
        # Set paths for core context files using path_manager
        self.architecture_path: Path = path_manager.get_architecture_file()
        self.progress_path: Path = path_manager.get_progress_file()
        self.tasks_path: Path = path_manager.get_tasks_file()
        # Initialize content storage for core context files
        self.architecture_content: str | None = None
        self.progress_content: str | None = None
        self.tasks_content: str | None = None

    def get_default_content(self, file_type: str) -> str:
        template_map = {
            "architecture": path_manager.architecture_template,
            "progress": path_manager.progress_template,
            "tasks": path_manager.tasks_template,
            "protocol": path_manager.protocol_template,
            "meta_agent": path_manager.meta_agent_template,
            "meta_rules": path_manager.meta_rules_template,
        }
        if file_type not in template_map:
            raise ValueError(f"Unsupported file type: {file_type}")
        return template_map[file_type].read_text()

    def create_context(
        self,
        context_name: str,
        architecture_content: str | None = None,
        progress_content: str | None = None,
        tasks_content: str | None = None,
    ) -> None:
        """Create a new development context with optional custom content.

        This method establishes a new context directory and populates it with
        core XML files using either provided content or default templates.

        Args:
            context_name (str): A unique identifier for the new context.
                Will be sanitized to ensure file system compatibility.
            architecture_content (str, optional): Custom XML content for the
                architecture file. If None, uses the default template.
            progress_content (str, optional): Custom XML content for the
                progress tracking file. If None, uses the default template.
            tasks_content (str, optional): Custom XML content for the
                tasks file. If None, uses the default template.

        Raises:
            ContextError: If a context with the same name already exists.
            ValueError: If provided XML content is malformed.

        Notes:
            - Uses path_manager to locate template files
            - Sanitizes the context name for safe directory creation
            - Automatically creates a context directory
            - Supports partial or full custom content for context files
        """
        sanitized_name = self._sanitize_name(context_name)
        context_dir = path_manager.get_context_dir() / sanitized_name
        if context_dir.exists():
            raise ContextError(f"Context already exists: {context_name}")
        # Create context directory
        context_dir.mkdir(parents=True, exist_ok=False)
        architecture_content = architecture_content or self.get_default_content("architecture")
        named_architecture_content = architecture_content.replace(
            "  <Title>Project Title</Title>",
            f"<Title>{context_name}</Title>",
        )
        # Use the correct template directory from the path manager
        template_map = {
            "ctx.architecture.xml": (
                path_manager.architecture_template,
                named_architecture_content,
                "Architecture",
            ),
            "ctx.progress.xml": (
                path_manager.progress_template,
                progress_content or self.get_default_content("progress"),
                "Progress",
            ),
            "ctx.tasks.xml": (
                path_manager.tasks_template,
                tasks_content or self.get_default_content("tasks"),
                "Tasks",
            ),
        }
        for target_name, (
            template_path,
            user_content,
            root_tag,
        ) in template_map.items():
            content = None
            if user_content is not None and user_content.strip():
                try:
                    ET.fromstring(user_content)
                    content = user_content
                except Exception:
                    content = f"<{root_tag}>{user_content}</{root_tag}>"
            elif template_path.exists():
                content = template_path.read_text()
            else:
                content = f"<{root_tag}></{root_tag}>"
            (context_dir / target_name).write_text(content)

    def get_context(self, context_name: str) -> CtxModel:
        """Retrieve a specific context model by its name.

        This method searches for and returns a CtxModel instance
        corresponding to the given context name.

        Args:
            context_name (str): The name of the context to retrieve.

        Returns:
            CtxModel: The context model with the specified name.

        Raises:
            ContextError: If no context with the given name is found.

        Notes:
            - Uses get_context_model internally to fetch the context
            - Supports case-insensitive and sanitized context name matching
        """
        return self.get_context_model(context_name)

    @property
    def base_path(self) -> Path:
        """Retrieve the base directory path for context storage.

        This property provides an alias for base_dir, maintaining backwards
        compatibility and offering a consistent interface for accessing
        the root directory of context files.

        Returns:
            Path: The base directory path where context files are stored.

        Notes:
            - Ensures consistent access to the context storage location
            - Supports both base_dir and base_path naming conventions
            - Immutable property that returns the current base directory
        """
        # Always use path_manager.get_context_dir()
        return path_manager.get_context_dir()

    def save_context_file(self, context_name: str, filename: str, content: str) -> None:
        """Save raw content to a file within a specific context directory.

        This method writes the provided content to a file in the context
        directory, creating the directory if it doesn't exist.

        Args:
            context_name (str): The name of the context to save the file in.
            filename (str): The name of the file to be saved.
            content (str): The raw content to write to the file.

        Raises:
            ContextError: If the context directory cannot be created or accessed.
            OSError: If there are file system permission issues.

        Notes:
            - Automatically creates the context directory if it doesn't exist
            - Overwrites the file if it already exists
            - Does not perform any content validation or sanitization
        """
        context_dir = self.get_context_path(context_name)
        context_dir.mkdir(parents=True, exist_ok=True)
        file_path = context_dir / filename
        file_path.write_text(content)

    def load_context_file(self, context_name: str, filename: str) -> str:
        """Load and sanitize content from a file within a specific context directory.

        This method reads a file from the specified context directory,
        returning an empty string if the file does not exist.

        Args:
            context_name (str): The name of the context to load the file from.
            filename (str): The name of the file to load.

        Returns:
            str: The sanitized content of the file. Returns an empty string
                 if the file does not exist.

        Notes:
            - Uses _sanitize_content to clean the loaded file content
            - Silently handles non-existent files by returning an empty string
            - Ensures that loaded content is safe for further processing

        Raises:
            ContextError: If there are issues accessing the context directory.
            OSError: If there are file system permission issues.
        """
        context_dir = self.get_context_path(context_name)
        file_path = context_dir / filename
        if not file_path.exists():
            return ""
        raw = file_path.read_text()
        return self._sanitize_content(raw)

    def list_context_files(self, context_name: str) -> list[str]:
        """List all file names in the specified context directory."""
        context_dir = self.get_context_path(context_name)
        if not context_dir.exists():
            return []
        return [
            context_file.name for context_file in context_dir.iterdir() if context_file.is_file()
        ]

    def delete_context_file(self, context_name: str, filename: str) -> None:
        """Delete a file in the specified context directory."""
        context_dir = self.get_context_path(context_name)
        file_path = context_dir / filename
        if file_path.exists():
            file_path.unlink()

    def update_architecture(self, context_name: str, content: str) -> None:
        """Update the architecture file content for a context."""
        self.save_context_file(context_name, "ctx.architecture.xml", content)

    def update_progress(self, context_name: str, content: str) -> None:
        """Update the progress file content for a context."""
        self.save_context_file(context_name, "ctx.progress.xml", content)

    def update_tasks(self, context_name: str, content: str) -> None:
        """Update the tasks file content for a context."""
        self.save_context_file(context_name, "ctx.tasks.xml", content)
        # End of initialization

    def _sanitize_name(self, context_name: str) -> str:
        """
        Sanitize a context name for filesystem use.
        Args:
            context_name: The context name to sanitize.
        Returns:
            The sanitized name.
        """
        return _sanitize_string(context_name)

    def _get_context_dir(self, context_name: str) -> Path:
        """
        Get the directory for a context.
        Args:
            context_name: The context name.
        Returns:
            The context directory path.
        """
        # Always use path_manager.get_context_dir()
        return path_manager.get_context_dir() / self._sanitize_name(context_name)

    def _sanitize_filename(self, filename: str) -> str:
        """
        Sanitize a filename to be ASCII-only and safe for filesystem operations.
        Args:
            filename: The filename to sanitize
        Returns:
            Sanitized filename
        """
        return _sanitize_string(filename)

    def _sanitize_content(self, content: str) -> str:
        """
        Sanitize XML content to be ASCII-only and well-formed.
        Args:
            content: The content to sanitize
        Returns:
            Sanitized content
        """
        return _sanitize_xml_content(content)

    def get_context_path(self, context_name: str) -> Path:
        """
        Get the path for a context's directory.
        Args:
            context_name: Name of the context
        Returns:
            Path to the context directory
        """
        sanitized_name = self._sanitize_filename(context_name)
        return self.base_path / sanitized_name

    def get_context_dir_path(self, context_name: str) -> Path | None:
        """
        Get the directory path for a context if it exists.
        Args:
            context_name: Name of the context
        Returns:
            Path to the context directory, or None if it doesn't exist
        """
        try:
            context_dir = self._get_context_dir(context_name)
            return context_dir if context_dir.exists() else None
        except Exception as context_error:
            raise ContextFileError(
                f"Failed to get context path: {context_error}",
            ) from context_error

    def save_contexts(self) -> list[CtxModel]:
        """
        Save all contexts by loading them from disk into CtxModel instances.
        Returns:
            List of saved CtxModel instances
        """
        context_models: list[CtxModel] = []
        # Always use path_manager.get_context_dir()
        for context_directory in path_manager.get_context_dir().iterdir():
            if context_directory.is_dir():
                context_name = context_directory.name
                try:
                    context_path = self.get_context_dir_path(context_name)
                    if context_path:
                        context_models.append(self.get_context_model(context_name))
                except Exception as context_error:
                    logger.error(f"Failed to save context {context_name}: {context_error}")
        return context_models

    def delete_context(self, context_name: str) -> None:
        """
        Delete a context and all its files.
        Args:
            context_name: Name of the context to delete
        Raises:
            ContextFileError: If deletion fails
        """
        try:
            context_dir = self._get_context_dir(context_name)
            for file_path in context_dir.iterdir():
                if file_path.is_file():
                    file_path.unlink()
            context_dir.rmdir()
            logger.info(f"Deleted context: {context_name}")
        except Exception as context_error:
            raise ContextFileError(f"Failed to delete context: {context_error}") from context_error

    def display_context(self, context_name: str) -> None:
        """
        Display a context's information, including file sizes and paths.
        Args:
            context_name: Name of the context to display
        Raises:
            ContextFileError: If context doesn't exist
        """
        try:
            context_dir = self.get_context_dir_path(context_name)
            console.print(f"Context: {context_name}")
            console.print(f"Path: {context_dir}")
            console.print(
                f"Architecture: {
                    len(self.read_file(context_name, 'architecture'))
                    if self.read_file(context_name, 'architecture')
                    else 'N/A'
                }",
            )
            console.print(
                f"Progress: {
                    len(self.read_file(context_name, 'progress'))
                    if self.read_file(context_name, 'progress')
                    else 'N/A'
                }",
            )
            console.print(
                f"Tasks: {
                    len(self.read_file(context_name, 'tasks'))
                    if self.read_file(context_name, 'tasks')
                    else 'N/A'
                }",
            )
            console.print(
                f"Protocol: {
                    len(self.read_file(context_name, 'protocol'))
                    if self.read_file(context_name, 'protocol')
                    else 'N/A'
                }",
            )
        except Exception as context_error:
            raise ContextFileError(f"Failed to display context: {context_error}") from context_error

    def list_contexts(self) -> list[str]:
        """
        List all development contexts by name.
        Returns:
            A list of context names.
        Raises:
            ContextFileError: If contexts cannot be listed.
        """
        try:
            # Always use path_manager.get_context_dir()
            return [
                context_directory.name
                for context_directory in path_manager.get_context_dir().iterdir()
                if context_directory.is_dir()
            ]
        except Exception as context_error:
            raise ContextFileError(f"Failed to list contexts: {context_error}") from context_error

    def select_context(self) -> CtxModel:
        """
        Interactively select a context, loading it into memory and saving the current context if
            needed.
        Returns:
            The selected CtxModel instance
        Raises:
            ContextFileError: If no contexts exist
        """
        context_models = self.save_contexts()
        if not context_models:
            raise ContextFileError("No contexts exist")
        console.print("Available contexts:")
        for context_index, context_model in enumerate(context_models):
            console.print(f"{context_index + 1}. {context_model.path}")
        while True:
            try:
                user_choice = int(input("Select a context (number): "))
                if 1 <= user_choice <= len(context_models):
                    selected_context = context_models[user_choice - 1]
                    # Write current in-memory context to files before switching
                    if self.context:
                        self._write_context_to_files()
                    self.context = selected_context
                    self._load_context_to_memory(selected_context)
                    return selected_context
                console.print("Invalid choice. Please try again.")
            except ValueError:
                console.print("Please enter a number.")

    def _write_context_to_files(self) -> None:
        """
        Write the in-memory context content to the working files.
        """
        if self.context:
            if self.architecture_content is not None:
                self.architecture_path.write_text(self.architecture_content)
            if self.progress_content is not None:
                self.progress_path.write_text(self.progress_content)
            if self.tasks_content is not None:
                self.tasks_path.write_text(self.tasks_content)
            if self.protocol_content is not None:
                self.protocol_path.write_text(self.protocol_content)

    def _load_context_to_memory(self, context_model: CtxModel) -> None:
        """
        Load the content of a CtxModel into the in-memory fields.
        Args:
            context_model: The CtxModel to load
        """
        self.architecture_content = context_model.architecture
        self.progress_content = context_model.progress
        self.tasks_content = context_model.tasks

    def update_file(self, context_name: str, file_type: str, content: str) -> None:
        """
        Update a file in a development context.
        Args:
            context_name: The name of the context.
            file_type: The type of file to update (architecture, progress, tasks, protocol).
            content: The content to write to the file.
        Raises:
            ContextError: If the file cannot be updated.
        """
        context_dir = self.get_context_dir_path(context_name)
        if not context_dir:
            raise ContextError(f"Context does not exist: {context_name}")
        file_path = context_dir / f"ctx.{file_type}.xml"
        try:
            file_path.write_text(content)
        except Exception as error:
            raise ContextError(f"Failed to update file: {error}") from error

    def read_file(self, context_name: str, file_type: str) -> str | None:
        """
        Read a file from a development context.
        Args:
            context_name: The name of the context.
            file_type: The type of file to read (architecture, progress, tasks, protocol).
        Returns:
            The file content, or None if the file does not exist.
        Raises:
            ContextError: If the file cannot be read.
        """
        context_dir = self.get_context_dir_path(context_name)
        if not context_dir:
            raise ContextError(f"Context does not exist: {context_name}")
        file_path = context_dir / f"ctx.{file_type}.xml"
        try:
            return file_path.read_text() if file_path.exists() else None
        except Exception as error:
            raise ContextError(f"Failed to read file: {error}") from error

    def edit_file(self, context_name: str, file_type: str, editor: str | None = None) -> None:
        """
        Edit a file in a development context using the specified editor.
        Args:
            context_name: The name of the context.
            file_type: The type of file to edit (architecture, progress, tasks, protocol).
            editor: The editor to use. If None, the default editor is used.
        Raises:
            ContextError: If the file cannot be edited.
        """
        context_dir = self.get_context_dir_path(context_name)
        if not context_dir:
            raise ContextError(f"Context does not exist: {context_name}")
        file_path = context_dir / f"ctx.{file_type}.xml"
        if not file_path.exists():
            raise ContextError(f"File does not exist: {file_type}")
        try:
            editor_cmd = editor or os.environ.get("EDITOR", "nano")
            os.system(f"{editor_cmd} {file_path}")
        except Exception as error:
            raise ContextError(f"Failed to edit file: {error}") from error

    def store_context(self) -> str:
        """
        Store the current context by reading the architecture, progress, and tasks files into
            memory, then writing those values to the context directory files and updating the
            in-memory CtxModel.
        Returns:
            The name of the stored context
        Raises:
            ContextError: If storing the context fails
        """
        try:
            self.architecture_content = (
                self.architecture_path.read_text()
                if self.architecture_path.exists()
                else self.get_default_content("architecture")
            )
            self.progress_content = (
                self.progress_path.read_text()
                if self.progress_path.exists()
                else self.get_default_content("progress")
            )
            self.tasks_content = (
                self.tasks_path.read_text()
                if self.tasks_path.exists()
                else self.get_default_content("tasks")
            )
            tree = ET.ElementTree(ET.fromstring(self.architecture_content))
            root = tree.getroot()
            title_elem = root.find(".//Title")
            if title_elem is not None and title_elem.text:
                title = title_elem.text
            else:
                # If no Title element, use the first line of architecture content as fallback
                first_line = self.architecture_content.strip().split("\n", 1)[0].strip()
                # Sanitize the first line to ASCII only
                title = self._sanitize_string(first_line) if first_line else "untitled"
            # Always sanitize the title to remove non-ASCII characters
            context_name_sanitized = self._sanitize_string(title)
            context_dir = self._get_context_dir(context_name_sanitized)
            context_dir.mkdir(parents=True, exist_ok=True)
            # Sanitize the architecture, progress, and tasks content to ASCII before writing
            architecture_ascii = self._sanitize_xml(self.architecture_content)
            progress_ascii = self._sanitize_xml(self.progress_content)
            tasks_ascii = self._sanitize_xml(self.tasks_content)
            (context_dir / "ctx.architecture.xml").write_text(architecture_ascii)
            (context_dir / "ctx.progress.xml").write_text(progress_ascii)
            (context_dir / "ctx.tasks.xml").write_text(tasks_ascii)
            self.context = CtxModel(
                path=str(context_dir),
                architecture=architecture_ascii,
                progress=progress_ascii,
                tasks=tasks_ascii,
            )
        except Exception as error:
            raise ContextError(f"Failed to store context: {error}") from error
        return context_name_sanitized

    def load_context(self, context_name: str) -> None:
        """
        Load a stored context by copying its XML files to the root-level .ctx.* XML files.

        Args:
            context_name: Name of the context to load

        Raises:
            ContextError: If the context does not exist or loading fails
        """
        # Locate the context directory
        context_dir = self._get_context_dir(context_name)
        if not context_dir.exists():
            raise ContextError(f"Context does not exist: {context_name}")
        # Copy each context file (XML only) to root-level .ctx files
        try:
            for file_type in ("architecture", "progress", "tasks"):
                src = context_dir / f"ctx.{file_type}.xml"
                if src.exists():
                    dst = getattr(self, f"{file_type}_path")
                    dst.write_text(src.read_text())
                else:
                    logger.warning(
                        f"No {file_type} file found for context '{context_name}' \
                            (expected ctx.{file_type}.xml)",
                    )
        except Exception as error:
            raise ContextError(f"Failed to load context '{context_name}': {error}") from error
        # After loading context files, update IDE rules and global rules
        try:


            _merge_rules_file()
        except Exception as merge_error:
            logger.error(
                f"Failed to update rules file after loading context \
                    '{context_name}': {merge_error}",
            )

    def get_context_model(self, context_name: str) -> CtxModel:
        """
        Get a CtxModel instance by context name.
        Args:
            context_name: Name of the context
        Returns:
            CtxModel instance
        Raises:
            ContextFileError: If context doesn't exist
        """
        try:
            context_dir = self._get_context_dir(context_name)
            architecture = self.read_file(context_name, "architecture") or ""
            progress = self.read_file(context_name, "progress") or ""
            tasks = self.read_file(context_name, "tasks") or ""
            return CtxModel(
                path=str(context_dir),
                architecture=architecture,
                progress=progress,
                tasks=tasks,
            )
        except Exception as context_error:
            raise ContextFileError(f"Failed to get context: {context_error}") from context_error

    def _sanitize_string(self, filename: str) -> str:
        """
        Sanitize a filename to be ASCII-only and safe for filesystem operations.

        Args:
            filename: The filename to sanitize

        Returns:
            Sanitized filename
        """
        return _sanitize_string(filename)

    def _sanitize_xml(self, content: str) -> str:
        """
        Sanitize XML content to be ASCII-only and safe for filesystem operations.
        """
        return _sanitize_xml_content(content)

ContextError = ContextError
ContextFileError = ContextFileError
ContextValidationError = ContextValidationError
CtxModel = CtxModel
CtxMngrModel = CtxMngrModel

# protocol.py
from pathlib import Path
from typing import Optional
from pydantic import BaseModel
from loguru import logger



path_manager = get_path_manager()


class ProtocolError(Exception):
    """Exception raised for protocol-related errors."""

    pass


class ProtocolModel(BaseModel):
    """
    Represents a protocol, including its name, path, and content.
    """

    name: str
    path: str
    content: str


class ProtocolManager:
    """
    Manages protocol files for Erasmus.
    Loads base protocol templates from erasmus.erasmus/templates/protocols and custom user protocols from erasmus.erasmus/protocol.
    Provides methods to list, get, create, update, and delete protocols.
    """

    def __init__(self, base_dir: str | None = None, user_dir: str | None = None) -> None:
        # Always use path_manager.template_dir / 'protocols' unless base_dir is explicitly provided
        self.base_template_dir: Path = (
            Path(base_dir) if base_dir is not None else path_manager.template_dir / "protocols"
        )
        self.user_protocol_dir: Path = Path(user_dir) if user_dir else path_manager.protocol_dir
        self.base_template_dir.mkdir(parents=True, exist_ok=True)
        self.user_protocol_dir.mkdir(parents=True, exist_ok=True)
        logger.info(
            f"Initialized ProtocolManager with base template dir: {self.base_template_dir} and user protocol dir: {self.user_protocol_dir}"
        )

    def _sanitize_name(self, protocol_name: str) -> str:
        """Sanitize a protocol name for filesystem use."""
        return _sanitize_string(protocol_name)

    def _get_protocol_path(self, protocol_name: str, is_template: bool = False) -> Path:
        """
        Get the path for a protocol file.
        Args:
            protocol_name: The protocol name
            is_template: If True, look in the template directory; else, user directory
        Returns:
            Path to the protocol file
        """
        sanitized_name = self._sanitize_name(protocol_name)
        directory = self.base_template_dir if is_template else self.user_protocol_dir
        return directory / f"{sanitized_name}.xml"

    def list_protocols(
        self, include_templates: bool = True, include_user: bool = True
    ) -> list[str]:
        """
        List all available protocol names.
        Args:
            include_templates: Include base templates
            include_user: Include user protocols
        Returns:
            List of protocol names
        """
        protocol_names = set()
        if include_templates:
            protocol_names.update(
                [protocol_path.stem for protocol_path in self.base_template_dir.glob("*.xml")]
            )
        if include_user:
            protocol_names.update(
                [protocol_path.stem for protocol_path in self.user_protocol_dir.glob("*.xml")]
            )
        return sorted(protocol_names)

    def get_protocol(self, protocol_name: str) -> ProtocolModel | None:
        """
        Get a protocol by name, searching user protocols first, then templates.
        Args:
            protocol_name: The protocol name
        Returns:
            ProtocolModel if found, else None
        """
        sanitized_name = self._sanitize_name(protocol_name)
        user_path = self._get_protocol_path(sanitized_name, is_template=False)
        template_path = self._get_protocol_path(sanitized_name, is_template=True)
        if user_path.exists():
            content = user_path.read_text()
            return ProtocolModel(name=sanitized_name, path=str(user_path), content=content)
        elif template_path.exists():
            content = template_path.read_text()
            return ProtocolModel(name=sanitized_name, path=str(template_path), content=content)
        else:
            return None

    def create_protocol(self, protocol_name: str, content: str) -> ProtocolModel:
        """
        Create a new user protocol.
        Args:
            protocol_name: The protocol name
            content: The protocol content
        Returns:
            The created ProtocolModel
        Raises:
            FileExistsError: If a user protocol with the same name already exists
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        if protocol_path.exists():
            raise FileExistsError(f"Protocol '{sanitized_name}' already exists.")
        # Use template if content is not provided or empty
        if not isinstance(content, str) or not content.strip():
            template_path = path_manager.template_dir / "protocol.xml"
            if template_path.exists():
                content = template_path.read_text()
            else:
                content = '<?xml version="1.0" encoding="UTF-8"?>\n<Protocol></Protocol>'
        else:
            # If content is not valid XML, wrap it in <Protocol>...</Protocol>
            import xml.etree.ElementTree as ET

            try:
                ET.fromstring(content)
            except Exception:
                content = f'<?xml version="1.0" encoding="UTF-8"?>\n<Protocol>{content}</Protocol>'
        protocol_path.write_text(_sanitize_xml_content(content))
        logger.info(f"Created protocol: {sanitized_name}")
        return ProtocolModel(name=sanitized_name, path=str(protocol_path), content=content)

    def update_protocol(self, protocol_name: str, content: str) -> ProtocolModel:
        """
        Update an existing user protocol.
        Args:
            protocol_name: The protocol name
            content: The new protocol content
        Returns:
            The updated ProtocolModel
        Raises:
            FileNotFoundError: If the protocol does not exist in user protocols
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        if not protocol_path.exists():
            raise FileNotFoundError(f"Protocol '{sanitized_name}' not found in user protocols.")
        # Ensure content is a valid XML string
        if not isinstance(content, str) or not content.strip():
            content = '<?xml version="1.0" encoding="UTF-8"?>\n<Protocol></Protocol>'
        else:
            import xml.etree.ElementTree as ET

            try:
                ET.fromstring(content)
            except Exception:
                content = f'<?xml version="1.0" encoding="UTF-8"?>\n<Protocol>{content}</Protocol>'
        protocol_path.write_text(_sanitize_xml_content(content))
        logger.info(f"Updated protocol: {sanitized_name}")
        return ProtocolModel(name=sanitized_name, path=str(protocol_path), content=content)

    def delete_protocol(self, protocol_name: str) -> None:
        """
        Delete a user protocol.
        Args:
            protocol_name: The protocol name
        Raises:
            FileNotFoundError: If the protocol does not exist in user protocols
            PermissionError: If attempting to delete a template protocol
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        template_path = self._get_protocol_path(sanitized_name, is_template=True)
        # Prevent deletion if protocol is a template
        if template_path.exists():
            raise PermissionError(
                f"Cannot delete template protocol: '{sanitized_name}'. Only custom (user) protocols can be deleted."
            )
        if not protocol_path.exists():
            raise FileNotFoundError(f"Protocol '{sanitized_name}' not found in user protocols.")
        protocol_path.unlink()
        logger.info(f"Deleted protocol: {sanitized_name}")

ProtocolError = ProtocolError
ProtocolModel = ProtocolModel

# file_monitor.py
import os
import time
from typing import Optional, Set
from watchdog.observers import ObserverType, Observer
from watchdog.events import FileSystemEventHandler, FileSystemEvent
from loguru import logger
from pathlib import Path

import re

import xml.etree.ElementTree as ET

# Add a global to track last rules file write time
_last_rules_write_time = None


def _merge_rules_file() -> None:
    """
    Merge current .ctx files into the IDE rules file using the meta_rules.xml template.
    Refreshes IDE detection to ensure correct rules file is used.
    Overwrites the rules file every time with a fresh merge of the template and current context/protocol content.
    Prompts the user to select a protocol if none is set or the file is missing.
    """


    global _last_rules_write_time

    detected_ide = detect_ide_from_env()
    path_manager = get_path_manager(detected_ide)
    template_path = path_manager.template_dir / "meta_rules.xml"
    rules_file_path = path_manager.get_rules_file()
    if not template_path.exists():
        # No template available: fallback to raw merge of ctx files
        logger.warning(f"Template file not found: {template_path}; falling back to raw merge")
        try:
            architecture_text = path_manager.get_architecture_file().read_text()
            progress_text = path_manager.get_progress_file().read_text()
            tasks_text = path_manager.get_tasks_file().read_text()
            merged_content = "\n".join([architecture_text, progress_text, tasks_text])
            if not rules_file_path:
                logger.warning("No rules file configured; skipping local merge")
            else:
                rules_file_path.write_text(merged_content)
                _last_rules_write_time = rules_file_path.stat().st_mtime
                logger.info(f"Updated local rules file (fallback): {rules_file_path}")
        except Exception as exception:
            logger.error(f"Error during fallback merge: {exception}")
        return
    try:
        # Always start from a fresh template
        template_content = template_path.read_text()
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        merged_content = template_content
        merged_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            merged_content,
        )
        merged_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, merged_content
        )
        merged_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, merged_content)
        # Get protocol value from the current_protocol.txt file, or prompt if missing/invalid
        protocol_value = ""
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        protocol_manager = ProtocolManager()
        protocol_name = None
        if current_protocol_path.exists():
            protocol_name = current_protocol_path.read_text().strip()
        protocol_file = None
        if protocol_name:
            # Ensure protocol_name does not have .xml extension already
            if protocol_name.endswith(".xml"):
                protocol_file = path_manager.protocol_dir / protocol_name
            else:
                protocol_file = path_manager.protocol_dir / f"{protocol_name}.xml"
            print(f"[DEBUG] Loaded protocol name: '{protocol_name}'")
            print(f"[DEBUG] Checking protocol file: {protocol_file}")
            # Fallback to template protocols if not found in user protocol dir
            if not protocol_file.exists():
                template_protocol_file = (
                    path_manager.template_dir / "protocols" / f"{protocol_name}.xml"
                )
                print(f"[DEBUG] Checking template protocol file: {template_protocol_file}")
                if template_protocol_file.exists():
                    protocol_file = template_protocol_file
        if not protocol_name or not protocol_file or not protocol_file.exists():
            # Try to extract protocol from the existing rules file using XML parsing
            if rules_file_path and rules_file_path.exists():
                try:
                    tree = ET.parse(rules_file_path)
                    root = tree.getroot()
                    # Try to find <Protocol> block
                    protocol_elem = root.find(".//Protocol")
                    if protocol_elem is not None:
                        protocol_value = ET.tostring(protocol_elem, encoding="unicode")
                        print("[DEBUG] Extracted protocol from existing rules file.")
                except Exception as e:
                    print(f"[DEBUG] Failed to extract protocol from rules file: {e}")
            if not protocol_value:
                # Prompt user to select a protocol
                protocols = protocol_manager.list_protocols()
                if not protocols:
                    logger.error("No protocols found. Cannot update rules file.")
                    return
                print("Available protocols:")
                for idx, pname in enumerate(protocols):
                    print(f"  {idx + 1}. {pname}")
                while True:
                    choice = input("Select a protocol by number or name: ").strip()
                    selected = None
                    if choice.isdigit():
                        idx = int(choice)
                        if 1 <= idx <= len(protocols):
                            selected = protocols[idx - 1]
                    elif choice in protocols:
                        selected = choice
                    if selected:
                        protocol_name = selected.strip()
                        current_protocol_path.write_text(protocol_name)
                        protocol_file = path_manager.protocol_dir / f"{protocol_name}.xml"
                        print(f"[DEBUG] User selected protocol: '{protocol_name}'")
                        print(f"[DEBUG] Checking protocol file: {protocol_file}")
                        # Fallback to template protocols if not found in user protocol dir
                        if not protocol_file.exists():
                            template_protocol_file = (
                                path_manager.template_dir / "protocols" / f"{protocol_name}.xml"
                            )
                            print(
                                f"[DEBUG] Checking template protocol file: {template_protocol_file}"
                            )
                            if template_protocol_file.exists():
                                protocol_file = template_protocol_file
                        if protocol_file.exists():
                            protocol_value = protocol_file.read_text()
                        else:
                            print(f"Protocol file not found: {protocol_file}")
                            continue
                        break
                    print(f"Invalid selection: {choice}")
        else:
            if protocol_file and protocol_file.exists():
                protocol_value = protocol_file.read_text()
        merged_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->", protocol_value, merged_content
        )
        # Overwrite the rules file with the merged content
        if not rules_file_path:
            logger.warning("No rules file configured; skipping local merge")
        else:
            rules_file_path.write_text(merged_content)
            _last_rules_write_time = rules_file_path.stat().st_mtime
            logger.info(f"Updated local rules file: {rules_file_path}")
    except Exception as exception:
        logger.error(f"Error merging rules file: {exception}")


class FileEventHandler(FileSystemEventHandler):
    """
    Handles file system events with debouncing.
    """

    def __init__(self, debounce_time: float = 0.1) -> None:
        """
        Initialize the event handler.
        Args:
            debounce_time: Time in seconds to wait before processing duplicate events
        """
        super().__init__()
        self.debounce_time: float = debounce_time
        self.processed_events: Set[str] = set()
        self.last_processed: dict[str, float] = {}

    def on_modified(self, file_event: FileSystemEvent) -> None:
        """
        Handle file modification events.
        Args:
            file_event: The file system event
        """
        if file_event.is_directory:
            return

        current_time = time.time()
        file_path = file_event.src_path

        # Ignore changes to rules files (e.g., .codex.md, .cursorrules, .windsurfrules, CLAUDE.md)
        if file_path.endswith((".codex.md", ".cursorrules", ".windsurfrules", "CLAUDE.md")):
            return

        # Check if this is a duplicate event within debounce time
        if file_path in self.last_processed:
            if current_time - self.last_processed[file_path] < self.debounce_time:
                return

        self.processed_events.add(file_path)
        self.last_processed[file_path] = current_time
        logger.info(f"File modified: {file_path}")
        # Only trigger on .ctx.*.xml files
        if (
            file_path.endswith(".ctx.architecture.xml")
            or file_path.endswith(".ctx.progress.xml")
            or file_path.endswith(".ctx.tasks.xml")
        ):
            try:
                _merge_rules_file()
            except Exception as merge_error:
                logger.error(f"Failed to update rules file: {merge_error}")


class FileMonitor:
    """
    Monitors a path for file changes.
    """

    def __init__(self, watch_path: str | Path) -> None:
        """
        Initialize the file monitor.
        Args:
            watch_path: Path to monitor for changes
        Raises:
            FileNotFoundError: If watch_path does not exist
        """
        if isinstance(watch_path, str):
            watch_path = Path(watch_path)
        if not watch_path.exists():
            raise FileNotFoundError(f"Watch path does not exist: {watch_path}")

        self.watch_path: str = watch_path
        self.event_handler: FileEventHandler = FileEventHandler()
        self.observer: ObserverType | None = None
        self._is_running: bool = False

    def _matches_rules_file(self, file_path: str) -> bool:
        """
        Check if a path matches rules file patterns.
        Args:
            file_path: Path to check
        Returns:
            bool: True if path matches rules file patterns
        """
        return file_path.endswith((".windsurfrules", ".cursorrules"))

    def start(self) -> None:
        """
        Start monitoring the watch path.
        """
        if self._is_running:
            logger.warning("Monitor is already running")
            return

        self.observer = Observer()
        self.observer.schedule(self.event_handler, self.watch_path, recursive=False)
        self.observer.start()
        self._is_running = True
        logger.info(f"Started monitoring: {self.watch_path}")

    def stop(self) -> None:
        """
        Stop monitoring the watch path.
        """
        if not self._is_running:
            logger.warning("Monitor is not running")
            return

        if self.observer:
            self.observer.stop()
            self.observer.join()
            self.observer = None
            self._is_running = False
            logger.info(f"Stopped monitoring: {self.watch_path}")

    def __enter__(self) -> "FileMonitor":
        """
        Context manager entry.
        Returns:
            FileMonitor: The monitor instance
        """
        self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """
        Context manager exit.
        """
        self.stop()

FileEventHandler = FileEventHandler

# context_commands.py
import typer
from loguru import logger

import xml.dom.minidom as minidom

import os

context_manager = ContextManager()
context_app = typer.Typer(help="Manage development contexts and their files.")


@context_app.command("get")
def get_context(name: str = typer.Argument(..., help="Name of the context to get")):
    """Get detailed information of a development context."""
    try:
        # Use display_context to print full details
        context_manager.display_context(name)
    except ContextError as e:
        # Extract underlying error if prefixed by display_context
        error_msg = str(e)
        prefix = "Failed to display context: "
        if error_msg.startswith(prefix):
            error_msg = error_msg[len(prefix) :]
        typer.echo(f"Error: Failed to get context: {error_msg}")
        raise typer.Exit(1)
    # Successful display
    raise typer.Exit(0)


def show_context_help_and_exit():
    """Show help menu and exit with error code."""
    command_rows = [
        ["erasmus context list", "List all contexts"],
        ["erasmus context create", "Create a new context"],
        ["erasmus context show", "Show context details"],
        ["erasmus context update", "Update context files"],
        ["erasmus context edit", "Edit context files"],
        ["erasmus context store", "Store the current context"],
        ["erasmus context select", "Select and load a context interactively"],
        ["erasmus context load", "Load a context by name to root .ctx XML files"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus context <command> --help")
    raise typer.Exit(1)


@context_app.callback(invoke_without_command=True)
def context_callback(ctx: typer.Context):
    """
    Manage development contexts and their files.
    """
    if ctx.invoked_subcommand is None:
        command_rows = [
            ["erasmus context list", "List all contexts"],
            ["erasmus context create", "Create a new context"],
            ["erasmus context show", "Show context details"],
            ["erasmus context update", "Update context files"],
            ["erasmus context edit", "Edit context files"],
            ["erasmus context store", "Store the current context"],
            ["erasmus context select", "Select and load a context interactively"],
            ["erasmus context load", "Load a context by name to root .ctx XML files"],
        ]
        print_table(["Command", "Description"], command_rows, title="Available Commands")
        typer.echo("\nFor more information about a command, run:")
        typer.echo("  erasmus context <command> --help")
        raise typer.Exit(0)


@context_app.command()
def create(name: str = typer.Argument(None, help="Name of the context to create")):
    """Create a new development context and display its path."""
    try:
        if not name:
            name = typer.prompt("Enter the context name")
        if not name:
            print_table(
                ["Error"],
                [["Context name is required."]],
                title="Context Creation Failed",
            )
            raise typer.Exit(1)
        context_path = context_manager.get_context_path(name)
        context_manager.create_context(name)
        # Retrieve created context model for path
        context = context_manager.get_context(name)
        # Display created context in a table
        context_rows = [[context_path]]
        print_table(["Context Path"], context_rows, title=f"Created Context: {name}")
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Creation Failed")
        raise typer.Exit(1)


@context_app.command()
def delete(name: str = typer.Argument(None, help="Name of the context to delete")):
    """Delete a context.

    This command permanently removes a context folder and its files.
    Use with caution as this action cannot be undone.
    """
    try:
        if not name:
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Deletion Failed",
                )
                raise typer.Exit(1)
            name = selected
        context_manager.delete_context(name)
        print_table(["Info"], [[f"Deleted context: {name}"]], title="Context Deleted")
        raise typer.Exit(0)
    except Exception as e:
        print_table(["Error"], [[str(e)]], title="Context Deletion Failed")
        raise typer.Exit(1)


@context_app.command()
def list():
    """List all development contexts.

    This command shows all available contexts and their basic information.
    Use 'show' to view detailed information about a specific context.
    """
    try:
        contexts = context_manager.list_contexts()
        if not contexts:
            print_table(["Info"], [["No contexts found"]], title="Available Contexts")
            return

        # Display contexts in a table
        context_rows = [[context] for context in contexts]
        print_table(["Context Name"], context_rows, title="Available Contexts")
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Listing Failed")
        show_context_help_and_exit()


def preview(text, lines=10):
    if not text:
        return ""
    split = text.splitlines()
    if len(split) > lines:
        return "\n".join(split[:lines]) + "\n..."
    return text


@context_app.command()
def show(name: str = typer.Argument(None, help="Name of the context to show")):
    """Show details of a development context.

    This command displays detailed information about a specific context,
    including file sizes and paths. If no name is supplied, it will prompt the user to select one.
    """
    try:
        if not name:
            # List available contexts and prompt for selection
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Show Failed",
                )
                raise typer.Exit(1)
            name = selected
        context_dir = context_manager.get_context_path(name)

        def read_context_file(context_dir, file_type):
            for ext in (".xml", ".md"):
                file_path = context_dir / f"ctx.{file_type}{ext}"
                if file_path.exists():
                    return file_path.read_text()
            return ""

        context_rows = [
            ["Path", str(context_dir)],
            ["Architecture", preview(read_context_file(context_dir, "architecture"))],
            ["Progress", preview(read_context_file(context_dir, "progress"))],
            ["Tasks", preview(read_context_file(context_dir, "tasks"))],
            ["Protocol", preview(read_context_file(context_dir, "protocol"))],
        ]
        print_table(
            ["Field", "Preview (first 10 lines)"],
            context_rows,
            title=f"Context: {name}",
        )
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Show Failed")
        show_context_help_and_exit()


@context_app.command()
def update(
    name: str = typer.Argument(None, help="Name of the context to update"),
    file_type: str = typer.Argument(
        None, help="Type of file to update (architecture, progress, tasks, protocol)"
    ),
    content: str = typer.Argument(None, help="Content to write to the file"),
):
    """Update a file in a development context.

    This command updates the content of a specific file in a context.
    The file type must be one of: architecture, progress, tasks, or protocol.
    """
    try:
        if not name:
            # List available contexts and prompt for selection
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Update Failed",
                )
                raise typer.Exit(1)
            name = selected
        if not file_type:
            file_type = typer.prompt(
                "Enter the file type to update (architecture, progress, tasks, protocol)"
            )
        if not file_type:
            print_table(
                ["Error"],
                [["File type is required for update."]],
                title="Context Update Failed",
            )
            raise typer.Exit(1)
        if content is None:
            content = typer.prompt(f"Enter the new content for {file_type}")
        if not content:
            print_table(
                ["Error"],
                [["Content is required for update."]],
                title="Context Update Failed",
            )
            raise typer.Exit(1)
        context_manager.update_file(name, file_type, content)
        print_table(
            ["Info"],
            [[f"Updated {file_type} in context: {name}"]],
            title="Context Updated",
        )
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Update Failed")
        show_context_help_and_exit()


@context_app.command()
def cat(
    name: str = typer.Argument(..., help="Name of the context"),
    file_type: str = typer.Argument(
        ..., help="Type of file to read (architecture, progress, tasks, protocol)"
    ),
):
    """Display the contents of a file in a development context.

    This command shows the raw contents of a specific file in a context.
    The file type must be one of: architecture, progress, tasks, or protocol.
    """
    try:
        content = context_manager.read_file(name, file_type)
        if content is None:
            print_table(
                ["Error"],
                [[f"File not found: {file_type}"]],
                title="Context Cat Failed",
            )
            logger.info("Available file types: architecture, progress, tasks, protocol")
            show_context_help_and_exit()

        # Pretty print XML for better readability
        try:
            # Parse the XML content
            dom = minidom.parseString(content)
            # Pretty print with indentation
            pretty_xml = dom.toprettyxml(indent="  ")
            print(pretty_xml)
        except Exception:
            # If XML parsing fails, print the raw content
            print(content)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Cat Failed")
        show_context_help_and_exit()


@context_app.command()
def edit(
    name: str = typer.Argument(None, help="Name of the context"),
    file_type: str = typer.Argument(
        None, help="Type of file to edit (architecture, progress, tasks, protocol)"
    ),
    editor: str = typer.Argument(None, help="Editor to use for editing"),
):
    """Edit a file in a development context.

    This command opens a file in your default editor (or specified editor).
    The file type must be one of: architecture, progress, tasks, or protocol.
    """
    if not name:
        # List available contexts and prompt for selection
        contexts = context_manager.list_contexts()
        if not contexts:
            print_table(["Info"], [["No contexts found"]], title="Available Contexts")
            raise typer.Exit(1)
        context_rows = [
            [str(index + 1), context_name] for index, context_name in enumerate(contexts)
        ]
        print_table(["#", "Context Name"], context_rows, title="Available Contexts")
        choice = typer.prompt("Select a context by number or name")
        selected = None
        if choice.isdigit():
            index = int(choice)
            if 1 <= index <= len(contexts):
                selected = contexts[index - 1]
        else:
            if choice in contexts:
                selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Context Edit Failed",
            )
            raise typer.Exit(1)
        name = selected
    if not file_type:
        file_type = typer.prompt(
            "Enter the file type to edit (architecture, progress, tasks, protocol)"
        )
    if not file_type:
        print_table(
            ["Error"],
            [["File type is required for edit."]],
            title="Context Edit Failed",
        )
        raise typer.Exit(1)
    context_dir = context_manager.get_context_path(name)
    file_path = None
    for ext in (".xml", ".md"):
        candidate = context_dir / f"ctx.{file_type}{ext}"
        if candidate.exists():
            file_path = candidate
            break
    if not file_path:
        print_table(
            ["Error"],
            [[f"File does not exist: {file_type}"]],
            title="Context Edit Failed",
        )
        raise typer.Exit(1)
    editor_cmd = editor or os.environ.get("EDITOR", "nano")
    os.system(f"{editor_cmd} {file_path}")
    print_table(
        ["Info"],
        [[f"Edited {file_type} in context: {name}"]],
        title="Context Edited",
    )
    raise typer.Exit(0)


@context_app.command()
def store():
    """Store the current context by reading the architecture file, parsing the title,
    sanitizing it, and saving the current context files to a new folder.

    This command will:
    1. Read the current architecture file
    2. Extract the title from it
    3. Create a new context folder with the sanitized title
    4. Copy the current architecture, progress, and tasks files to the new folder
    """
    try:
        context_name = context_manager.store_context()
        print_table(
            ["Info"],
            [[f"Successfully stored context as: {context_name}"]],
            title="Context Stored",
        )
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Store Failed")
        show_context_help_and_exit()


@context_app.command("load")
def load_context(name: str = typer.Argument(None, help="Name of the context to load")):
    """Load a stored context by name into the root .ctx XML files.

    If no name is supplied, you will be prompted to select one interactively.
    """
    try:
        if not name:
            # List available contexts and prompt for selection
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Load Failed",
                )
                raise typer.Exit(1)
            name = selected
        context_manager.load_context(name)
        print_table(["Info"], [[f"Loaded context: {name}"]], title="Context Loaded")
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Load Failed")
        raise typer.Exit(1)


@context_app.command("select")
def select_context():
    """Interactively select a context and load its XML files."""
    base_dir = context_manager.base_path
    # Gather available contexts
    try:
        contexts = sorted(
            [
                context_directory.name
                for context_directory in base_dir.iterdir()
                if context_directory.is_dir()
            ]
        )
    except Exception as exception:
        typer.echo(f"Error: Unable to list contexts: {exception}")
        raise typer.Exit(1)
    if not contexts:
        typer.echo("No contexts found to select.")
        raise typer.Exit(1)
    # Display contexts in a table
    context_rows = [[str(index + 1), context_name] for index, context_name in enumerate(contexts)]
    print_table(["#", "Context Name"], context_rows, title="Available Contexts")
    choice = typer.prompt("Select a context by number or name")
    # Determine selected context name
    selected = None
    if choice.isdigit():
        index = int(choice)
        if 1 <= index <= len(contexts):
            selected = contexts[index - 1]
    else:
        if choice in contexts:
            selected = choice
    if not selected:
        typer.echo(f"Error: Invalid selection: {choice}")
        raise typer.Exit(1)
    # Load the selected context
    try:
        context_manager.load_context(selected)
        typer.echo(f"Loaded context: {selected}")
        raise typer.Exit(0)
    except ContextError as exception:
        typer.echo(f"Error: Failed to load context: {exception}")
        raise typer.Exit(1)

get_context = get_context
show_context_help_and_exit = show_context_help_and_exit
context_callback = context_callback
create = create
delete = delete
list = list
preview = preview
show = show
update = update
cat = cat
edit = edit
store = store
load_context = load_context
select_context = select_context

# protocol_commands.py
import typer
from pathlib import Path
from loguru import logger


import os
import re

protocol_manager = ProtocolManager()
protocol_app = typer.Typer(help="Manage development protocols.")


def show_protocol_help_and_exit():
    """Show help menu and exit with error code."""
    command_rows = [
        ["erasmus protocol list", "List all protocols"],
        ["erasmus protocol create", "Create a new protocol"],
        ["erasmus protocol show", "Show protocol details"],
        ["erasmus protocol update", "Update a protocol"],
        ["erasmus protocol edit", "Edit a protocol"],
        ["erasmus protocol delete", "Delete a protocol"],
        ["erasmus protocol select", "Select and display a protocol"],
        ["erasmus protocol load", "Load a protocol as active"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Protocol Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus protocol <command> --help")
    raise typer.Exit(1)


@protocol_app.callback(invoke_without_command=True)
def protocol_callback(ctx: typer.Context):
    """
    Manage development protocols.
    """
    if ctx.invoked_subcommand is None:
        command_rows = [
            ["erasmus protocol list", "List all protocols"],
            ["erasmus protocol create", "Create a new protocol"],
            ["erasmus protocol show", "Show protocol details"],
            ["erasmus protocol update", "Update a protocol"],
            ["erasmus protocol edit", "Edit a protocol"],
            ["erasmus protocol delete", "Delete a protocol"],
            ["erasmus protocol select", "Select and display a protocol"],
            ["erasmus protocol load", "Load a protocol as active"],
        ]
        print_table(
            ["Command", "Description"],
            command_rows,
            title="Available Protocol Commands",
        )
        typer.echo("\nFor more information about a command, run:")
        typer.echo("  erasmus protocol <command> --help")
        raise typer.Exit(0)


@protocol_app.command()
def create(
    name: str = typer.Argument(None, help="Name of the protocol to create"),
    content: str = typer.Argument(None, help="Content of the protocol"),
):
    """Create a new protocol.

    This command creates a new protocol file with optional content.
    The protocol name will be sanitized to ensure it's safe for filesystem operations.
    """
    try:
        if not name:
            name = typer.prompt("Enter the protocol name")
        if not name:
            print_table(
                ["Error"],
                [["Protocol name is required."]],
                title="Protocol Creation Failed",
            )
            raise typer.Exit(1)
        if content is None:
            content = typer.prompt("Enter the protocol content (leave blank to use template)")
        protocol_manager.create_protocol(name, content)
        logger.info(f"Created protocol: {name}")
        print_table(["Info"], [[f"Created protocol: {name}"]], title="Protocol Created")
        raise typer.Exit(0)
    except ProtocolError as e:
        logger.error(f"Failed to create protocol: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def update(
    name: str = typer.Argument(None, help="Name of the protocol to update"),
    content: str = typer.Argument(None, help="New content for the protocol"),
):
    """Update an existing protocol.

    This command updates the content of an existing protocol.
    The protocol must exist before it can be updated.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Update Failed",
                )
                raise typer.Exit(1)
            name = selected
        if content is None:
            content = typer.prompt("Enter the new protocol content")
        if not content:
            print_table(
                ["Error"],
                [["Protocol content is required."]],
                title="Protocol Update Failed",
            )
            raise typer.Exit(1)
        protocol_manager.update_protocol(name, content)
        logger.info(f"Updated protocol: {name}")
        print_table(["Info"], [[f"Updated protocol: {name}"]], title="Protocol Updated")
        raise typer.Exit(0)
    except ProtocolError as e:
        logger.error(f"Failed to update protocol: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def delete(name: str = typer.Argument(None, help="Name of the protocol to delete")):
    """Delete a protocol.

    This command permanently removes a protocol file.
    Use with caution as this action cannot be undone.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Deletion Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol_manager.delete_protocol(name)
        logger.info(f"Deleted protocol: {name}")
        print_table(["Info"], [[f"Deleted protocol: {name}"]], title="Protocol Deleted")
        raise typer.Exit(0)
    except (ProtocolError, PermissionError, FileNotFoundError) as e:
        print_table(["Error"], [[str(e)]], title="Protocol Deletion Failed")
        raise typer.Exit(1)


@protocol_app.command()
def list():
    """List all protocols.

    This command shows all available protocols and their basic information.
    Use 'show' to view detailed information about a specific protocol.
    """
    try:
        protocols = protocol_manager.list_protocols()
        if not protocols:
            typer.echo("No protocols found")
            return

        # Display protocols in a table
        protocol_rows = [[protocol] for protocol in protocols]
        print_table(["Protocol Name"], protocol_rows, title="Available Protocols")
    except ProtocolError as e:
        logger.error(f"Failed to list protocols: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def show(name: str = typer.Argument(None, help="Name of the protocol to show")):
    """Show details of a protocol.

    This command displays detailed information about a specific protocol,
    including its content and metadata.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Show Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Show Failed",
            )
            raise typer.Exit(1)
        print_table(["Info"], [[f"Protocol: {name}"]], title="Protocol Details")
        typer.echo(f"Path: {protocol.path}")
        typer.echo(f"Content:\n{protocol.content}")
        raise typer.Exit(0)
    except ProtocolError as e:
        print_table(["Error"], [[str(e)]], title="Protocol Show Failed")
        raise typer.Exit(1)


@protocol_app.command("select")
def select_protocol():
    """Interactively select a protocol, display its details, and update the rules file with it."""
    try:
        protocols = protocol_manager.list_protocols()
        if not protocols:
            print_table(["Info"], [["No protocols found"]], title="Available Protocols")
            raise typer.Exit(1)
        protocol_rows = [
            [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
        ]
        print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            index = int(choice)
            if 1 <= index <= len(protocols):
                selected = protocols[index - 1]
        else:
            if choice in protocols:
                selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        protocol = protocol_manager.get_protocol(selected)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {selected}"]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        print_table(["Info"], [[f"Selected protocol: {selected}"]], title="Protocol Selected")
        typer.echo(f"Path: {protocol.path}")
        typer.echo(f"Content:\n{protocol.content}")
        # Write the selected protocol name to .erasmus/current_protocol.txt


        path_manager = get_path_manager()
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        current_protocol_path.write_text(selected)
        # Also update the rules file as in load
        template_path = path_manager.template_dir / "meta_rules.xml"
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.xml template not found."]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        meta_rules_content = template_path.read_text()
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        meta_rules_content = meta_rules_content.replace(
            "<!--ARCHITECTURE-->\n  <!--/ARCHITECTURE-->", architecture
        )
        meta_rules_content = meta_rules_content.replace(
            "<!--PROGRESS-->\n  <!--/PROGRESS-->", progress
        )
        meta_rules_content = meta_rules_content.replace("<!--TASKS-->\n  <!--/TASKS-->", tasks)
        meta_rules_content = meta_rules_content.replace(
            "<!--PROTOCOL-->\n  <!--/PROTOCOL-->", protocol.content
        )
        rules_file = path_manager.get_rules_file()
        if not rules_file:
            print_table(
                ["Error"],
                [["No rules file configured."]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Updated rules file with protocol: {selected}"]],
            title="Rules File Updated",
        )
        raise typer.Exit(0)
    except ProtocolError as exception:
        print_table(["Error"], [[str(exception)]], title="Protocol Select Failed")
        raise typer.Exit(1)


@protocol_app.command("load")
def load_protocol(
    name: str = typer.Argument(None, help="Name of the protocol to load"),
):
    """Interactively select and load a protocol, merging it into the rules file with current context."""
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Load Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Load Failed",
            )
            raise typer.Exit(1)
        # Write the selected protocol name to .erasmus/current_protocol.txt


        path_manager = get_path_manager()
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        current_protocol_path.write_text(name)
        # Load meta_rules.xml template
        template_path = path_manager.template_dir / "meta_rules.xml"
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.xml template not found."]],
                title="Protocol Load Failed",
            )
            raise typer.Exit(1)
        meta_rules_content = template_path.read_text()
        # Read current context files
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        # Replace context and protocol blocks using regex for robustness
        meta_rules_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            meta_rules_content,
        )
        meta_rules_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, meta_rules_content
        )
        meta_rules_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, meta_rules_content)
        meta_rules_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->",
            protocol.content,
            meta_rules_content,
        )
        # Write to rules file
        rules_file = path_manager.get_rules_file()
        if not rules_file:
            print_table(["Error"], [["No rules file configured."]], title="Protocol Load Failed")
            raise typer.Exit(1)
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Loaded protocol: {name} into rules file"]],
            title="Protocol Loaded",
        )
        raise typer.Exit(0)
    except ProtocolError as exception:
        print_table(["Error"], [[str(exception)]], title="Protocol Load Failed")
        raise typer.Exit(1)


@protocol_app.command()
def edit(
    name: str = typer.Argument(None, help="Name of the protocol to edit"),
    editor: str = typer.Argument(None, help="Editor to use for editing"),
):
    """Edit a protocol file in your default editor (or specified editor)."""
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Edit Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Edit Failed",
            )
            raise typer.Exit(1)
        file_path = protocol.path
        editor_cmd = editor or os.environ.get("EDITOR", "nano")
        os.system(f"{editor_cmd} {file_path}")
        print_table(["Info"], [[f"Edited protocol: {name}"]], title="Protocol Edited")
        raise typer.Exit(0)
    except ProtocolError as error:
        print_table(["Error"], [[str(error)]], title="Protocol Edit Failed")
        raise typer.Exit(1)


@protocol_app.command("watch")
def watch_protocol():
    """Monitor .ctx.*.xml files for changes and update the rules file with the current protocol. Does NOT monitor the rules file itself."""
    import time



    path_manager = get_path_manager()
    protocol_manager = ProtocolManager()
    ctx_files = [
        path_manager.get_architecture_file(),
        path_manager.get_progress_file(),
        path_manager.get_tasks_file(),
    ]
    template_path = path_manager.template_dir / "meta_rules.xml"
    rules_file = path_manager.get_rules_file()
    current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"

    def get_protocol_name():
        if current_protocol_path.exists():
            return current_protocol_path.read_text().strip()
        protocols = protocol_manager.list_protocols()
        if not protocols:
            print_table(["Error"], [["No protocols found."]], title="Protocol Watch Failed")
            raise typer.Exit(1)
        protocol_rows = [[str(i + 1), p] for i, p in enumerate(protocols)]
        print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            idx = int(choice)
            if 1 <= idx <= len(protocols):
                selected = protocols[idx - 1]
        elif choice in protocols:
            selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Protocol Watch Failed",
            )
            raise typer.Exit(1)
        current_protocol_path.write_text(selected)
        return selected

    def merge_and_write():
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.xml template not found."]],
                title="Protocol Watch Failed",
            )
            return
        meta_rules_content = template_path.read_text()
        architecture = ctx_files[0].read_text() if ctx_files[0].exists() else ""
        progress = ctx_files[1].read_text() if ctx_files[1].exists() else ""
        tasks = ctx_files[2].read_text() if ctx_files[2].exists() else ""
        meta_rules_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            meta_rules_content,
        )
        meta_rules_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, meta_rules_content
        )
        meta_rules_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, meta_rules_content)
        protocol_name = get_protocol_name()
        protocol = protocol_manager.get_protocol(protocol_name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {protocol_name}"]],
                title="Protocol Watch Failed",
            )
            return
        meta_rules_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->",
            protocol.content,
            meta_rules_content,
        )
        if not rules_file:
            print_table(
                ["Error"],
                [["No rules file configured."]],
                title="Protocol Watch Failed",
            )
            return
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Rules file updated with protocol: {protocol_name}"]],
            title="Rules File Updated",
        )

    # Track last modification times for only the .ctx.*.xml files
    last_mtimes = [f.stat().st_mtime if f.exists() else 0 for f in ctx_files]
    print_table(["Info"], [["Watching .ctx.*.xml files for changes..."]], title="Protocol Watch")
    try:
        while True:
            changed = False
            for i, f in enumerate(ctx_files):
                if f.exists():
                    mtime = f.stat().st_mtime
                    if mtime != last_mtimes[i]:
                        changed = True
                        last_mtimes[i] = mtime
            if changed:
                merge_and_write()
            time.sleep(1)
    except KeyboardInterrupt:
        print_table(["Info"], [["Stopped watching context files."]], title="Protocol Watch")



show_protocol_help_and_exit = show_protocol_help_and_exit
protocol_callback = protocol_callback
create = create
update = update
delete = delete
list = list
show = show
select_protocol = select_protocol
load_protocol = load_protocol
edit = edit
watch_protocol = watch_protocol

# setup_commands.py
import typer
from pathlib import Path




setup_app = typer.Typer(help="Setup Erasmus: initialize project, environment, and context.")

console = get_console()


def set_erasmus_path():
    import os

    shell = os.environ.get("SHELL", "").split("/")[-1]
    home = str(Path.home())
    added = False
    msg = ""
    erasmus_func = """erasmus() {
    if [ -f erasmus.py ]; then
        uv run erasmus.py "$@"
    else
        command erasmus "$@"
    fi
}"""
    erasmus_fish_func = """function erasmus
    if test -f erasmus.py
        uv run erasmus.py $argv
    else
        command erasmus $argv
    end
end"""
    if shell == "bash":
        rc = f"{home}/.bashrc"
        if not Path(rc).read_text(errors="ignore").find("erasmus()") >= 0:
            with open(rc, "a") as f:
                f.write(f"\n{erasmus_func}\n")
            msg = f"Added erasmus function to {rc}"
            added = True
    elif shell == "zsh":
        rc = f"{home}/.zshrc"
        if not Path(rc).read_text(errors="ignore").find("erasmus()") >= 0:
            with open(rc, "a") as f:
                f.write(f"\n{erasmus_func}\n")
            msg = f"Added erasmus function to {rc}"
            added = True
    elif shell == "fish":
        rc = f"{home}/.config/fish/config.fish"
        if not Path(rc).read_text(errors="ignore").find("function erasmus") >= 0:
            with open(rc, "a") as f:
                f.write(f"\n{erasmus_fish_func}\n")
            msg = f"Added erasmus function to {rc}"
            added = True
    elif shell in ("csh", "tcsh"):
        rc = f"{home}/.cshrc" if shell == "csh" else f"{home}/.tcshrc"
        if not Path(rc).read_text(errors="ignore").find("alias erasmus") >= 0:
            with open(rc, "a") as f:
                f.write(
                    '\nalias erasmus "if ( -f erasmus.py ) uv run erasmus.py !*; else command erasmus !*; endif"\n'
                )
            msg = f"Added erasmus alias to {rc}"
            added = True
    else:
        msg = f"Unsupported shell: {shell}. Please add the erasmus function to your shell rc file manually."
    if added:
        print(msg)
    else:
        print(msg or "erasmus function/alias already present in your shell rc file.")


@setup_app.callback(invoke_without_command=True)
def setup_callback(ctx: typer.Context):
    if ctx.invoked_subcommand is not None:
        return
    """Interactive setup for Erasmus: configure IDE, project, context, and protocol."""
    # Step 1: Use path manager for IDE detection and prompting
    path_manager = get_path_manager()
    print_table(["Info"], [[f"IDE detected: {path_manager.ide.name}"]], title="Setup")

    # Step 2: Prompt for project name
    project_name = typer.prompt("Enter the project name")
    if not project_name:
        print_table(["Error"], [["Project name is required."]], title="Setup Failed")
        raise typer.Exit(1)

    # Step 3: Create project directory and context using path manager
    project_dir = Path.cwd() / project_name
    project_dir.mkdir(parents=True, exist_ok=True)
    print_table(["Info"], [[f"Project directory created: {project_dir}"]], title="Setup")

    # Step 4: Use path manager for all Erasmus folders inside project
    erasmus_dir = path_manager.erasmus_dir
    context_dir = path_manager.context_dir
    protocol_dir = path_manager.protocol_dir
    template_dir = path_manager.template_dir
    for d in [erasmus_dir, context_dir, protocol_dir, template_dir]:
        d.mkdir(parents=True, exist_ok=True)
    print_table(["Info"], [[f"Erasmus folders created in: {erasmus_dir}"]], title="Setup")

    # Step 5: Create a template context in the context folder and update root .ctx.*.xml files
    context_manager = ContextManager(base_dir=str(context_dir))
    context_manager.create_context(project_name)
    print_table(["Info"], [[f"Template context created: {project_name}"]], title="Setup")
    # Load the new context to root .ctx.*.xml files
    context_manager.load_context(project_name)
    set_erasmus_path()
    print_table(
        ["Info"],
        [[f"Root .ctx.*.xml files updated for: {project_name}"]],
        title="Setup",
    )

    # Step 6: Prompt for protocol selection
    protocol_manager = ProtocolManager()
    protocols = protocol_manager.list_protocols()
    if not protocols:
        print_table(["Error"], [["No protocols found."]], title="Setup Failed")
        raise typer.Exit(1)
    protocol_rows = [[str(i + 1), p] for i, p in enumerate(protocols)]
    print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
    while True:
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            idx = int(choice)
            if 1 <= idx <= len(protocols):
                selected = protocols[idx - 1]
        elif choice in protocols:
            selected = choice
        if selected:
            # Write the selected protocol to current_protocol.txt using path manager
            current_protocol_path = path_manager.erasmus_dir / "current_protocol.txt"
            current_protocol_path.write_text(selected)
            print_table(["Info"], [[f"Protocol set to: {selected}"]], title="Setup")
            # Immediately update the rules file to reflect the selected protocol
            try:


                _merge_rules_file()
                print_table(
                    ["Info"],
                    [[f"Rules file updated with protocol: {selected}"]],
                    title="Setup",
                )
            except Exception as e:
                print_table(
                    ["Error"],
                    [[f"Failed to update rules file: {e}"]],
                    title="Setup Warning",
                )
            break
        print(f"Invalid selection: {choice}")

    print_table(["Info"], [["Erasmus setup complete."]], title="Setup Success")
    raise typer.Exit(0)

set_erasmus_path = set_erasmus_path
setup_callback = setup_callback

# main.py
import typer



app = typer.Typer(
    help="Erasmus - Development Context Management System\n\nA tool for managing development contexts, protocols, and Model Context Protocol (MCP) interactions.\n\nFor more information, visit: https://github.com/hydra-dynamics/erasmus"
)

# Add sub-commands
app.add_typer(context_app, name="context", help="Manage development contexts")
app.add_typer(protocol_app, name="protocol", help="Manage protocols")
app.add_typer(setup_app, name="setup", help="Setup Erasmus")


# Custom error handler for unknown commands and argument errors
def print_main_help_and_exit():
    try:
        from rich.console import Console

        console = Console()
        banner = [
            ("green", " _____                                  "),
            ("green", "|  ___|                                 "),
            ("cyan", "| |__ _ __ __ _ ___ _ __ ___  _   _ ___ "),
            ("green", "|  __| '__/ _` / __| '_ ` _ \\| | | / __|"),
            ("cyan", "| |__| | | (_| \\__ \\ | | | | | |_| \\__ \\"),
            ("green", "\\____/_|  \\__,_|___/_| |_| |_|\\__,_|___/"),
        ]
        for color, line in banner:
            console.print(line, style=color)
    except ImportError:
        # Fallback to plain text if rich is not available
        typer.echo(r"""
 _____                                  
|  ___|                                 
| |__ _ __ __ _ ___ _ __ ___  _   _ ___ 
|  __| '__/ _` / __| '_ ` _ \| | | / __|
| |__| | | (_| \__ \ | | | | | |_| \__ \
\____/_|  \__,_|___/_| |_| |_|\__,_|___/
""")
    typer.echo("\n Development Context Management System\n")
    command_rows = [
        ["erasmus context", "Manage development contexts"],
        ["erasmus protocol", "Manage protocols"],
        ["erasmus setup", "Setup Erasmus"],
        ["erasmus watch", "Watch for .ctx file changes"],
        ["erasmus status", "Show current status"],
        ["erasmus version", "Show Erasmus version"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Erasmus Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus <command> --help")
    raise typer.Exit(1)


@app.callback(invoke_without_command=True)
def main(ctx: typer.Context):
    """
    Erasmus - Development Context Management System
    """
    if ctx.invoked_subcommand is None:
        print_main_help_and_exit()


# Patch Typer's error handling to show help on unknown command
from typer.main import get_command
from typer.core import TyperGroup
from click import UsageError

original_command = get_command(app)


class HelpOnErrorGroup(TyperGroup):
    def main(self, *args, **kwargs):
        try:
            return super().main(*args, **kwargs)
        except UsageError as e:
            typer.echo(str(e))
            print_main_help_and_exit()


app.command_class = HelpOnErrorGroup


@app.command()
def watch():  # pragma: no cover
    """Watch for changes to .ctx files and update the IDE rules file automatically.

    Press Ctrl+C to stop watching.
    """
    import time



    pm = get_path_manager()
    root = pm.get_root_dir()
    monitor = FileMonitor(str(root))
    monitor.start()
    typer.echo(f"Watching {root} for .ctx file changes (Ctrl+C to stop)...")
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        monitor.stop()
        typer.echo("Stopped watching.")


@app.command()
def status():
    """Show the current Erasmus context and protocol status."""


    import os

    context_manager = ContextManager()
    protocol_manager = ProtocolManager()

    # Current context (from .erasmus/current_context.txt if exists)
    current_context = None
    current_context_path = os.path.join(context_manager.base_dir.parent, "current_context.txt")
    if os.path.exists(current_context_path):
        with open(current_context_path) as f:
            current_context = f.read().strip()

    # List all contexts
    try:
        contexts = context_manager.list_contexts()
    except Exception as e:
        contexts = []

    # List all protocols
    try:
        protocols = protocol_manager.list_protocols()
    except Exception as e:
        protocols = []

    print_table(
        ["Status", "Value"],
        [
            ["Current Context", current_context or "(none set)"],
            ["Available Contexts", ", ".join(contexts) if contexts else "(none)"],
            ["Available Protocols", ", ".join(protocols) if protocols else "(none)"],
        ],
        title="Erasmus Status",
    )


@app.command()
def version():
    """Show the Erasmus version."""


    typer.echo(f"Erasmus version: {erasmus.__version__}")




if __name__ == '__main__':
    app()
